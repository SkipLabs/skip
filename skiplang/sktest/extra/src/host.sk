module SKTest;

fun signal_name(code: Int): String {
  Posix.Signal::fromCode(code) match {
  | Some(sig) -> sig.toString()
  | None() -> `signal ${code}`
  }
}

fun each_assigned_test(
  tests: readonly Map<String, readonly Sequence<Test>>,
  filter: String,
  njobs: Int,
  f: (Int, String, Test) -> void,
): void {
  i = 0;
  for (testSuite in tests.keys()) {
    for (test in tests[testSuite]) {
      if (!`${testSuite}.${test.name}`.contains(filter)) {
        continue
      };
      !i = i + 1;
      f(i % njobs, testSuite, test)
    }
  }
}

fun assign_all_tests(
  tests: readonly Map<String, readonly Sequence<Test>>,
  filter: String,
  njobs: Int,
): Array<Array<(String, Test)>> {
  assigned = Array::fillBy(njobs, _ -> mutable Vector[]);
  each_assigned_test(tests, filter, njobs, (rank, testSuite, test) -> {
    assigned[rank].push((testSuite, test))
  });
  assigned.map(v -> v.toArray())
}

fun test_job(
  tests: readonly Map<String, readonly Sequence<Test>>,
  filter: String,
  njobs: Int,
  rank: Int,
): void {
  stdout = mutable IO.File(Posix.dup(IO.stdout().fileno));
  each_assigned_test(tests, filter, njobs, (r, testSuite, test) -> {
    if (r == rank) {
      stdout_file = Posix.mkstemp(Path.join(Environ.temp_dir(), "XXXXXX"));
      Posix.dup2(stdout_file.fileno, IO.stdout().fileno);
      stderr_file = Posix.mkstemp(Path.join(Environ.temp_dir(), "XXXXXX"));
      Posix.dup2(stderr_file.fileno, IO.stderr().fileno);

      res = run_test(
        test,
        TestResult{
          name => test.name,
          suite => testSuite,
          file => test.file,
          line => test.lineno,
        },
      );

      flushStdout();
      _ = Posix.lseek(stdout_file.fileno, 0, Posix.SeekSet());
      _ = Posix.lseek(stderr_file.fileno, 0, Posix.SeekSet());
      !res = res with {
        stdout => stdout_file.read_to_string().fromSuccess(),
        stderr => stderr_file.read_to_string().fromSuccess(),
      };

      stdout_file.close();
      stderr_file.close();

      stdout.write_all((res.toJSON() + "\n").bytes()).fromSuccess();
    }
  });
  skipExit(0)
}

fun test_harness(tests: readonly Map<String, readonly Sequence<Test>>): void {
  args = Cli.Command("tests")
    .about("Run tests")
    .arg(
      Cli.Arg::string("filter")
        .positional()
        .about(
          "If specified, only run tests containing this string in their names",
        ),
    )
    // TODO: Expose flag(s) to handle test report format(s) selection.
    .arg(
      Cli.Arg::int("jobs")
        .long("jobs")
        .short("j")
        .about("Number of parallel jobs, defaults to # of CPUs")
        .default(8), // TODO: Properly determine available cores.
    )
    .arg(Cli.Arg::string("junitxml").about("Generate a JUnit XML report"))
    .arg(
      Cli.Arg::bool("verbose")
        .long("verbose")
        .short("v")
        .about("Use verbose output"),
    )
    .help()
    .parseArgs();

  filter = args.maybeGetString("filter").default("");
  Environ.varOpt("SKTEST_RANK") match {
  | Some(rank) ->
    test_job(
      tests,
      Environ.var("SKTEST_FILTER"),
      Environ.var("SKTEST_JOBS").toInt(),
      rank.toInt(),
    )
  | None() -> void
  };

  reporters = mutable Vector<mutable TestReporter>[
    mutable BasicTestReporter{color => true},
  ];
  args.maybeGetString("junitxml").each(path ->
    reporters.push(mutable XmlTestReporter{output => Some(path)})
  );

  njobs = args.getInt("jobs");
  expected_tests = assign_all_tests(tests, filter, njobs);

  procs = Array::fillBy(njobs, rank -> {
    Posix.Popen::create{
      args => Array[Environ.current_exe()],
      env => Map[
        "SKTEST_RANK" => rank.toString(),
        "SKTEST_JOBS" => njobs.toString(),
        "SKTEST_FILTER" => filter,
      ],
      stdout => true,
      stderr => true,
    }.fromSuccess()
  });
  readers = procs.map(p -> mutable IO.BufferedReader(p.stdout.fromSome()));
  pollfds = Array::mcreateFromItems(
    procs.map(p -> Posix.Pollfd::create(p.stdout.fromSome().fileno)),
  );
  reported_tests = Array::fillBy(njobs, _ -> mutable Set[]);
  open_fds = procs.size();
  success = true;
  while (open_fds > 0) {
    _ = Posix.poll(pollfds);
    for ((i, pfd) in pollfds.items()) {
      if (pfd.fd == -1) continue;
      if (pfd.pollin()) {
        loop {
          line = readers[i].read_line() match {
          | Failure(err) -> throw err
          | Success("") ->
            pollfds.set(i, Posix.Pollfd::create(-1));
            !open_fds = open_fds - 1;
            break void
          | Success(line) -> line
          };
          res = TestResult::fromJSON(line);
          reported_tests[i].insert(`${res.suite}.${res.name}`);
          if (res.result != "success") {
            !success = false
          };
          reporters.each(x -> x.report(res));
          if (!readers[i].has_buffered_data()) {
            break void
          }
        }
      } else if (pfd.pollerr() || pfd.pollhup()) {
        pollfds.set(i, Posix.Pollfd::create(-1));
        !open_fds = open_fds - 1
      }
    }
  };

  for (rank in Range(0, procs.size())) {
    p = procs[rank];
    // Read stderr before wait() which calls closefds().
    stderr_output = p.stderr match {
    | Some(f) ->
      f.read_to_string() match {
      | Success(s) -> s
      | Failure(_) -> ""
      }
    | None() -> ""
    };

    exitstatus = p.wait();

    if (!exitstatus.success()) {
      !success = false;
      reason = exitstatus match {
      | Posix.WSignaled(sig) -> `killed by ${signal_name(sig)}`
      | Posix.WExited(code) -> `exited with code ${code}`
      | Posix.WStopped(sig) -> `stopped by ${signal_name(sig)}`
      };
      crash_desc = `subprocess ${rank} ${reason}`;

      unreported = 0;
      for ((testSuite, test) in expected_tests[rank]) {
        key = `${testSuite}.${test.name}`;
        if (!reported_tests[rank].contains(key)) {
          !unreported = unreported + 1;
          res = TestResult{
            name => test.name,
            suite => testSuite,
            file => test.file,
            line => test.lineno,
            result => "error",
            failure_type => "SubprocessCrash",
            failure_message => crash_desc,
            stderr => stderr_output,
          };
          reporters.each(x -> x.report(res))
        }
      };

      // If all tests were reported but the process still crashed,
      // report a standalone crash error.
      if (unreported == 0) {
        res = TestResult{
          name => "(subprocess crash)",
          suite => "(harness)",
          file => "",
          line => 0,
          result => "error",
          failure_type => "SubprocessCrash",
          failure_message => `${crash_desc} (all tests completed before crash)`,
          stderr => stderr_output,
        };
        reporters.each(x -> x.report(res))
      }
    }
  };

  reporters.each(r -> r.finish());

  if (!success) {
    skipExit(1)
  }
}

module end;
