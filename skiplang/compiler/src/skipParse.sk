/**
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

/*****************************************************************************/
/* Utility functions to perform the parsing. */
/*****************************************************************************/
module alias Error = SkipError;

module FileCache;

class InputSource(
  /// Name of the package this source file belongs to, if any.
  pkg_opt: ?String,
  /// Absolute path of the original source file. NOTE: As we read the
  /// source files of dependencies from the compiled `.sklib`s, the
  /// path does not always map to a file with the same contents on the
  /// actual file system (and sometimes maps to no file at all, as in
  /// the case of using the bootstrap `libstd.sklib`).
  path: String,
) extends SKStore.Key uses Hashable

const fileDirName: SKStore.DirName = SKStore.DirName::create("/fileCache/");
const fileDir: SKStore.EHandle<
  InputSource,
  SKStore.StringFile,
> = SKStore.EHandle(
  InputSource::keyType,
  SKStore.StringFile::type,
  fileDirName,
);

class InputPackage(
  name: ?String,
  srcs: Array<(String, Int)>,
) extends SKStore.File

// Contains the paths of all source files the analysis of which has
// been kept so far.
const allFilesDirName: SKStore.DirName = SKStore.DirName::create(
  "/allFilesCache/",
);
const allFilesDir: SKStore.EHandle<SKStore.IID, InputPackage> = SKStore.EHandle(
  SKStore.IID::keyType,
  InputPackage::type,
  allFilesDirName,
);

fun pkgDelta(
  old_srcs: Array<(String, Int)>,
  new_srcs: Array<(String, Int)>,
): (Array<String>, Array<String>, Array<String>) {
  added_files = mutable Vector[];
  modified_files = mutable Vector[];
  deleted_files = mutable Vector[];

  // FIXME: This is O(n^2).
  for ((src, mtime) in new_srcs) {
    old_srcs.find(s -> s.i0 == src) match {
    | Some((_, old_mtime)) ->
      if (mtime != old_mtime) {
        modified_files.push(src)
      }
    | None() -> added_files.push(src)
    }
  };

  // FIXME: This is O(n^2).
  for ((src, _) in old_srcs) {
    if (!new_srcs.any(s -> s.i0 == src)) {
      deleted_files.push(src)
    }
  };

  (
    added_files.collect(Array),
    modified_files.collect(Array),
    deleted_files.collect(Array),
  )
}

fun writeFiles(
  context: mutable SKStore.Context,
  file_names: Array<String>,
  dependencies: Map<String, (String, Sklib.Metadata)>,
  lib_name_opt: ?String,
): void {
  // Files in the current graph.
  current_files = mutable Map[
    lib_name_opt => file_names
      .map(fn ->
        (
          fn,
          FileSystem.getLastModificationTime(fn),
          FileSystem.readTextFile(fn),
        )
      )
      .collect(Array),
  ];
  for (dep_name => dep in dependencies) {
    (_, dep_meta) = dep;
    current_files.set(Some(dep_name), dep_meta.sources)
  };

  // Files kept in the previous run.
  old_files = mutable Map[];
  for (pkg in allFilesDir.unsafeGetArray(context, SKStore.IID(0))) {
    old_files.set(pkg.name, pkg.srcs)
  };

  stale_pkgs = mutable Vector<?String>[];
  if (lib_name_opt is Some _) {
    // Invalidate non-package source files.
    stale_pkgs.push(None())
  };
  // For each current package, invalidate files that were modified or deleted.
  for (pkg_opt => srcs in current_files) {
    (added_files, modified_files, deleted_files) = if (
      old_files.containsKey(pkg_opt)
    ) {
      pkgDelta(old_files[pkg_opt], srcs.map(src -> (src.i0, src.i1)));
    } else {
      (srcs.map(src -> src.i0), Array[], Array[])
    };

    if (
      added_files.isEmpty() &&
      modified_files.isEmpty() &&
      deleted_files.isEmpty()
    ) {
      continue
    };
    stale_pkgs.push(pkg_opt);

    // Update added/modified files.
    for (src_path in added_files.concat(modified_files)) {
      // FIXME: This is O(n).
      src_contents = srcs.find(src ~> src.i0 == src_path).fromSome().i2;
      fileDir.writeArray(
        context,
        InputSource(pkg_opt, src_path),
        Array[SKStore.StringFile(src_contents)],
      )
    };
    // Invalidate deleted files.
    for (src_path in deleted_files) {
      fileDir.writeArray(
        context,
        InputSource(pkg_opt, src_path),
        Array[SKStore.StringFile("")],
      )
    }
  };

  new_old_files = current_files
    .map((_, srcs) -> srcs.map(src -> (src.i0, src.i1)))
    .clone();
  // Keep analysis for all non-stale packages.
  for (pkg_opt => srcs in old_files) {
    // FIXME: This is O(n).
    if (stale_pkgs.contains(pkg_opt)) {
      continue
    };
    new_old_files.set(pkg_opt, srcs)
  };

  allFilesDir.writeArray(
    context,
    SKStore.IID(0),
    new_old_files
      .items()
      .map(pkg -> InputPackage(pkg.i0, pkg.i1))
      .collect(Array),
  );
}

module end;

module SkipParse;

const astDirName: SKStore.DirName = SKStore.DirName::create("/astCache/");
const astDir: SKStore.EHandle<SKStore.SID, DefsFile> = SKStore.EHandle(
  SKStore.SID::keyType,
  DefsFile::type,
  astDirName,
);

class DefsFile(value: List<SkipAst.Definition>) extends SKStore.File

fun parseFile(file: FileCache.InputSource, source: String): DefsFile {
  fileResult = SkipParser.parseSource(source, true);
  ast = parseToAst(file, fileResult);
  DefsFile(ast)
}

fun parseToAst(
  file: FileCache.InputSource,
  parseResults: Parser.ParseResults,
): List<SkipAst.Definition> {
  parseResults.throwOnError(file);
  List::createFromItems(
    ConvertTree.Converter{file}.convertTree(parseResults.tree),
  );
}

module end;
