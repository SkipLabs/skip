/**
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

module alias I = OuterIst;

module alias SLO = SkipLowerOuterIst;

module OuterIstToIR;

private fun isTdefault(t: I.Type): Bool {
  t.ty is I.Tdefault _
}

// The magic fields in Awaitable::continuation that indicate "fulfilled".
// WARNING: These must match their C++ equivalents.
private const kAwaitableValueMarker: Int = -1;
private const kAwaitableExceptionMarker: Int = -3;

// We compile "return" as assigning to this temp then jumping to a shared
// physical return.
private const kImplicitReturnVariableName: String = "returnvalue!!";

private const kLocalVarType: FrontEndLazyGClass = FrontEndLazyGClass(
  "Runtime.LocalVariable",
);

// Wrap optional arguments in Tdefault per front end convention.
private fun defaultifyParamType(p: I.Parameter): I.Type {
  t = p.type;
  invariant(!isTdefault(t), "Unexpected Tdefault");
  if (p.value.isSome()) {
    I.Type(t.pos, I.Tdefault(t))
  } else {
    t
  }
}

// Given Parameters, extract their types. Optional arguments get their
// types wrapped in Tdefault per the front end's convention.
fun paramTypes(params: Parameters<I.Parameter>): Parameters<I.Type> {
  params.map(defaultifyParamType);
}

// Return the fields for a class, if any.
private fun getFields(
  cd: I.ClassDef,
  _pos: FileRange,
): Parameters<I.Parameter> {
  cd.params match {
  | Some(cp) -> cp.params
  | None() -> Positional::create()
  }
}

// Do the given outgoing arguments contain any default args?
private fun hasDefaultArg(args: Parameters<I.Expr>): Bool {
  args.foldl((acc, e) -> acc || (e is I.Expr(_, _, I.DefaultArg())), false)
}

private fun computeNumOptionalFlagInts(numOptional: Int, useMask: Bool): Int {
  if (numOptional == 0) {
    0
  } else if (!useMask) {
    // Use a counter rather than a bitmask. A single word always suffices.
    1
  } else {
    // Pass a separate bit mask per 64 optional arguments.
    roundUp(numOptional, 64) / 64
  }
}

private fun unreachableFrontEndStmt(pos: FileRange): I.Stmt {
  tvoid = I.Type(pos, I.Tapply(I.Name(pos, "Void"), Array[]));
  I.SingleExpr(I.Expr(tvoid, pos, I.Unreachable()))
}

// Magic name for codegened "inspect" methods. This cannot conflict
// with user code.
private const kInspectMethodName: String = ".inspect";

// Magic name for codegened "getClass" methods. These handle class(x).
private const kGetClassMethodName: String = ".getClass";

private const kFrozenFactoryName: String = ".frozenFactory";
private const kMutableFactoryName: String = ".mutableFactory";

// Prefix before parameter names for compiler-generated arguments holding
// bit masks or counts indicating which optional arguments were supplied
// by the caller.
private const kOptSuppliedPrefix: String = "optional.supplied.";

private fun insertOptionalFlags(
  params: Array<I.Parameter>,
  numOptional: Int,
  useMask: Bool,
  pos: FileRange,
): Array<ParameterInfo> {
  numRequired = params.size() - numOptional;
  numFlagInts = computeNumOptionalFlagInts(numOptional, useMask);

  Array::fillBy(params.size() + numFlagInts, i -> {
    if (i < numRequired) {
      ParameterInfo::make(params[i])
    } else if (i < numRequired + numFlagInts) {
      ParameterInfo{
        name => kOptSuppliedPrefix + (i - numRequired).toString(),
        value => None(),
        info => SkipOuterIstUtils.const_binding_info,
        index => -1,
        pos,
      }
    } else {
      ParameterInfo::make(params[i - numFlagInts])
    }
  })
}

// Discard named parameter names and produce an array of the values
// in calling-convention order for calling a function of the given type.
//
// The calling convention:
// - For positional arguments, the original order is preserved. This means
//   any optional arguments are at the end.
// - For named arguments, required arguments come first, followed by optional.
//   Within each set the arguments are sorted lexicographically by argument
//   name.
//
// For convenience this function also returns the number of optional arguments,
// and whether to use the "bitmask" or "count" calling convention for
// optional arguments.
private fun flattenParams<T>(
  params: Parameters<T>,
  expectedTypes: Parameters<I.Type>,
): (Array<T>, Int, Bool) {
  expectedTypes match {
  | Positional(funArgs) ->
    params match {
    | Positional(pArgs) ->
      // Count how many of those arguments are optional.
      numOpt = funArgs.foldl(
        (acc, t) -> acc + (if (isTdefault(t)) 1 else 0),
        0,
      );
      (pArgs, numOpt, numOpt <= 1)
    | Named _ -> invariant_violation("Positional/named mismatch.")
    }
  | Named(funArgs) ->
    params match {
    | Positional _ -> invariant_violation("Positional/named mismatch.")
    | Named(pArgs) ->
      invariant(funArgs.size() == pArgs.size(), "Arg count mismatch");

      required = mutable Vector<T>[];
      optional = mutable Vector<T>[];

      funArgsVec = funArgs.collect(Array);
      pArgsVec = pArgs.collect(Array);
      funArgsVec.eachWithIndex((i, t) -> {
        (if (isTdefault(t)) optional else required).push(pArgsVec[i])
      });

      // Append all the optionals after the required.
      optional.each(required.push);

      (required.toArray(), optional.size(), true)
    }
  }
}

private fun isMutableType(tt: I.Type): Bool {
  tt.ty match {
  | I.Tmutable _ -> true
  | I.Tdefault(x) -> isMutableType(x)
  | I.Tany _
  | I.Tapply _
  | I.TsetElt _
  | I.Treadonly _
  | I.Tfun _ ->
    false
  | I.Tparam _
  | I.Tnamed _ ->
    tt.pos.die("isMutableType cannot handle this case")
  }
}

private fun getLineStr(pos: FileRange): String {
  (pos.start().line() + 1).toString()
}

mutable private class JumpBlockInfo{
  pos: FileRange,
  name: String,
  stmt: I.Stmt,
  block: mutable GBlock,
}

// A subset of OuterIst.Parameter. Sometimes we make these synthetically
// and don't actually have the "type" that OuterIst.Parameter needs,
// so it's cleaner just to use this subset.
class ParameterInfo{
  name: String,
  value: ?I.Initializer,
  info: I.BindingInfo,
  index: Int,
  pos: FileRange,
} {
  static fun make(p: I.Parameter): ParameterInfo {
    ParameterInfo{
      name => p.name.id,
      value => p.value,
      info => p.frozen_,
      index => p.index,
      pos => p.name.pos,
    }
  }

  fun getInit(): I.Initializer {
    this.value match {
    | None() -> this.pos.die(`no initializer`)
    | Some(init) -> init
    }
  }
}

// A GFunction which may or may not be compiled to GIR yet.
base class LazyGFun{} uses Hashable, Orderable, Show {
  fun compile(
    context: mutable SKStore.Context,
    converter: Converter,
  ): GFunction;

  fun gname(): GFunctionName;

  macro fun toString(): String {
    `<${#thisClassName} ${this.gname().id}>`
  }

  fun hash(): Int {
    this.gname().hash()
  }

  fun ==(other: LazyGFun): Bool {
    this.gname() == other.gname()
  }

  fun compare(other: LazyGFun): Order {
    this.gname().compare(other.gname())
  }
}

// A GFunction which has already been compiled to GIR.
class DoneLazyGFun{function: GFunction} extends LazyGFun {
  fun gname(): GFunctionName {
    this.function.funInfo.gfunction
  }

  fun compile(
    _context: mutable SKStore.Context,
    _converter: Converter,
  ): GFunction {
    this.function
  }
}

// A lazy fun that compiles the given function from the front end.
class FrontEndLazyGFun{frontEndName: String} extends LazyGFun {
  fun gname(): GFunctionName {
    GFunctionName(this.frontEndName)
  }

  fun compile(
    context: mutable SKStore.Context,
    converter: Converter,
  ): GFunction {
    funDef = converter.program.getFun(context, this.frontEndName);
    convertedFunDef = converter.convertFunDef(context, funDef);
    result = converter.getGFunction(context, convertedFunDef);
    result
  }
}

base class FunInfoLazyGFun{
  funInfo: GFunInfo,
  params: Array<ParameterInfo>,
} extends LazyGFun {
  fun gname(): GFunctionName {
    this.funInfo.gfunction
  }
}

class NativeLazyGFun{} extends FunInfoLazyGFun {
  // Make a no-implementation function.
  fun compile(
    _context: mutable SKStore.Context,
    _converter: Converter,
  ): GFunction {
    funInfo = this.funInfo;
    GFunction{
      funInfo,
      params => this.params.mapWithIndex((i, p) ->
        GFunParam{
          id => GInstrID(i),
          typ => funInfo.funType.params[i],
          pos => funInfo.pos,
          prettyName => p.name,
        }
      ),
      blocks => Array[],
    }
  }
}

base class ConcreteLazyGFun{
  useOptionalMask: Bool = true,
  captured: Array<GField> = Array[],
} extends FunInfoLazyGFun {
  overridable fun compile(
    context: mutable SKStore.Context,
    converter: Converter,
  ): GFunction {
    emitter = OuterIstEmitter::make(context, converter, this);

    emitter.emitPreamble();

    this.emitBody(context, emitter);

    emitter.terminateExistingBlock();

    blocks = mutable Vector[];
    for (i in Range(0, emitter.blocks.size())) {
      block = emitter.blocks[i].chill();
      blocks.push(block)
    };

    GFunction{
      funInfo => emitter.funInfo,
      params => emitter.params,
      blocks => blocks.toArray(),
    }
  }

  protected fun emitBody(
    context: mutable SKStore.Context,
    emitter: mutable OuterIstEmitter,
  ): void;

  overridable fun getParams(
    _context: mutable SKStore.Context,
    Converter,
  ): Array<ParameterInfo> {
    this.params
  }

  overridable fun returnTempType(): GType {
    this.funInfo.funType.returnType
  }

  // Emit the final Return for the function. This hook gives LazyGFuns
  // a chance to emit some extra code at the return site, or change
  // the return value.
  overridable fun emitReturn(
    emitter: mutable OuterIstEmitter,
    value: GInstr,
    pos: FileRange,
  ): void {
    _ = emitter.emitInstr(GReturn{pos, value})
  }
}

class InspectLazyGFun extends ConcreteLazyGFun {
  protected fun emitBody(
    context: mutable SKStore.Context,
    emitter: mutable OuterIstEmitter,
  ): void {
    emitter.emitBindParameters(context);

    // The "this" object for this inspect method.
    obj = emitter.params[0];

    pos = emitter.funInfo.pos;
    clsID = obj.typ.asGTapply(pos).generic;
    cls = emitter.converter.getGClass(context, clsID, pos);
    if (!cls.kind.isFinal()) {
      pos.die(`inspect method only valid for concrete classes, not ${obj.typ}`)
    };

    returnValue = cls.methods.maybeGet("inspect").flatMap(def ->
      // NOTE: This "if" cannot be folded into a match pattern because it
      // has a mutable parameter.
      if (
        !this.isLegalInspectSignature(
          context,
          cls,
          emitter.converter.getGFunction(
            context,
            def.function.fromSome()(context, clsID),
          ),
          emitter.converter,
        )
      ) {
        None()
      } else {
        // The user wrote their own "inspect" method, just call it.
        Some(
          emitter.emitInstr(
            GCallMethod{
              typ => gtInspect,
              pos,
              method => "inspect",
              args => Array[obj],
              source => clsID,
            },
          ),
        )
      }
    ) match {
    | Some(x) -> x
    | None() ->
      pairType = GTapply(
        FrontEndLazyGClass("Tuple2"),
        DeepFrozen(),
        Array[gtString, gtInspect],
      );

      isLambda = cls.isLambda;

      // Remove any confusing "!123" suffix for renamed captured variables.
      computeDisplayName = n ~> {
        if (isLambda) {
          n.split("!")[0]
        } else {
          n
        }
      };

      sortedFields = if (cls.constructorParametersNamed) {
        cls.fields.sortedBy(a ~> computeDisplayName(a.name))
      } else {
        cls.fields
      };

      // Create an array by calling inspect on all the fields.
      fields = sortedFields.map(gf -> {
        rawField = emitter.emitInstr(
          GGetField{typ => gf.typ, pos, obj, field => gf.name},
        );

        (origDisplayName, captureKind) = parseClosureFieldName(gf);

        field = captureKind match {
        | CCByRef() ->
          // Read the capture-by-ref value out of the LocalVariable<T> cell.
          // The type of the result is whatever T is.
          emitter.emitInstr(
            GGetField{
              typ => rawField.getType().asGTapply(pos).targs[0],
              pos,
              obj => rawField,
              field => "value",
            },
          )
        | _ -> rawField
        };

        displayName = computeDisplayName(origDisplayName);

        inspVal = emitter.emitInstr(
          GCallFunction{
            typ => gtInspect,
            pos,
            name => FrontEndLazyGFun{frontEndName => "inspect"},
            args => Array[field],
            targs => Array[field.getType()],
          },
        );

        if (cls.constructorParametersNamed) {
          // Produce a (String, Inspect) pair.
          emitter.emitInstr(
            GObject{
              typ => pairType,
              pos,
              args => Array[
                emitter.constantString(UTF8String::make(displayName)),
                inspVal,
              ],
            },
          )
        } else {
          inspVal
        }
      });

      // Create an Array of the inspected field values.
      inspectedFields = emitter.emitInstr(
        GEArray{
          typ => GTapply(
            FrontEndLazyGClass("Array"),
            DeepFrozen(),
            Array[
              if (cls.constructorParametersNamed) {
                pairType
              } else {
                gtInspect
              },
            ],
          ),
          pos,
          args => fields,
        },
      );

      clsName = cls.name.id;
      typeName = if (isLambda) {
        "Captured"
      } else if (clsName.endsWith(concreteMetaImplSuffix)) {
        "Concrete<" + clsName.splitLast(concreteMetaImplSuffix).i0 + ">"
      } else if (clsName.endsWith(baseMetaImplSuffix)) {
        "Base<" + clsName.splitLast(baseMetaImplSuffix).i0 + ">"
      } else {
        clsName
      };

      inspectType = FrontEndLazyGClass(
        if (cls.constructorParametersNamed) {
          "InspectObject"
        } else {
          "InspectCall"
        },
      );

      inspectResult = emitter.emitInstr(
        GObject{
          typ => GTapply(inspectType, DeepFrozen()),
          pos,
          args => Array[
            emitter.constantString(UTF8String::make(typeName)),
            inspectedFields,
          ],
        },
      );

      if (!isLambda) {
        inspectResult
      } else {
        // Create an Inspect object corresponding to a fake "Lambda" object
        // with "source" and "captured" fields.
        sourceString = emitter.emitInstr(
          GObject{
            typ => GTapply(FrontEndLazyGClass("InspectString"), DeepFrozen()),
            pos,
            args => Array[
              emitter.constantString(UTF8String::make(pos.toString())),
            ],
          },
        );

        sourcePair = emitter.emitInstr(
          GObject{
            typ => pairType,
            pos,
            args => Array[
              emitter.constantString(UTF8String::make("source")),
              sourceString,
            ],
          },
        );

        capturedPair = emitter.emitInstr(
          GObject{
            typ => pairType,
            pos,
            args => Array[
              emitter.constantString(UTF8String::make("captured")),
              inspectResult,
            ],
          },
        );

        // Produce something like:
        // Lambda{source => "file:line", captured => Captured{a => 3}}
        fakeLambdaFields = emitter.emitInstr(
          GEArray{
            typ => GTapply(
              FrontEndLazyGClass("Array"),
              DeepFrozen(),
              Array[pairType],
            ),
            pos,
            args => Array[sourcePair, capturedPair],
          },
        );

        emitter.emitInstr(
          GObject{
            typ => GTapply(FrontEndLazyGClass("InspectObject"), DeepFrozen()),
            pos,
            args => Array[
              emitter.constantString(UTF8String::make("Lambda")),
              fakeLambdaFields,
            ],
          },
        )
      }
    };

    // This is the only Return, no need for emitReturn.
    _ = emitter.emitInstr(GReturn{pos, value => returnValue})
  }

  // When the user writes an "inspect" method, we should call it rather
  // than using the default. But, until we check this properly with a trait,
  // if they happen to make a method called "inspect" with the wrong signature
  // we'll just ignore it.
  private fun isLegalInspectSignature(
    context: mutable SKStore.Context,
    cls: GClass,
    f: GFunction,
    converter: Converter,
  ): Bool {
    funInfo = f.funInfo;

    // Look for: fun inspect(): Inspect
    funInfo.tparams.size() == cls.tparams.size() &&
      funInfo.funType.params.size() == 1 &&
      (funInfo.funType.returnType == gtInspect ||
        (funInfo.funType.returnType match {
        | GTapply(generic, _, _) ->
          gc = converter.getGClass(context, generic, funInfo.pos);
          gc.extends_.contains(gtInspect)
        | _ -> false
        }))
  }
}

class GetClassLazyGFun extends ConcreteLazyGFun {
  protected fun emitBody(
    _context: mutable SKStore.Context,
    emitter: mutable OuterIstEmitter,
  ): void {
    pos = emitter.funInfo.pos;

    value = emitter.emitInstr(
      GObject{typ => this.funInfo.funType.returnType, pos, args => Array[]},
    );

    // This is the only Return, no need for emitReturn.
    _ = emitter.emitInstr(GReturn{pos, value})
  }
}

// Lazy functions with either a backing definition or a handbuilt body.
base class BodyProvidingLazyGFun{} extends ConcreteLazyGFun {
  fun getBody(context: mutable SKStore.Context, converter: Converter): I.Stmt;

  overridable protected fun emitBody(
    context: mutable SKStore.Context,
    emitter: mutable OuterIstEmitter,
  ): void {
    emitter.emitBindParameters(context);
    emitter.emitStmt(context, this.getBody(context, emitter.converter));
  }
}

base class BodyLazyGFun{body: I.Stmt} extends BodyProvidingLazyGFun {
  children =
  | NormalLazyGFun
  | ConstLazyGFun{constName: ConstID}

  fun getBody(_context: mutable SKStore.Context, _: Converter): I.Stmt {
    this.body
  }
}

// A CustomLazyGFun is given a lambda to emit the body for one-off custom
// function emitters.
class CustomLazyGFun{
  emitBodyHelper: mutable OuterIstEmitter ~> void,
} extends ConcreteLazyGFun {
  protected fun emitBody(
    _context: mutable SKStore.Context,
    e: mutable OuterIstEmitter,
  ): void {
    this.emitBodyHelper(e)
  }
}

// functions and methods backed by an OuterIst def
class DefLazyGFun{def: I.CallableDef} extends BodyProvidingLazyGFun {
  static fun make{
    funInfo: GFunInfo,
    def: I.CallableDef,
    params: Array<ParameterInfo>,
    useOptionalMask: Bool,
  }: LazyGFun {
    DefLazyGFun{funInfo, def, params, useOptionalMask};
  }

  private fun getLoweredDef(
    context: mutable SKStore.Context,
    converter: Converter,
    def: I.CallableDef,
  ): I.CallableDef {
    result = if (def.isLowered()) {
      def
    } else {
      converter.lower.get(context, I.CallableDefFile(def)).value
    };
    result
  }

  fun getBody(context: mutable SKStore.Context, converter: Converter): I.Stmt {
    this.getLoweredDef(context, converter, this.def).getBody().asOuter()
  }

  // get our lowered def, and patch our params array with the fresh info.
  // (For simplicity we just do this every time getParams() is called,
  // on the assumption it's usually called just once)
  fun getParams(
    context: mutable SKStore.Context,
    converter: Converter,
  ): Array<ParameterInfo> {
    def = this.getLoweredDef(context, converter, this.def);
    defParams = def.getParams();
    this.params.map(p -> {
      if (p.index < 0) {
        def match {
        | (md @ I.MethodDef _) if (p.name == md.implicit_param.name.id) ->
          p with {info => md.implicit_param.info}
        | _ -> p
        }
      } else {
        defp = defParams match {
        | Positional(l) ->
          // param.index is not always reliable (e.g. for inherited fields)
          l.find(defp -> defp.name.id == p.name) match {
          | None() -> p.pos.die(`positional param def not found`)
          | Some(defp) -> defp
          }
        | Named(m) ->
          m.maybeGetNoPos(p.name) match {
          | None() -> p.pos.die(`named param def not found`)
          | Some(defp) -> defp
          }
        };
        p with {info => defp.frozen_, value => defp.value}
      }
    })
  }
}

// What does the raw field in a closure field hold?
private base class ClosureCaptureKind {
  children =
  | CCNotCaptured()
  // A simple by-value capture.
  | CCByValue()
  // A mutable LocalVariable<T> representing a local variable of type T.
  // This LocalVariable may be read and written by this closure and others.
  | CCByRef()
}

// Parse the name of a field in a closure into the name of the local
// variable it represents, and whether that variable was captured by reference.
private fun parseClosureFieldName(field: GField): (String, ClosureCaptureKind) {
  name = field.name;
  if (name.startsWith("captured_ref:")) {
    (name.split("captured_ref:")[1], CCByRef())
  } else if (name.startsWith("captured:")) {
    (name.split("captured:")[1], CCByValue())
  } else {
    (name, CCNotCaptured())
  }
}

fun makeGFunTypeWithFlags{
  paramTypes: Array<GType>,
  numOptional: Int,
  returnType: GType,
  isMutable: Bool,
  isTracked: Bool,
  useOptionalMask: Bool = true,
}: GFunType {
  numFlagInts = computeNumOptionalFlagInts(numOptional, useOptionalMask);

  paramsWithFlags = if (numFlagInts == 0) {
    paramTypes
  } else {
    // Splice in the Int flags for optional args in between the
    // mandatory args and the optional ones.
    (paramTypes
      .slice(0, paramTypes.size() - numOptional)
      .concat(
        Array::fill(numFlagInts, gtInt).concat(
          paramTypes.slice(paramTypes.size() - numOptional, paramTypes.size()),
        ),
      ))
  };

  GFunType{isMutable, isTracked, params => paramsWithFlags, returnType}
}

class LazyGFunKey(value: LazyGFun) extends SKStore.Key {
  fun compare(other: SKStore.Key): Order {
    other match {
    | LazyGFunKey(value) -> this.value.toString().compare(value.toString())
    | _ -> invariant_violation("Heterogeneous keys found")
    }
  }
}

class LazyGClassKey(value: LazyGClass) extends SKStore.Key {
  fun compare(other: SKStore.Key): Order {
    other match {
    | LazyGClassKey(value) -> this.value.name().id.compare(value.name().id)
    | _ -> invariant_violation("Heterogeneous keys found")
    }
  }
}
class GClassFile(value: GClass) extends SKStore.File

// Manages the overall conversion from OuterIst to IR.
class Converter private (
  program: I.Program,
  private classes: SKStore.LHandle<LazyGClassKey, GClassFile>,
  lower: SKStore.LHandle<I.CallableDefFile, I.CallableDefFile>,
) {
  fun getConsts(
    context: mutable SKStore.Context,
    constsProj: SKStore.EHandle<SKStore.UnitID, I.ConstDefFile>,
  ): Array<ConstLazyGFun> {
    consts = this.program.getConsts(context, constsProj);
    consts.map(cst -> this.convertConstDef(context, cst))
  }

  static fun create(
    context: mutable SKStore.Context,
    name: SKStore.DirName,
    program: I.Program,
  ): this {
    classDirName = name.sub("classes");
    classes = SKStore.LHandle(
      LazyGClassKey::keyType,
      GClassFile::type,
      classDirName,
    );
    lowerDirName: SKStore.DirName = SKStore.DirName::create("/lowerDefs/");
    lower = SKStore.LHandle(
      I.CallableDefFile::keyType,
      I.CallableDefFile::type,
      lowerDirName,
    );
    converter = static(program, classes, lower);
    _ = SKStore.LHandle::create(
      LazyGClassKey::keyType,
      GClassFile::type,
      context,
      classDirName,
      converter.getGClassImplFun,
      false,
    );
    _ = SKStore.LHandle::create(
      I.CallableDefFile::keyType,
      I.CallableDefFile::type,
      context,
      lowerDirName,
      (context, _self, key) ~> {
        def = key match {
        | I.CallableDefFile(x) -> x
        };
        lowered = def.lower(context, program);
        if (shouldDebugSymbol(def.getName())) {
          debug(def.getName() + " unlowered");
          debug(def);
          debug(def.getName() + " lowered");
          debug(lowered);
        };
        loweredFile = I.CallableDefFile(lowered);
        Array[loweredFile]
      },
    );
    converter
  }

  fun getGFunction(
    context: mutable SKStore.Context,
    lazy: LazyGFun,
  ): GFunction {
    this.getGFunctionFun(context, LazyGFunKey(lazy))[0].value
  }

  private fun getGFunctionFun(
    context: mutable SKStore.Context,
    key: LazyGFunKey,
  ): Array<GFunctionFile> {
    file = GFunctionFile(key.value.compile(context, this));
    Array[file]
  }

  private fun getGClassImpl(
    context: mutable SKStore.Context,
    gid: LazyGClass,
  ): GClass {
    key = LazyGClassKey(gid);
    this.classes.get(context, key).value
  }

  private fun getGClassImplFun(
    context: mutable SKStore.Context,
    _self: SKStore.LHandle<LazyGClassKey, GClassFile>,
    key: LazyGClassKey,
  ): Array<GClassFile> {
    gid = key match {
    | LazyGClassKey(x) -> x
    };
    value = Array[
      GClassFile(
        gid match {
        | LiteralLazyGClass(cls) -> cls
        | name @ FrontEndLazyGClass _ ->
          classDef = this.program.getClass(context, name.id);
          this.convertClassDef(context, classDef, name, classDef.name.pos)
        | meta @ BaseMetaLazyGClass _ -> this.createBaseMeta(context, meta)
        | meta @ BaseMetaImplLazyGClass _ ->
          this.createBaseMetaImpl(context, meta)
        | meta @ ClassMetaLazyGClass _ -> this.createClassMeta(context, meta)
        | meta @ ConcreteMetaLazyGClass _ ->
          this.createConcreteMeta(context, meta)
        | meta @ ConcreteMetaImplLazyGClass _ ->
          this.createConcreteMetaImpl(context, meta)
        | c @ ClosureBaseLazyGClass _ -> this.createClosureBaseClass(context, c)
        | MetaMetaLazyGClass _ -> this.createMetaMeta(context)
        | rt @ ReturnTupleLazyGClass(arity) ->
          this.createReturnTuple(context, rt.name(), arity)
        },
      ),
    ];
    value
  }

  // Every class gets a codegen'd method to help with "inspect". Although
  // we create the stubs eagerly for simplicity, like all methods they are
  // only actually compiled on demand.
  private fun createInspectMethod(gclass: GClass): ?(String, GMethodDef) {
    pos = gclass.pos;

    function = if (!gclass.kind.isFinal()) {
      None()
    } else {
      // Copy this into a local so we don't capture all of gclass.
      tparams = gclass.tparams;

      Some((_context, receiver) ~> {
        className = receiver.name();

        funInfo = GFunInfo{
          gfunction => GFunctionName(className.id + "::" + kInspectMethodName),
          pos,
          tparams,
          annotations => SSet["@no_inline"],
          funType => makeGFunTypeWithFlags{
            paramTypes => Array[GTapply(receiver, Readonly(), tparams)],
            numOptional => 0,
            returnType => gtInspect,
            isMutable => false,
            isTracked => true,
          },
          className => Some(className),
        };

        InspectLazyGFun{
          funInfo,
          params => Array[
            ParameterInfo{
              name => "this",
              value => None(),
              info => SkipOuterIstUtils.const_binding_info,
              index => 0,
              pos,
            },
          ],
        }
      })
    };

    Some((kInspectMethodName, GMethodDef{function, tparams => Array[], pos}))
  }

  // For each KClass X we create a ".getClass" method that returns Concrete<X>.
  // This allows us to implement the "class(x)" language feature via a virtual
  // method call.
  private fun createGetClassMethod(gclass: GClass): ?(String, GMethodDef) {
    pos = gclass.pos;

    function = if (!gclass.kind.isFinal() || !gclass.hasMeta) {
      None()
    } else {
      // Copy this into a local so we don't capture all of gclass.
      tparams = gclass.tparams;

      Some((_context, receiver) ~> {
        className = receiver.name();

        returnType = GTapply(
          ConcreteMetaImplLazyGClass(receiver),
          DeepFrozen(),
          tparams,
        );

        funInfo = GFunInfo{
          gfunction => GFunctionName(className.id + "::" + kGetClassMethodName),
          pos,
          tparams,
          funType => makeGFunTypeWithFlags{
            paramTypes => Array[GTapply(receiver, Readonly(), tparams)],
            numOptional => 0,
            returnType,
            isMutable => false,
            isTracked => true,
          },
          className => Some(className),
        };

        GetClassLazyGFun{
          funInfo,
          params => Array[
            ParameterInfo{
              name => "this",
              value => None(),
              info => SkipOuterIstUtils.const_binding_info,
              index => 0,
              pos,
            },
          ],
        }
      })
    };

    Some((kGetClassMethodName, GMethodDef{function, tparams => Array[], pos}))
  }

  private fun finishGClass(
    context: mutable SKStore.Context,
    orig: GClass,
    addInspect: Bool = true,
  ): GClass {
    extraMethods = Vector::mcreate(2);

    if (addInspect) {
      this.createInspectMethod(orig) match {
      | Some(x) -> extraMethods.push(x)
      | None() -> void
      }
    };

    this.createGetClassMethod(orig) match {
    | Some(x) -> extraMethods.push(x)
    | None() -> void
    };

    gclass = if (extraMethods.isEmpty()) {
      orig
    } else {
      newMethods = orig.methods.clone(extraMethods.size());
      for (x in extraMethods) {
        newMethods.set(x.i0, x.i1)
      };
      orig with {methods => newMethods.chill()}
    };

    isCppExport = annotationsContainParam(
      orig.annotations,
      "@cpp_export",
      gclass.pos,
    ).isSome();

    // Convert some KClass to KValue when it's legal and free. So a class
    // with no base classes containing only a single unassignable pointer
    // to another class might as well just be a value class, to save one
    // level of indirection.
    if (
      gclass.kind.isKClass() &&
      gclass.extends_.isEmpty() &&
      !gclass.isNative &&
      !isCppExport &&
      (gclass.fields.isEmpty() ||
        (gclass.fields.size() == 1 &&
          !gclass.fields[0].isAssignable &&
          (gclass.fields[0].typ match {
          | GTapply(subgid, _, _) ->
            this.scalarizesToNoMoreThanOneScalar(context, subgid, gclass.pos)
          | _ -> false
          })))
    ) {
      !gclass = gclass with {kind => KValue()};
    };

    // Make sure we have created GClasses for all base classes.
    for (ta in gclass.extends_) {
      _ = this.getGClass(context, ta.generic, gclass.pos)
    };

    gclass
  }

  // Returns the GClassKind, if known.
  private fun getGClassKind(
    context: mutable SKStore.Context,
    ref: LazyGClass,
  ): GClassKind {
    ref match {
    | LiteralLazyGClass(cls) -> cls.kind
    | FrontEndLazyGClass(nameStr) ->
      this.convertClassKind(this.program.getClass(context, nameStr))
    | BaseMetaLazyGClass _
    | ClassMetaLazyGClass _
    | ConcreteMetaLazyGClass _
    | ClosureBaseLazyGClass _ ->
      KBase()
    | BaseMetaImplLazyGClass _
    | ConcreteMetaImplLazyGClass _
    | MetaMetaLazyGClass _ ->
      KClass()
    | ReturnTupleLazyGClass _ -> KValue()
    }
  }

  fun getGClass(
    context: mutable SKStore.Context,
    gid: LazyGClass,
    _pos: Pos,
  ): GClass {
    gid match {
    | LiteralLazyGClass(cls) -> cls
    | _ -> this.getGClassImpl(context, gid)
    }
  }

  private fun getMetaClass(
    context: mutable SKStore.Context,
    lazyGClass: LazyGClass,
    g: ?GClass = None(),
  ): LazyGClass {
    gc = g match {
    | Some(x) -> x
    | None() -> this.getGClassImpl(context, lazyGClass)
    };

    if (!gc.hasMeta) {
      MetaMetaLazyGClass()
    } else if (gc.kind.isBaseClass()) {
      BaseMetaImplLazyGClass(lazyGClass)
    } else {
      ConcreteMetaImplLazyGClass(lazyGClass)
    }
  }

  private fun allocTparams(prefix: String, count: Int): Array<GTparam> {
    Array::fillBy(count, i -> {
      name = "T" + i;
      GTparam(prefix + name, name)
    })
  }

  private fun createReturnTuple(
    context: mutable SKStore.Context,
    name: GClassName,
    arity: Int,
  ): GClass {
    pos = FileRange.builtin;

    tparams = this.allocTparams("<class>" + name.id, arity);

    this.finishGClass(
      context,
      GClass{
        name,
        tparams,
        variances => Array::fill(arity, I.Vplus()),
        isMutable => false,
        fieldsFinal => true,
        hasMeta => false,
        isReturnTuple => true,
        kind => KValue(),
        fields => tparams.mapWithIndex((i, typ) ->
          GField{name => `i${i}`, typ, isAssignable => false, pos, index => i}
        ),
        pos,
      },
      false,
    )
  }

  // When you do class(class(class(...(x)))) it quickly ends up in
  // a class that is its own metaclass. You can't do anything interesting
  // with this class but it needs to exist.
  private fun createMetaMeta(context: mutable SKStore.Context): GClass {
    this.finishGClass(
      context,
      GClass{
        name => GClassName("<builtin>.MetaMeta"),
        tparams => Array[],
        variances => Array[],
        pos => FileRange.builtin,
        isMutable => false,
        fieldsFinal => true,
        kind => KClass(),
      },
    )
  }

  // given an array of GTapply, return an array containing each original
  // along with the GTapplys it extends, applied to the original's targs.
  // (We can assume this targ congruence for closure classes.)
  // Note: not transitive - we depend on being called on parents before kids.
  private fun flattenClosureClassExtends(
    context: mutable SKStore.Context,
    extends_: Array<GTapply>,
    pos: FileRange,
  ): Array<GTapply> {
    flat = mutable Map[];
    addExtend = gta -> flat.maybeSet(gta.generic, gta);
    for (parent in extends_) {
      if (addExtend(parent)) {
        parentClass = this.getGClass(context, parent.generic, pos);
        for (grandParent in parentClass.extends_) {
          _ = addExtend(grandParent with {targs => parent.targs})
        }
      }
    };
    flat.values().collect(Array)
  }

  // Create a class somewhere in a closure class hierarchy.
  fun createClosureClass(
    context: mutable SKStore.Context,
    className: GClassName,
    callMethodType: GFunType,
    tparams: Array<GTparam>,
    variances: Array<I.Variance>,
    kind: ClassKind,
    extends_: Array<GTapply>,
    yields: Bool,
    pos: FileRange,
    generateBody: ?(GFunInfo ~> LazyGFun),
    fields: Array<GField> = Array[],
  ): GClass {
    // Let the caller produce optional code for this.
    methods = UnorderedMap[
      "call" => GMethodDef{
        function => generateBody.map(bodyFunc ~>
          (_context, receiver) ~> {
            thisType: GType = GTapply(
              receiver,
              Mutability::fromFlag(callMethodType.isMutable),
              tparams,
            );

            callFunType = callMethodType with {
              params => Array[thisType].concat(callMethodType.params),
            };

            funInfo = GFunInfo{
              gfunction => GFunctionName(className.id + "::call"),
              pos,
              tparams,
              annotations => SSet["@always_inline"],
              funType => callFunType,
              className => Some(className),
              isGenerator => yields,
            };

            bodyFunc(funInfo)
          }
        ),
        tparams => Array[],
        pos,
      },
    ];

    // Create the actual generic class for this closure.
    this.finishGClass(
      context,
      GClass{
        name => className,
        tparams,
        variances,
        pos,
        kind,
        isMutable => callMethodType.isMutable,
        isLambda => true,
        fieldsFinal => kind.isFinal(),
        constructorParametersNamed => true,
        extends_ => this.flattenClosureClassExtends(context, extends_, pos),
        methods,
        fields,
      },
    )
  }

  fun getClosureBaseClass(t: GFunType): GTapply {
    GTapply(
      ClosureBaseLazyGClass(t.params.size(), t.isMutable, t.isTracked),
      Mutability::fromFlag(t.isMutable),
      Array[t.returnType].concat(t.params),
    )
  }

  // Closures are desugared to objects with a "call()" method. This creates
  // the base class to use for all closures with a particular function type.
  private fun createClosureBaseClass(
    context: mutable SKStore.Context,
    cb: ClosureBaseLazyGClass,
  ): GClass {
    // We model the fact that a "pure" ("~>") lambda can be cast to an
    // "impure" ("->") one by making impure be a base class of pure.
    // Similarly we make untracked a base class of tracked. That gives us
    // this base class inheritance diamond:
    //
    //                 (mutable, untracked) closure
    //                             |
    //                       ______|_______
    //                       |            |
    //                       |            |
    //  (frozen, untracked) closure    (mutable, tracked) closure
    //                       |            |
    //                       |____________|
    //                             |
    //                    (frozen, tracked) closure
    //
    // This sort of inheritance is not legal in Skip due to mutability
    // differences, but it's actually safe given the limited way closures
    // can be used, so we allow it in the back end.
    //
    // Modeling inheritance more accurately this way makes closures not
    // be a special case for method invocation, specialization, vtable
    // layout, IR verification, etc.

    // For base classes, the return type and parameters are all GTparams.
    tparams = this.allocTparams(`<class>${cb.nameStr()}:`, 1 + cb.numParams);

    // If not mutable, create a base class that is.
    parent1 = if (cb.isMutable) {
      Array[]
    } else {
      Array[GTapply(cb with {isMutable => true}, DeepFrozen(), tparams)]
    };

    // If tracked, create a base class that isn't.
    parent2 = if (!cb.isTracked) {
      Array[]
    } else {
      Array[GTapply(cb with {isTracked => false}, DeepFrozen(), tparams)]
    };

    // For base classes, the return type and parameters are all GTparams.
    mtype = GFunType{
      isMutable => cb.isMutable,
      isTracked => cb.isTracked,
      params => tparams.drop(1),
      returnType => tparams[0],
    };

    pos = FileRange.builtin;

    this.createClosureClass(
      context,
      cb.name(),
      mtype,
      tparams,
      Array::fillBy(tparams.size(), i -> {
        // Return values are covariant, parameters are contravariant.
        if (i == 0) {
          I.Vplus()
        } else {
          I.Vminus()
        }
      }),
      KBase(),
      this.flattenClosureClassExtends(context, parent1.concat(parent2), pos),
      false,
      pos,
      None(),
    )
  }

  // Return the fields for a class, if any,
  // with lowered OuterIst in their default initializers
  private fun getLoweredFields(
    context: mutable SKStore.Context,
    cd: I.ClassDef,
  ): Parameters<I.Parameter> {
    cd.params match {
    | Some(cp) -> SLO.class_params(context, cp, this.program).params
    | None() -> Positional::create()
    }
  }

  private fun createFactory(
    context: mutable SKStore.Context,
    returnsMutable: Bool,
    isAbstract: Bool,
    frontEndGClass: I.ClassDef,
    pos: FileRange,
  ): I.MethodDef {
    frontEndFields = this.getLoweredFields(context, frontEndGClass);

    frontEndTparams = frontEndGClass.tparams.map(tp -> {
      I.Type(pos, I.Tparam(tp.var, tp.id, tp.name, None()))
    });

    // Forward the factory parameters to Object.
    frontEndArgExprs = frontEndFields.map(p -> {
      fieldPos = p.name.pos;
      I.Expr(p.type, fieldPos, I.Local(p.name))
    });

    objType = I.Type(pos, (I.Tapply(frontEndGClass.name, frontEndTparams)));
    staticType = I.Type(pos, I.Tapply(I.Name(pos, "Concrete"), Array[objType]));

    // We'll make the factory return a mutable object and let the caller
    // decide if they want to freeze it.
    returnType = if (returnsMutable) {
      I.Type(pos, I.Tmutable(objType))
    } else {
      objType
    };

    body = if (isAbstract) {
      None()
    } else {
      makeObj = I.Object(
        frontEndGClass.name,
        frontEndTparams,
        frontEndArgExprs,
      );
      Some(I.OuterBody(I.Return(I.Expr(returnType, pos, makeObj))))
    };

    factoryName = if (returnsMutable) {
      kMutableFactoryName
    } else {
      kFrozenFactoryName
    };

    mdef = I.MethodDef{
      name => I.Name(pos, factoryName),
      body,
      visibility => (pos, I.VPublic()),
      annotations => SSet[],
      overridable_ => None(),
      kind => SkipNamedAst.FKStatic(pos),
      native_ => None(),
      untracked_ => None(),
      whenparams => Array[],
      tparams => Array[],
      params => frontEndFields,
      return_ => returnType,
      // TODO: This is wrong, it really should be inherited from whichever
      // base class first made the fields "final".
      from_ => frontEndGClass.name,
      source => frontEndGClass.name,
      met_class => frontEndGClass.name,
      implicit_param => I.Binding(
        staticType,
        I.Name(pos, "static"),
        SkipOuterIstUtils.const_binding_info,
      ),
      generic_mapping => SortedMap[],
      yields => None(),
      xhash => 0,
    };
    !mdef.xhash = hash(mdef);
    mdef
  }

  private fun getStaticMethods(
    context: mutable SKStore.Context,
    gc: GClass,
    name: LazyGClass,
  ): mutable UnorderedMap<String, GMethodDef> {
    // For magic codegen classes we'll check the parent class to find
    // static methods, since the front end couldn't "inherit" them for us.
    // This shouldn't come up often, if ever.
    orig = gc;
    while (!gc.isFrontEndClass) {
      if (gc.extends_.size() != 1) {
        return mutable UnorderedMap[]
      };
      !gc = this.getGClassImpl(context, gc.extends_[0].generic);
    };

    if (gc.tparams.size() != orig.tparams.size()) {
      // This case is too hard, give up.
      return mutable UnorderedMap[]
    };

    // Get the front end methods.
    cd = this.program.getClass(context, gc.name.id);
    fem = this.getFrontEndStaticMethods(cd);

    methods = UnorderedMap::mcreate(fem.size());
    phys = name.name();
    fem.each(md -> {
      (mname, mf) = this.convertMethodDef(
        context,
        md,
        phys,
        orig.name,
        gc.tparams,
      );
      methods.add(mname, mf)
    });

    methods
  }

  // TODO: T31411692: Memoize this.
  private fun getFrontEndStaticMethods(cd: I.ClassDef): Array<I.MethodDef> {
    methods = Vector::mcreateFromIterator(
      cd.methods.values().filter(md -> md.kind is SkipNamedAst.FKStatic _),
    );

    // Yields the I.Binding for the implicit "static" parameter.
    staticThisBinding = methodPos -> {
      // e.g. For Foo<X>, yields Concrete<Foo<X>> or Base<Foo<X>>.
      staticThisType = I.Type(
        methodPos,
        I.Tapply(
          I.Name(methodPos, if (cd.kind is I.KClass()) "Concrete" else "Base"),
          Array[
            I.Type(
              methodPos,
              I.Tapply(
                cd.name,
                cd.tparams.map(tp ->
                  I.Type(
                    methodPos,
                    (I.Tparam(tp.var, tp.id, tp.name, None()) : I.Type_),
                  )
                ),
              ),
            ),
          ],
        ),
      );

      // This is an I.Binding.
      I.Binding(
        staticThisType,
        I.Name(methodPos, "static"),
        SkipOuterIstUtils.const_binding_info,
      )
    };

    // Each class const turns into a static method that retrieves an
    // actual static const value, so that overriding works.
    for (constKey => constDef in cd.consts) {
      (constPos, constName) = constKey;

      realConstName = cd.name.id + "::" + constName;

      // Generate a static method that reads a global const.
      getterName = "getConst:" + constName;
      met = I.MethodDef{
        name => I.Name(constPos, getterName),
        body => constDef.value.map(_ ->
          I.OuterBody(
            I.Return(
              I.Expr(
                constDef.type,
                constPos,
                I.Const(I.Name(constPos, realConstName)),
              ),
            ),
          )
        ),
        annotations => SSet[],
        met_class => cd.name,
        from_ => constDef.from_.default(cd.name),
        implicit_param => staticThisBinding(constPos),
        overridable_ => None(),
        native_ => None(),
        params => Positional::create(),
        return_ => constDef.type,
        source => constDef.source.default(cd.name),
        kind => SkipNamedAst.FKStatic(constPos),
        tparams => Array[],
        untracked_ => None(),
        visibility => constDef.visibility,
        whenparams => Array[],
        generic_mapping => SortedMap[],
        yields => None(),
        xhash => 0,
      };
      !met.xhash = hash(met);
      methods.push(met);
    };

    methods.toArray()
  }

  // Skip supports overridable static methods. In order to avoid the back end
  // needing additional method dispatch and optimization mechanisms for static
  // methods, static method calls are compiled into normal method calls on
  // "metaclass singleton" objects created by the back end.
  //
  // During IR creation we begin by creating, for each (non-type) class C,
  // - a metaclass for C: a new class definition which hosts all of C's
  //   static methods as normal (instance) methods
  // - a singleton instance of C's metaclass.
  //
  // Normal method dispatch among these metaclass instances produces the same
  // observed behavior as overridable static methods, but look like normal
  // method calls to the back end.
  //
  // Beyond the one metaclass for each front end class, we also create
  // additional metaclasses to model inheritance relationships among the
  // front-end Base<T>, Concrete<T> and Class<T> metaclasses.
  //
  // The Skip operation class(obj) maps an object to its metaclass singleton
  // at runtime.  If obj has a final type at compile time (e.g., including all
  // value class types), then the metaclass singleton is known at compile time
  // and can be returned directly.  For values with non-final class types, the
  // singleton's pointer is loaded from the object's vtable.
  //
  // The mapping from Base<T>, Concrete<T> and Class<T> to their corresponding
  // back end types is a bit tricky to implement, but fast at runtime. We
  // need a class hierarchy with the same inheritance properties that the
  // front end class types have, but with usable vtables for method dispatch.
  //
  // Suppose we have this simple inheritance hierarchy:
  //
  //         A
  //         |
  //         |
  //         B
  //         |
  //         |
  //         C
  //
  // A, B are base classes and C is concrete.
  //
  // The corresponding metaclass hierarchy in the back end looks like:
  //
  //                    A::.ClassMeta
  //                        |
  //         _______________|_____________
  //         |              |             |
  //  A::.ConcreteMeta      |          A::.BaseMeta
  //         |              |             |    |
  //         |              |             |    |
  //         |          B::.ClassMeta     |  A::.BaseMetaImpl
  //         |              |             |
  //         |______________|_____________|
  //         |                            |
  //         |                            |
  //  B::.ConcreteMeta                  B::.BaseMeta
  //         |                                 |
  //         |                                 |
  //         |                               B::.BaseMetaImpl
  //  C::.ConcreteMetaImpl
  //
  //
  // Note that the "::." is actually part of a mangled class name, and present
  // to ensure the user cannot make a class with these names. That text really
  // is part of the class name, these are not static members of anything.
  //
  // Static methods for concrete class K are implemented as normal methods
  // on K::ConcreteMetaImpl. Static methods for base class J
  // are implemented on J::ClassMeta, so they can be inherited by both
  // base and concrete subclasses.
  //
  // As with front end types, only base classes can have subclasses.
  // For base classes, we need the T::BaseMetaImpl to host the metaclass
  // singleton corresponding to Base<T>, but we need T::BaseMeta, a
  // non-concrete class to model the inheritance relationship between B
  // and its (base) subclasses.
  //
  // There is exactly one concrete metaclass for each front end class (base
  // or concrete). In this example, A has A::BaseMetaImpl, B has
  // B::BaseMetaImpl, and C has C::ConcreteMetaImpl. This is the type of
  // the metaclass singleton for each class.
  //
  // The rest of the hierarchy described above exist to preserve the
  // inheritance relationships between the front-end metaclasses (Concrete<T>,
  // Base<T>, Class<T>).
  //
  // Front end types get mapped into this hierarchy as follows:
  //
  // Concrete<T> --> T::ConcreteMeta if T is a base class, else
  //                 T::ConcreteMetaImpl
  // Base<T>     --> T::BaseMeta, except that class literals are T::BaseMetaImpl
  // Class<T>    --> T::ClassMeta if T is a base class, else T::ConcreteMetaImpl
  //
  // If the front end types (A, B, C) are generic, then so are the metatypes,
  // taking the same type parameters.
  //
  // The Concrete, Base and Class types are removed from the hierarchy, although
  // they could easily be added back in.
  //
  // ConcreteMeta types can also be used to create object instances of runtime
  // types under certain constraints imposed by the front end (where we know
  // exactly what the fields are). The back end use this by giving each
  // ConcreteMeta instance a pointer to the vtable for that type.
  //
  // TODO: Where do we put abstract static methods? We would like to inherit
  // them normally, but we need BaseMetaImpl classes to not inherit any that
  // they don't implement (those methods would not be callable by the front
  // end). But it's not enough to only put those only in the ConcreteMeta
  // hierarchy, since some BaseMeta class could provide an implmentation.
  private fun createBaseMeta(
    context: mutable SKStore.Context,
    name: BaseMetaLazyGClass,
  ): GClass {
    cls = name.cls;
    gc = this.getGClassImpl(context, cls);

    // Note: in keeping with current front-end policy, here we copy methods
    // down from B::.ClassMeta to its "local" sub-metaclasses.
    // TODO supplement (or replace) with a copydown post-processing pass
    // that propagates static methods to the full metaclass hierarchy.

    this.finishGClass(
      context,
      GClass{
        name => name.name(),
        tparams => gc.tparams,
        variances => gc.variances,
        pos => gc.pos,
        isMutable => false,
        fieldsFinal => true,
        kind => KBase(),
        extends_ => {
          Array[
            GTapply(ClassMetaLazyGClass(cls), DeepFrozen(), gc.tparams),
          ].concat(
            gc.extends_.map(t -> {
              GTapply(BaseMetaLazyGClass(t.generic), DeepFrozen(), t.targs)
            }),
          )
        },
        methods => this.getStaticMethods(context, gc, name).chill(),
      },
    )
  }

  private fun createBaseMetaImpl(
    context: mutable SKStore.Context,
    name: BaseMetaImplLazyGClass,
  ): GClass {
    cls = name.cls;
    gc = this.getGClassImpl(context, cls);

    this.finishGClass(
      context,
      GClass{
        name => name.name(),
        tparams => gc.tparams,
        variances => gc.variances,
        pos => gc.pos,
        isMutable => false,
        fieldsFinal => true,
        kind => KClass(),
        extends_ => Array[
          GTapply(BaseMetaLazyGClass(cls), DeepFrozen(), gc.tparams),
        ],
        methods => this.getStaticMethods(context, gc, name).chill(),
      },
    )
  }

  private fun createClassMeta(
    context: mutable SKStore.Context,
    name: ClassMetaLazyGClass,
  ): GClass {
    gc = this.getGClassImpl(context, name.cls);

    this.finishGClass(
      context,
      GClass{
        name => name.name(),
        tparams => gc.tparams,
        variances => gc.variances,
        pos => gc.pos,
        isMutable => false,
        fieldsFinal => false,
        kind => KBase(),
        extends_ => gc.extends_.map(t -> {
          GTapply(ClassMetaLazyGClass(t.generic), DeepFrozen(), t.targs)
        }),
        methods => this.getStaticMethods(context, gc, name).chill(),
      },
    )
  }

  private fun createConcreteMeta(
    context: mutable SKStore.Context,
    name: ConcreteMetaLazyGClass,
  ): GClass {
    gc = this.getGClassImpl(context, name.cls);
    pos = gc.pos;

    methods = this.getStaticMethods(context, gc, name);

    if (gc.isFrontEndClass && gc.fieldsFinal) {
      // Create abstract declarations for the factories.
      fegc = this.program.getClass(context, gc.name.id);
      for (factoryIndex in Range(0, 2)) {
        factoryIsMutable = (factoryIndex == 0);
        factory = this.createFactory(
          context,
          factoryIsMutable,
          true,
          fegc,
          pos,
        );
        (mname, mf) = this.convertMethodDef(
          context,
          factory,
          name.name(),
          gc.name,
          gc.tparams,
        );
        methods.add(mname, mf)
      }
    };

    this.finishGClass(
      context,
      GClass{
        name => name.name(),
        tparams => gc.tparams,
        variances => gc.variances,
        pos,
        isMutable => false,
        fieldsFinal => false,
        kind => KBase(),
        extends_ => {
          Array[
            GTapply(ClassMetaLazyGClass(name.cls), DeepFrozen(), gc.tparams),
          ].concat(
            gc.extends_.map(t -> {
              GTapply(ClassMetaLazyGClass(t.generic), DeepFrozen(), t.targs)
            }),
          )
        },
        methods => methods.chill(),
      },
    )
  }

  private fun createConcreteMetaImpl(
    context: mutable SKStore.Context,
    name: ConcreteMetaImplLazyGClass,
  ): GClass {
    gc = this.getGClassImpl(context, name.cls);
    pos = gc.pos;

    this.finishGClass(
      context,
      GClass{
        name => name.name(),
        tparams => gc.tparams,
        variances => gc.variances,
        pos,
        isMutable => false,
        isNative => true,
        fieldsFinal => true,
        kind => KClass(),
        extends_ => gc.extends_.map(t -> {
          GTapply(ConcreteMetaLazyGClass(t.generic), DeepFrozen(), t.targs)
        }),
        methods => {
          m = this.getStaticMethods(context, gc, name);

          if (gc.isFrontEndClass && gc.fieldsFinal) {
            // Create factories.
            fegc = this.program.getClass(context, gc.name.id);
            for (factoryIndex in Range(0, 2)) {
              factoryIsMutable = (factoryIndex == 0);
              factory = this.createFactory(
                context,
                factoryIsMutable,
                false,
                fegc,
                pos,
              );
              (mname, mf) = this.convertMethodDef(
                context,
                factory,
                name.name(),
                gc.name,
                gc.tparams,
              );
              m.add(mname, mf)
            }
          };

          m.chill()
        },
      },
    )
  }

  fun asTfun(context: mutable SKStore.Context, typ: I.Type): I.Tfun {
    typ.ty match {
    | t @ I.Tfun _ -> t
    | _ ->
      typ.pos.die(
        "Expected function type but got " + this.convertType(context, typ),
      )
    }
  }

  private fun makeGFunType{
    context: mutable SKStore.Context,
    paramTypes: Parameters<I.Type>,
    returnType: I.Type,
    isMutable: Bool,
    isTracked: Bool,
  }: GFunType {
    (flatParams, numOptional, useOptionalMask) = flattenParams(
      paramTypes,
      paramTypes,
    );
    makeGFunTypeWithFlags{
      paramTypes => this.convertTypes(context, flatParams),
      numOptional,
      useOptionalMask,
      returnType => this.convertType(context, returnType),
      isMutable,
      isTracked,
    }
  }

  // Convert a GFunType without creating the usual closure wrapper class type.
  fun convertRawTfun(context: mutable SKStore.Context, f: I.Tfun): GFunType {
    isMutable = f.modifiers.purity match {
    | I.Fpure() -> false
    | I.Fmutable() -> true
    };
    isTracked = f.modifiers.tracking match {
    | I.Ftracked() -> true
    | I.Funtracked() -> false
    };

    this.makeGFunType{
      context,
      paramTypes => f.params,
      returnType => f.returnType,
      isMutable,
      isTracked,
    }
  }

  private fun convertTapply(
    context: mutable SKStore.Context,
    name: String,
    types: Array<I.Type>,
    mutability: Mutability,
  ): GType {
    GTapply(
      FrontEndLazyGClass(name),
      mutability,
      types.map(t -> this.convertType(context, t)),
    )
  }

  // Convert an OuterIst type to an IR type.
  fun convertType(
    context: mutable SKStore.Context,
    in_: I.Type,
    mutability: Mutability = DeepFrozen(),
  ): GType {
    mustBeFrozen = true;
    ret = in_.ty match {
    | I.Tany() -> gtAny
    | I.Tapply(name, typesList) ->
      invariant(name.id != "void", "ICE void should be Void");
      !mustBeFrozen = false;
      this.convertTapply(context, name.id, typesList, mutability)
    | I.TsetElt(tparamsMap, name, typesList) ->
      !mustBeFrozen = false;

      tapply = this.convertTapply(context, name.id, typesList, mutability);

      // This back end does not care about traits, so throw them away.
      isTrait = tapply match {
      | GTapply(FrontEndLazyGClass(id), _, _) ->
        this.program.getClass(context, id).kind is I.KTrait _
      | GTapply _
      | GTparam _ ->
        false
      };

      if (!isTrait) {
        tapply
      } else {
        if (tparamsMap.size() != 1) {
          in_.pos.die(
            `Do not know how to convert type TsetElt to a GType ` +
              `because the upper bound is a trait, and there are ` +
              `${tparamsMap.size()} tparams`,
          )
        };
        (pid, pname) = tparamsMap.items().next().fromSome();
        GTparam(pid, pname)
      }
    | f @ I.Tfun _ -> this.getClosureBaseClass(this.convertRawTfun(context, f))
    | I.Tparam(v, id, name, typ2) ->
      tylist = typ2 match {
      | None() -> List::create()
      | Some(ty_cstr) -> List[ty_cstr]
      };
      this.convertTypeParameter(I.TypeParameter(v, id, name, tylist))
    | I.Tmutable(t) -> this.convertType(context, t, Mutable())
    | I.Treadonly(t) -> this.convertType(context, t, Readonly())
    | I.Tnamed(_, typ2) ->
      !mustBeFrozen = false;
      this.convertType(context, typ2, mutability)
    | I.Tdefault(ty) -> this.convertType(context, ty)
    };

    if (mustBeFrozen && mutability != DeepFrozen()) {
      in_.pos.die(`Mutability override for ${ret} unexpected here.`)
    };

    ret
  }

  fun convertTypes<T: Sequence<I.Type>>(
    context: mutable SKStore.Context,
    types: T,
  ): Array<GType> {
    types.collect(Array).map(t -> this.convertType(context, t))
  }

  private fun convertTypeParameter(in_: I.TypeParameter): GTparam {
    GTparam(in_.id, in_.name.id)
  }

  private fun convertTypeParameters<T: Sequence<I.TypeParameter>>(
    tparams: T,
  ): Array<GTparam> {
    tparams.collect(Array).map(this.convertTypeParameter)
  }

  private fun convertFields(
    context: mutable SKStore.Context,
    fields: Array<I.Parameter>,
  ): Array<GField> {
    fields.map(f -> {
      typ = this.convertType(context, f.type);
      GField{
        pos => f.name.pos,
        name => f.name.id,
        typ,
        isAssignable => f.mutable_.isSome(),
        index => f.index,
      }
    })
  }

  private fun convertExtends(
    context: mutable SKStore.Context,
    in_: I.ClassDef,
    parentMutability: Mutability,
  ): Array<GTapply> {
    in_.extends_.items().collect(Array).map(kv -> {
      ((_, name), parentInfo) = kv;
      GTapply(
        FrontEndLazyGClass(name),
        parentMutability,
        this.convertTypes(context, parentInfo.targs),
      )
    })
  }

  private fun convertClassKind(cd: I.ClassDef): GClassKind {
    (cd.kind, cd.value) match {
    | (I.KClass(), Some _) -> KValue()
    | (I.KClass(), None()) -> KClass()
    | (I.KBase(), None()) -> KBase()
    | (I.KTrait(), None()) -> KTrait()
    | _ -> cd.name.pos.die("Impossible kind")
    }
  }

  private fun convertClassDef(
    context: mutable SKStore.Context,
    in_: I.ClassDef,
    classID: FrontEndLazyGClass,
    pos: FileRange,
  ): GClass {
    kind = this.convertClassKind(in_);

    classname = classID.id;
    name = GClassName(classname);

    // Convert the tparams.
    tparams = this.convertTypeParameters(in_.tparams);
    variances = in_.tparams.map(p -> p.var).collect(Array);

    // We can only trust mutable_ on "final" classes. It just means
    // no fields known here are assignable, but subclasses could add more.
    classMutable = in_.mutable_.isSome() && kind.isFinal();
    parentMutability = Mutability::fromFlag(classMutable);

    extends_ = this.convertExtends(context, in_, parentMutability);

    nonStaticMethods = in_.methods.filter((_, v) ->
      v.kind is SkipNamedAst.FKDynamic _
    );

    // TODO: Could the type of some field depend on a class constant,
    // in which case these are not really final?
    fieldsFinal =
      kind.isFinal() ||
      {
        in_.params match {
        | Some(cp) -> cp.final_.isSome()
        | None() -> false
        }
      };

    isCppExport = annotationsContainParam(
      in_.annotations,
      "@cpp_export",
      pos,
    ).isSome();

    if (isCppExport) {
      // @cpp_export must be concrete with no base classes
      pos.invariant(
        kind is KClass _ && extends_.isEmpty(),
        `@cpp_export classes must be final and may not extend any base classes`,
      )
    };

    // Flatten the fields into calling convention order (optional last).
    fieldParams = getFields(in_, pos);
    (fields, _, _) = flattenParams(fieldParams, paramTypes(fieldParams));

    convertedFields = if (classname != "Unsafe.RawStorage") {
      this.convertFields(context, fields)
    } else {
      // Give Unsafe.RawStorage a field "value: T" to hold its internal data.
      pos.invariant(fields.isEmpty(), "Unexpected RawStorage fields.");
      Array[
        GField{
          name => "value",
          pos,
          typ => tparams[0],
          isAssignable => false,
          index => 0,
        },
      ]
    };

    methods = UnorderedMap::mcreate(nonStaticMethods.size());
    for (v in nonStaticMethods) {
      (mname, mf) = this.convertMethodDef(context, v, name, name, tparams);
      methods.add(mname, mf)
    };

    // only record nonlocal method sources
    methodFields = in_.fields.filter((_, f) ~>
      f.eltk == SkipNamedAst.EMethod() && f.source.i1 != classname
    );
    methodSources = UnorderedMap::mcreate(methodFields.size());
    for (mname => f in methodFields) {
      methodSources.add(mname.i1, FrontEndLazyGClass(f.source.i1))
    };

    this.finishGClass(
      context,
      GClass{
        name,
        tparams,
        variances,
        pos,
        isMutable => classMutable,
        isNative => in_.native_.isSome(),
        isFrontEndClass => true,
        hasMeta => !(kind is KTrait _),
        fieldsFinal,
        constructorParametersNamed => fieldParams match {
        | Positional _ -> false
        | Named _ -> true
        },
        kind,
        extends_,
        methods => methods.chill(),
        methodSources => methodSources.chill(),
        annotations => in_.annotations,
        fields => convertedFields,
      },
    )
  }

  // This provides a LazyGFun for the "inspect" function. This function calls
  // the kInspectMethodName method on its argument, something that can't
  // be expressed in user source code.
  private fun createInspect(
    funInfo: GFunInfo,
    params: Array<ParameterInfo>,
    def: I.FunDef,
  ): NormalLazyGFun {
    // Extract the only Parameter (somewhat tedious).
    param = def.params.foldl(
      (acc, param) -> {
        if (!acc.isNone()) {
          param.name.pos.die("Too many parameters");
        };
        Some(param)
      },
      (None() : ?I.Parameter),
    ) match {
    | Some(a) -> a
    | None() -> funInfo.pos.die("Missing parameter")
    };

    pos = param.name.pos;

    // Extract the parameter to inspect().
    paramExpr = I.Expr(param.type, pos, I.Local(param.name));

    // Call kInspectMethodName on it.
    returnType = def.return_;
    methodInfo = I.DotInfo{
      obj_expr => paramExpr,
      field => I.Name(pos, kInspectMethodName),
      field_targs => Array[],
      source => I.Name(pos, "<no source for inspect>"),
      elt_kind => I.EMethod(),
      field_type => I.Type(
        pos,
        I.Tfun(
          I.TfunModifiers(I.Fpure(), I.Ftracked()),
          Positional::create(),
          returnType,
        ),
      ),
    };
    call = I.MethodCall(methodInfo, Positional::create());

    // Return that value.
    body = I.Return(I.Expr(returnType, pos, call));

    NormalLazyGFun{
      funInfo => funInfo with {
        isNative => false,
        annotations => funInfo.annotations.add("@no_inline"),
      },
      params,
      body,
      useOptionalMask => true,
    }
  }

  fun convertFunDef(context: mutable SKStore.Context, in_: I.FunDef): LazyGFun {
    (pos, name) = (in_.name.pos, in_.name.id);

    tparams = this.convertTypeParameters(in_.tparams);

    funParamTypes = paramTypes(in_.params);
    funType = this.makeGFunType{
      context,
      paramTypes => funParamTypes,
      returnType => in_.return_,
      isMutable => false,
      isTracked => in_.untracked_.isNone(),
    };

    isNative = (
      (in_.native_.isSome() ||
        annotationsContainParam(in_.annotations, "@cpp_extern", pos).isSome() ||
        annotationsContainParam(in_.annotations, "@cpp_runtime", pos).isSome())
    );

    if (isNative) {
      ann = in_.annotations;
      pos.invariant(
        annotationsContainParam(ann, "@cpp_extern", pos).isSome() ||
          annotationsContainParam(ann, "@cpp_runtime", pos).isSome() ||
          annotationsContainParam(ann, "@intrinsic", pos).isSome(),
        "Native functions must be declared with @cpp_extern, @cpp_runtime, " +
          "or @intrinsic",
      );
    };

    funInfo = GFunInfo{
      gfunction => GFunctionName(name),
      pos,
      tparams,
      isNative,
      isGenerator => in_.yields.isSome(),
      annotations => in_.annotations,
      className => None(),
      funType,
    };

    (flatParams, numOptional, useOptionalMask) = flattenParams(
      in_.params,
      funParamTypes,
    );

    params = insertOptionalFlags(flatParams, numOptional, useOptionalMask, pos);

    function = if (funInfo.isNative) {
      name match {
      | "inspect" -> this.createInspect(funInfo, params, in_)
      | _ -> NativeLazyGFun{funInfo, params}
      }
    } else {
      in_.body match {
      | Some _ ->
        DefLazyGFun::make{funInfo, def => in_, params, useOptionalMask}
      | None() -> NativeLazyGFun{funInfo, params}
      }
    };

    function
  }

  private fun convertMethodDef(
    context: mutable SKStore.Context,
    in_: I.MethodDef,
    physicalClassName: GClassName,
    // Usually the same as physicalClassName, but for static methods
    // moved to metaclasses it's the original class, not the metaclass
    // where the methods are implemented in the back end.
    logicalClassName: GClassName,
    classTparams: Array<GTparam>,
  ): (String, GMethodDef) {
    (pos, name) = (in_.name.pos, in_.name.id);

    methodTparams = this.convertTypeParameters(in_.tparams);

    thisBinding = in_.implicit_param;

    isStatic = in_.kind is SkipNamedAst.FKStatic _;
    pos.invariant(
      thisBinding.name.id == (if (isStatic) "static" else "this"),
      "Surprising name for implicit arg.",
    );

    // Prepend a "this" or "static" argument.
    thisParameter = I.Parameter{
      annotations => SSet[],
      visibility => (pos, I.VPrivate()),
      name => thisBinding.name,
      type => thisBinding.ty,
      value => None(),
      frozen_ => thisBinding.info,
      index => -1,
      mutable_ => Some(pos),
    };

    (flatParamsWithoutThis, numOptional, useOptionalMask) = flattenParams(
      in_.params,
      paramTypes(in_.params),
    );
    flatParams = Array[thisParameter].concat(flatParamsWithoutThis);

    funName = physicalClassName.id + "::" + name;

    funType = makeGFunTypeWithFlags{
      paramTypes => this.convertTypes(
        context,
        flatParams.map(defaultifyParamType),
      ),
      numOptional,
      useOptionalMask,
      returnType => this.convertType(context, in_.return_),
      isMutable => false,
      isTracked => in_.untracked_.isNone(),
    };

    // Turn each method into a global generic function, whose tparams
    // are all the class tparams followed by all the method tparams.
    tparams = classTparams.concat(methodTparams);

    isCppExtern = annotationsContainParam(
      in_.annotations,
      "@cpp_extern",
      pos,
    ).isSome();
    isCppRuntime = annotationsContainParam(
      in_.annotations,
      "@cpp_runtime",
      pos,
    ).isSome();

    isNative = ((in_.native_.isSome() || isCppExtern || isCppRuntime));

    if (isNative) {
      ann = in_.annotations;
      pos.invariant(
        isCppExtern ||
          isCppRuntime ||
          annotationsContainParam(ann, "@intrinsic", pos).isSome(),
        "Native methods must be declared with @cpp_extern, @cpp_runtime, " +
          "or @intrinsic",
      );
    };

    funID = FrontEndLazyGFun{frontEndName => funName};
    funInfo = GFunInfo{
      gfunction => funID.gname(),
      pos,
      isNative,
      isGenerator => in_.yields.isSome(),
      className => Some(logicalClassName),
      annotations => in_.annotations,
      tparams,
      funType,
    };

    // Remember to compile this body once we have seen all the definitions.
    params = insertOptionalFlags(flatParams, numOptional, useOptionalMask, pos);

    methodFunction = if (funInfo.isNative) {
      // If a function (or method) is native then ignore any body it might have.
      Some(NativeLazyGFun{funInfo, params})
    } else if (in_.body is Some _) {
      Some(DefLazyGFun::make{funInfo, def => in_, params, useOptionalMask})
    } else {
      // Do nothing with regular abstract methods.
      None()
    };

    tparamInherit = if (methodTparams.isEmpty()) {
      emptyTparamInherit
    } else {
      timap = UnorderedMap::mcreate(in_.generic_mapping.size());
      for (base => tmap in in_.generic_mapping) {
        timap.set(
          FrontEndLazyGClass(base),
          methodTparams.map(tp -> this.convertType(context, tmap[tp.id])),
        )
      };
      timap.chill()
    };
    (
      name,
      GMethodDef{
        function => methodFunction.map(lazy ~> ((_, _) ~> lazy)),
        tparams => methodTparams,
        tparamInherit,
        pos,
      },
    )
  }

  private fun convertConstDef(
    context: mutable SKStore.Context,
    in_: I.ConstDef,
  ): ConstLazyGFun {
    // Create a function that unconditionally computes this constant value.
    // See GetConst for what happens next.
    funType = GFunType{
      isMutable => false,
      isTracked => true,
      params => Array[],
      returnType => this.convertType(context, in_.type),
    };

    constName = ConstID(in_.name.id);

    // generate initializer outerIst eagerly for const_defs
    !in_ = SLO.const_def(context, in_, this.program);

    in_.value match {
    | Some(init) ->
      (stmt, expr) = init.asOuter();

      funInfo = GFunInfo{
        gfunction => GFunctionName(
          constName.id + LowerConst.kComputeConstSuffix,
        ),
        pos => expr.pos,
        tparams => Array[],
        className => None(),
        funType,
        annotations => SSet[].add("@always_inline"),
      };

      ConstLazyGFun{
        funInfo,
        params => Array[],
        body => I.Seq(List.Cons(stmt, List::of(I.Return(expr)))),
        constName,
        useOptionalMask => false,
      }
    | None() -> invariant_violation("Cannot handle const with no value.")
    }
  }

  // If gclass is stored as the field of another object, does it "scalarize"
  // into no more than one scalar?
  //
  // So for any reference type this is true, since it's just one pointer.
  // For a value class with two Int fields this would be false, for a value
  // class containing a value class containing one Int it's true, etc.
  private fun scalarizesToNoMoreThanOneScalar(
    context: mutable SKStore.Context,
    gid: LazyGClass,
    pos: Pos,
  ): Bool {
    loop {
      this.getGClassKind(context, gid) match {
      | KBase()
      | KClass() ->
        return true
      | KValue() ->
        gclass = this.getGClass(context, gid, pos);
        if (gclass.fields.isEmpty()) {
          return true
        } else if (gclass.fields.size() > 1) {
          return false
        } else {
          gclass.fields[0].typ match {
          | GTapply(subgid, _, _) ->
            // This should not loop forever because you can't have
            // an infinitely recursive value class type.
            !gid = subgid
          | _ -> return false
          }
        }
      | KTrait() -> pos.die("Cannot scalarize a trait")
      }
    }
  }

  private fun assertNoStaticMethods(
    context: mutable SKStore.Context,
    lazyGClass: LazyGClass,
    gc: GClass,
  ): void {
    metaID = this.getMetaClass(context, lazyGClass, Some(gc));
    for (name => def in this.getGClassImpl(context, metaID).methods) {
      if (
        name != kFrozenFactoryName &&
        name != kGetClassMethodName &&
        name != kInspectMethodName &&
        name != kMutableFactoryName
      ) {
        def.pos.die(
          `Unexpected static method ${name} for special class ` +
            lazyGClass.nameStr(),
        )
      }
    }
  }

  // Every generator gets its own subclass of Iterator to hold its
  // particular coroutine state. This produces a new such class
  // for the generator function described by funInfo.
  fun createGeneratorClass(
    context: mutable SKStore.Context,
    funInfo: GFunInfo,
  ): GTapply {
    // We start with Iterator.Generator as a basic template
    // for the custom class we want to create, then tweak it.
    pos = funInfo.pos;

    // Computes Array[XX] for the return type "mutable Iterator<XX>".
    yieldedTargs = funInfo.funType.returnType match {
    | GTapply(
      FrontEndLazyGClass("Iterator"),
      Mutable(),
      t,
    ) if (t.size() == 1) ->
      t
    | bad -> funInfo.die(`Expected mutable Iterator return type, got ${bad}`)
    };

    template = this.getGClass(
      context,
      FrontEndLazyGClass("Iterator.Generator"),
      pos,
    );

    // This class takes as tparams all of the tparams in the
    // environment where the body appears, since that body might
    // reference them. Additionally it takes the T for Iterator<T> so
    // that any fields etc. that it inherits can be resolved in terms
    // of that T.
    tparams = template.tparams.concat(funInfo.tparams);

    generatorGClass = template with {
      name => GClassName(funInfo.gfunction.id + "::Generator"),
      isFrontEndClass => false,
      tparams,

      // Replace "extends Iterator<T>" with "extends Iterator<XX>" where
      // "mutable Iterator<XX>" is the declared return type of the
      // function containing the yield.
      extends_ => template.extends_.map(ext -> {
        if (ext.generic.name() != GClassName("Iterator")) {
          ext
        } else {
          ext with {targs => yieldedTargs}
        }
      }),

      methods => template.methods
        .filter((name, _) -> name != kInspectMethodName)
        .map((name, methodDef) -> {
          if (name != "next") {
            methodDef
          } else {
            GMethodDef{
              function => Some((_context, receiver) ~> {
                generatorType = GTapply(receiver, Mutable(), tparams);

                // Produce a skeleton for the "next" method. The body will
                // be filled in for real much later, once the ramp up function
                // has been optimized and gets split in two.
                nextImpl = GFunction{
                  funInfo => GFunInfo{
                    gfunction => GFunctionName(receiver.nameStr() + "::next"),
                    funType => GFunType{
                      isMutable => false,
                      isTracked => funInfo.funType.isTracked,
                      params => Array[generatorType],
                      returnType => GTapply(
                        FrontEndLazyGClass("Option"),
                        Readonly(),
                        yieldedTargs,
                      ),
                    },
                    tparams,
                    pos,
                    className => Some(receiver.name()),
                    annotations => funInfo.annotations,
                  },
                  params => Array[GFunParam{typ => generatorType, pos}],
                  blocks => Array[
                    // Dummy body for now.
                    GBlock{
                      id => GBlockID(0),
                      pos,
                      instrs => Vector[
                        GUnreachable{
                          why => "incomplete generator 'next' method",
                          pos,
                        },
                      ],
                    },
                  ],
                  coroutineInfo => Some(GUnfinishedNext(funInfo)),
                };

                DoneLazyGFun{function => nextImpl}
              }),
              tparams => Array[],
              pos,
            }
          }
        }),
    };

    GTapply(
      LiteralLazyGClass(this.finishGClass(context, generatorGClass)),
      Mutable(),
      yieldedTargs.concat(funInfo.tparams),
    )
  }
}

class TryInfo{
  llvmLandingPad: GBlockID,
  catchMatch: GBlockID,
  exceptionVariable: String,
}

class SwitchBranch<T>(value: T, actionIndex: Int, pos: FileRange)

mutable class SwitchAction(body: I.Stmt, block: mutable GBlock)

// Manages converting a single function from OuterIst to GIR.
mutable class OuterIstEmitter{
  converter: Converter,
  mutable funInfo: GFunInfo,
  lazy: ConcreteLazyGFun,
  mutable nextBlockID: Int = 0,
  mutable nextClosureID: Int = 0,
  mutable nextInstrID: Int = 0,
  mutable nextTryID: Int = 0,
  // Containing "try" catch clause blocks ("landing pads").
  mutable tryInfo: ?TryInfo = None(),
  mutable continueID: GBlockID = GBlockID::none,

  mutable exitBlockID: GBlockID = GBlockID::none,

  // Maps local name to the GInstr providing its value and a flag indicating
  // whether that is the value (false) or a LocalVariable holding its value
  // indirectly (true).
  locals: mutable UnorderedMap<String, (GInstr, Bool)> = mutable UnorderedMap[],
  // Maps labels to JumpBlock entry block ids.
  labels: mutable UnorderedMap<String, GBlockID> = mutable UnorderedMap[],
  blocks: mutable Vector<mutable GBlock> = mutable Vector[],
  mutable params: Array<GFunParam> = Array[],
  mutable blockActive: Bool = false,
  mutable pos: FileRange,
} {
  static fun make(
    context: mutable SKStore.Context,
    converter: Converter,
    lazy: ConcreteLazyGFun,
  ): mutable OuterIstEmitter {
    funInfo = lazy.funInfo;
    if (funInfo.isGenerator) {
      !funInfo.funType.returnType = converter.createGeneratorClass(
        context,
        funInfo,
      )
    };

    mutable OuterIstEmitter{converter, funInfo, lazy, pos => lazy.funInfo.pos}
  }

  readonly fun constantBool(value: Bool): GConstantBool {
    GConstantBool{value}
  }

  readonly fun constantChar(value: Char): GConstantChar {
    GConstantChar{value}
  }

  readonly fun constantDefaultArg(typ: GType): GConstantDefaultArg {
    GConstantDefaultArg{typ}
  }

  readonly fun constantFloat(value: Float): GConstantFloat {
    GConstantFloat{value}
  }

  readonly fun constantInt(value: Int): GConstantInt {
    GConstantInt{value}
  }

  readonly fun constantString(value: UTF8String): GConstantString {
    GConstantString{value}
  }

  readonly fun constantVoid(): GConstantVoid {
    GConstantVoid{}
  }

  readonly fun constantZero(typ: GType): GConstantZero {
    GConstantZero{typ}
  }

  mutable fun emitInstr(instr: GStmt): GStmt {
    if (this.blockActive) {
      // Allocate an GInstrID for this instruction.
      id = this.nextInstrID;
      this.!nextInstrID = id + 1;
      !instr = instr with {id => GInstrID(id)};

      this.blocks.last().instrs.push(instr);

      instr match {
      | GTerminator _ -> this.!blockActive = false
      | _ -> void
      }
    };
    instr
  }

  // Returns the raw value of a local variable, which may be the value itself
  // or may be a ref wrapping it.
  private mutable fun getRawLocal(
    name: String,
    pos: FileRange,
  ): (GInstr, Bool) {
    this.locals.maybeGet(name) match {
    | Some(binding) -> binding
    | None() ->
      buf = mutable Vector[];
      this.locals.keys().each(buf.push);
      pos.die(
        "Accessing unknown variable " +
          name +
          ": choices are " +
          buf.join(", "),
      )
    }
  }

  mutable fun getLocal(name: String, pos: FileRange): GInstr {
    (value, byRef) = this.getRawLocal(name, pos);
    if (!byRef) {
      value
    } else {
      // Dereference the LocalVariable storing the value by reference.
      this.emitInstr(
        GGetField{
          typ => value.getType().asGTapply(pos).targs[0],
          pos,
          obj => value,
          field => "value",
          prettyName => name,
        },
      )
    }
  }

  mutable fun setLocal(var: String, value: GInstr, pos: FileRange): void {
    (ref, byRef) = this.getRawLocal(var, pos);

    if (byRef) {
      // Capture-by-reference, so set the field of the ref.
      _ = this.emitInstr(GSetField{pos, obj => ref, field => "value", value})
    } else if (ref.getType() != gtVoid) {
      // Only by-reference values can be set after they are bound.
      pos.die(
        "Found unexpected assignment to variable " +
          var +
          " of type " +
          value.getType() +
          " (var is " +
          ref.getType() +
          ")",
      )
    }
  }

  mutable fun emitPreamble(): void {
    lazy = this.lazy;

    this.startBlock(this.newBlock(this.pos, "entry"));

    funType = this.funInfo.funType;
    this.pos.invariant(
      funType.params.size() == lazy.params.size(),
      "args mismatch",
    );

    // Create FunParams and assign them the first IDs to match Emitter.
    this.!params = lazy.params.mapWithIndex((i, p) -> {
      GFunParam{
        id => GInstrID(i),
        typ => funType.params[i],
        pos => p.pos,
        prettyName => p.name,
      }
    });
    this.pos.invariant(this.nextInstrID == 0, "FunParams not numbered right");
    this.!nextInstrID = lazy.params.size();

    returnTempType = lazy.returnTempType();
    if (returnTempType != gtVoid) {
      // Declare a return value variable. "Return" assigns to this then
      // jumps to the exit block.
      this.emitBind(
        kImplicitReturnVariableName,
        returnTempType,
        this.constantZero(returnTempType),
        SkipOuterIstUtils.nonconst_binding_info,
        this.pos,
      )
    }
  }

  mutable fun emitBindParameters(context: mutable SKStore.Context): void {
    lazy = this.lazy;

    // Bind captured variables as locals.
    // Load the raw value of each captured variable from the closure.
    // This may or may not be a LocalVariable.
    for (f in lazy.captured) {
      (localName, closureCaptureKind) = parseClosureFieldName(f);

      load = this.emitInstr(
        GGetField{
          typ => f.typ,
          pos => f.pos,
          obj => this.params[0],
          field => f.name,
          prettyName => localName,
        },
      );

      closureCaptureKind match {
      | CCByValue() -> this.locals.set(localName, (load, false))
      | CCByRef() -> this.locals.set(localName, (load, true))
      | CCNotCaptured() -> f.pos.die("Expected captured field " + localName)
      }
    };

    paramInfos = lazy.getParams(context, this.converter);

    // Declare all required arguments and all optional positional arguments.
    // Optional named arguments are handled below.
    firstOptional = -1;
    paramInfos.eachWithIndex((i, param) -> {
      isOptional = param.value.isSome();
      if (firstOptional < 0 && isOptional) {
        !firstOptional = i
      };

      // NOTE: In the case of an optional parameter, this may end up
      // storing zero bits in a LocalVariable, where it will be overwritten
      // with the real value. This is safe, since no one can look at it
      // until a real value is assigned, but it's worth calling out here.
      this.emitBind(
        param.name,
        this.params[i].getType(),
        this.params[i],
        param.info with {updated => param.info.updated || isOptional},
        param.pos,
      )
    });

    //
    // Compute default arguments.
    //
    if (firstOptional >= 0) {
      numOptional = paramInfos.size() - firstOptional;

      if (lazy.useOptionalMask) {
        // We have named optional arguments. We need to evaluate them in
        // declaration order, not alphabetical order. This is both for
        // side effects and if, someday, we allow default values to
        // reference earlier parameter values.
        argIndices = Array::fillBy(numOptional, i ->
          i + firstOptional
        ).sortedBy(ai ~> {
          paramInfos[ai].index
        });

        for (argIndex in argIndices) {
          param = paramInfos[argIndex];
          name = param.name;
          pos = param.pos;

          (defaultStmt, defaultExpr) = param.getInit().asOuter();

          flagIndex = argIndex - firstOptional;
          whichFlag = flagIndex / 64;
          suppliedMask = this.getLocal(kOptSuppliedPrefix + whichFlag, pos);

          bit = this.emitInstr(
            GCallMethod{
              typ => gtInt,
              pos,
              method => "andImpl",
              args => Array[
                suppliedMask,
                this.constantInt(1.shl(flagIndex % 64)),
              ],
              source => gtInt.generic,
            },
          );

          predicate = this.emitInstr(
            GCallMethod{
              typ => gtBool,
              pos,
              method => "neImpl",
              args => Array[bit, this.constantInt(0)],
              source => gtInt.generic,
            },
          );

          computeDefaultBlock = this.newBlock(pos, "set_optional_" + name);

          afterBlock = this.newBlock(pos, "done_optional_" + name);

          _ = this.emitInstr(
            GIf{
              pos,
              predicate,
              successors => Array[afterBlock.id, computeDefaultBlock.id],
            },
          );

          // Conditionally replace this variable with its default value.
          this.startBlock(computeDefaultBlock);
          this.emitStmt(context, defaultStmt);
          defaultExprPos = defaultExpr.pos;
          this.setLocal(
            name,
            this.emitExpr(context, defaultExpr),
            defaultExprPos,
          );
          this.maybeEmitJump(afterBlock.id, defaultExprPos);

          this.startBlock(afterBlock)
        }
      } else {
        pos = this.pos;

        numArgs = this.getLocal(kOptSuppliedPrefix + "0", pos);

        // Create the blocks for the "switch" to jump to.
        // For N arguments there are N + 1 blocks we might execute;
        // for example, if we have 3 optional positional arguments,
        // there are four possibilities: 0, 1, 2, or 3 arguments were supplied.
        // We add an additional "default" block for the IntSwitch containing
        // only an "Unreachable" to tell LLVM that it does not need to handle
        // the default case.

        blocks = mutable Vector[];
        blocks.push(this.newBlock(pos, "setup_optional_impossible"));
        for (i in Range(0, numOptional)) {
          blocks.push(this.newBlock(paramInfos[i].pos, "setup_optional_" + i))
        };
        blocks.push(this.newBlock(pos, "setup_optional_done"));

        _ = this.emitInstr(
          GIntSwitch{
            pos,
            value => numArgs,
            cases => Array::fillBy(numOptional + 1, id),
            successors => Array::fillBy(blocks.size(), i -> blocks[i].id),
          },
        );

        // Emit the "default" case where an impossible number of optional
        // arguments was supplied.
        this.startBlock(blocks[0]);
        _ = this.emitInstr(
          GUnreachable{why => "impossible bind parameters", pos},
        );

        for (i in Range(0, numOptional)) {
          this.startBlock(blocks[i + 1]);

          param = paramInfos[firstOptional + i];
          (defaultStmt, defaultExpr) = param.getInit().asOuter();

          this.emitStmt(context, defaultStmt);
          defaultExprPos = defaultExpr.pos;
          this.setLocal(
            param.name,
            this.emitExpr(context, defaultExpr),
            defaultExprPos,
          );

          // "Fall through" to the next case.
          this.maybeEmitJump(blocks[i + 2].id, defaultExprPos)
        };

        this.startBlock(blocks[numOptional + 1])
      }
    }
  }

  private mutable fun emitParams(
    context: mutable SKStore.Context,
    params: Parameters<I.Expr>,
    expectedTypes: Parameters<I.Type>,
    skipOptionalFlags: Bool = false,
  ): Array<GInstr> {
    (flatParams, numOptional, useOptionalMask) = flattenParams(
      params,
      expectedTypes,
    );
    args = flatParams.map(arg -> this.emitExpr(context, arg));

    if (numOptional == 0 || skipOptionalFlags) {
      args
    } else {
      numRequired = flatParams.size() - numOptional;

      flags = if (useOptionalMask) {
        // Insert extra arg(s) indicating which optional args are supplied.
        masks = Array::mfill(computeNumOptionalFlagInts(numOptional, true), 0);

        for (i in Range(0, numOptional)) {
          args[numRequired + i] match {
          | GConstantDefaultArg _ -> void
          | _ ->
            // Set a 1 bit for each named arg that is being supplied.
            index = i / 64;
            bit = 1.shl(i % 64);
            masks.set(index, masks[index].or(bit))
          };
        };

        masks.map(n -> this.constantInt(n))
      } else {
        // Scan to find first missing positional argument.
        firstMissing = numRequired;
        done = false;

        while (firstMissing < args.size() && !done) {
          args[firstMissing] match {
          | GConstantDefaultArg _ -> !done = true
          | _ -> !firstMissing = firstMissing + 1
          };
        };

        Array[this.constantInt(firstMissing - numRequired)];
      };

      // Insert optional arg flags in the middle.
      numFlagInts = flags.size();
      Array::fillBy(args.size() + numFlagInts, i -> {
        if (i < numRequired) {
          args[i]
        } else if (i < numRequired + numFlagInts) {
          flags[i - numRequired]
        } else {
          args[i - numFlagInts]
        }
      })
    }
  }

  mutable fun emitCast(frm: GInstr, typ: GType, pos: FileRange): GInstr {
    this.emitInstr(GCast{typ, pos, value => frm})
  }

  mutable fun newBlock(
    pos: FileRange,
    prettyName: String = "",
  ): mutable GBlock {
    // NOTE: This Block is not the final one we will end up with in the
    // GFunction, it's just a carrier of fields we'll need for the final block.
    id = this.nextBlockID;
    this.!nextBlockID = id + 1;
    mutable GBlock{id => GBlockID(id), prettyName, pos}
  }

  mutable fun terminateExistingBlock(): void {
    if (this.blockActive) {
      _ = this.emitInstr(GUnreachable{why => "end of block", pos => this.pos})
    }
  }

  mutable fun startBlock(b: mutable GBlock): void {
    if (this.blockActive) {
      b.pos.die("Unterminated block")
    };
    this.blocks.push(b);
    this.!blockActive = true;
    this.!pos = b.pos
  }

  private mutable fun convertType(
    context: mutable SKStore.Context,
    typ: I.Type,
  ): GType {
    this.converter.convertType(context, typ)
  }

  // Emit a call to a global function.
  mutable fun emitCallFunction(
    name: LazyGFun,
    args: Array<GInstr>,
    targs: Array<GType>,
    typ: GType,
    pos: FileRange,
  ): GInstr {
    this.tryInfo match {
    | None() ->
      // A normal call (not inside a "try").
      this.emitInstr(GCallFunction{typ, pos, name, args, targs})
    | Some(tryInfo) ->
      // A "call" lexically inside a "try" becomes an "invoke",
      // possibly transferring control to the "catch" landing pad.
      nextBlockIfNoThrow = this.newBlock(pos, "try_no_throw");

      invoke = this.emitInstr(
        GInvokeFunction{
          typ,
          pos,
          name,
          args,
          targs,
          successors => Array[nextBlockIfNoThrow.id, tryInfo.llvmLandingPad],
        },
      );

      this.startBlock(nextBlockIfNoThrow);

      invoke
    }
  }

  private mutable fun emitMethodCall(
    context: mutable SKStore.Context,
    info: I.DotInfo,
    methodArgs: Parameters<I.Expr>,
    staticMethodCall: Bool,
    pos: FileRange,
  ): GInstr {
    info.elt_kind match {
    | I.EMethod()
    | I.EConst() ->
      void
    | I.EProperty() -> pos.die("Cannot handle EProperty yet")
    };

    obj = this.emitExpr(context, info.obj_expr);
    frontEndMethodType = this.converter.asTfun(context, info.field_type);
    reorderedArgs = this.emitParams(
      context,
      methodArgs,
      frontEndMethodType.params,
    );

    args = Array[obj].concat(reorderedArgs);

    // Find the type of the method, which does not include "this".
    mtype = this.converter.convertRawTfun(context, frontEndMethodType);

    // Prepend a "this" of whatever object type we are invoking it on.
    typ = mtype with {params => Array[obj.getType()].concat(mtype.params)};

    targs = this.converter.convertTypes(context, info.field_targs);

    source = (FrontEndLazyGClass(info.source.id) : LazyGClass);
    if (staticMethodCall) {
      // Change the "source" of a static method from Foo to Class<Foo>, etc.,
      // since that's where it will exist in the GClass hierarchy.
      !source = ClassMetaLazyGClass(source)
    };

    method = info.field.id;

    this.tryInfo match {
    | None() ->
      // A normal call (not inside a "try").
      this.emitInstr(
        GCallMethod{typ => typ.returnType, pos, method, args, targs, source},
      )
    | Some(tryInfo) ->
      // A "call" lexically inside a "try" becomes an "invoke",
      // possibly transferring control to the "catch" landing pad.
      nextBlockIfNoThrow = this.newBlock(pos, "try_no_throw");

      invoke = this.emitInstr(
        GInvokeMethod{
          typ => typ.returnType,
          pos,
          method,
          args,
          targs,
          successors => Array[nextBlockIfNoThrow.id, tryInfo.llvmLandingPad],
          source,
        },
      );

      this.startBlock(nextBlockIfNoThrow);

      invoke
    }
  }

  private mutable fun emitClosureCall(
    context: mutable SKStore.Context,
    funcExpr: I.Expr,
    params: Parameters<I.Expr>,
    pos: FileRange,
  ): GInstr {
    closureType = this.convertType(context, funcExpr.ty);
    closureTypeName = closureType match {
    | GTapply(generic, _, _) -> generic.nameStr()
    | _ -> ""
    };

    if (!closureTypeName.startsWith("<builtin>.Closure")) {
      pos.die("Expected closure type but got " + closureType)
    };

    // Closures are an object with a single "call" method.
    info = I.DotInfo{
      obj_expr => funcExpr,
      field => I.Name(pos, "call"),
      field_targs => Array[],
      source => I.Name(pos, closureTypeName), /// ??? wrong, not a front end type
      elt_kind => I.EMethod(),
      field_type => funcExpr.ty,
    };

    this.emitMethodCall(context, info, params, false, pos)
  }

  private mutable fun getNextClosureID(): Int {
    n = this.nextClosureID;
    this.!nextClosureID = n + 1;
    n
  }

  mutable fun emitLambda{
    context: mutable SKStore.Context,
    paramVars: Array<I.Binding>,
    captured: Array<I.Name>,
    body: I.Stmt,
    closureClassNameHint: String,
    callMethodType: GFunType,
    yields: Bool,
    pos: FileRange,
  }: GInstr {
    closureBaseType = this.converter.getClosureBaseClass(callMethodType);

    // We create one field per captured variable.
    fieldsAndValues = captured.map(posAndName -> {
      (capturePos, name) = (posAndName.pos, posAndName.id);
      (rawValue, byRef) = this.getRawLocal(name, capturePos);

      (fieldPrefix, fieldValue) = if (!byRef) {
        ("captured:", rawValue)
      } else {
        ("captured_ref:", rawValue)
      };

      ( // NOTE: These field names are important, see parseClosureFieldName.
        GField{
          name => fieldPrefix + name,
          typ => fieldValue.getType(),
          pos => capturePos,
          isAssignable => false,
          index => -1,
        },
        fieldValue,
      )
    });

    fields = fieldsAndValues.map(fv -> fv.i0);

    generateBody = funInfo ~> {
      paramInfos = Array::fillBy(funInfo.funType.params.size(), i -> {
        // Prepend a "this" parameter with a non-conflicting name.
        if (i == 0) {
          ParameterInfo{
            name => "closure:this",
            value => None(),
            info => SkipOuterIstUtils.const_binding_info,
            index => i,
            pos,
          }
        } else {
          paramVar = paramVars[i - 1];
          ParameterInfo{
            name => paramVar.name.id,
            value => None(),
            info => paramVar.info,
            index => i,
            pos => paramVar.name.pos,
          }
        }
      });

      NormalLazyGFun{
        funInfo,
        params => paramInfos,
        body,
        captured => fields,
        useOptionalMask => false,
      }
    };

    closureClassName = GClassName(
      this.funInfo.gfunction.id +
        "::" +
        closureClassNameHint +
        this.getNextClosureID(),
    );

    closureGClass = this.converter.createClosureClass(
      context,
      closureClassName,
      callMethodType,
      this.funInfo.tparams,
      // TODO: Does the variance need to track that of the containing class?
      Array::fill(this.funInfo.tparams.size(), I.Vnone()),
      KClass(),
      Array[closureBaseType],
      yields,
      pos,
      Some(generateBody),
      fields,
    );

    closureType = GTapply(
      LiteralLazyGClass(closureGClass),
      Mutability::fromFlag(callMethodType.isMutable),
      this.funInfo.tparams,
    );

    closureObj = this.emitInstr(
      GObject{
        typ => closureType,
        pos,
        args => fieldsAndValues.map(fv -> fv.i1),
      },
    );

    this.emitCast(closureObj, closureBaseType, pos)
  }

  private mutable fun emitWith(
    context: mutable SKStore.Context,
    objExpr: I.Expr,
    typ: GType,
    fieldAssignments: UMap<I.WithUpdate>,
  ): GInstr {
    pos = objExpr.pos;
    obj = this.emitExpr(context, objExpr);

    // Sort assignments by source position so we evaluate them in
    // the user's original order (see T16663788).
    assignmentExprs = fieldAssignments.items().collect(Vector).sortedBy(x ~>
      Orderable.create(x, (a, b) ~> {
        (aName, _aExpr) = a;
        (bName, _bExpr) = b;
        aName.compare(bName)
      })
    );

    // Compile expressions in order and make a map of their values.
    assignments = assignmentExprs.map(a -> {
      ((_aPos, aField), aExprSourceCast) = a;
      (aField, this.emitExpr(context, aExprSourceCast.expr))
    });

    this.emitInstr(
      GWith{typ, pos, obj, fieldAssignments => assignments.toArray()},
    )
  }

  private mutable fun emitFactoryCall(
    context: mutable SKStore.Context,
    runtimeType: I.Expr,
    frontEndType: I.Type,
    name: I.Name,
    _types: Array<I.Type>,
    params: Parameters<I.Expr>,
    pos: FileRange,
  ): GInstr {
    // Reverse engineer the factory's type (close enough, anyway) by looking
    // at the values being passed to it, which we know passed type checking.
    defaultedParams = if (params.isEmpty()) {
      // Special case no arguments, importantly handling metaclasses
      // which have no ClassDef.
      params.map(p -> p.ty)
    } else {
      // See which fields are optional.
      fields = getFields(
        this.converter.program.getClass(context, name.id),
        pos,
      );
      optional = mutable Vector[];
      _ = fields.map(field -> optional.push(field.value.isSome()));

      if (optional.size() != params.size()) {
        pos.die("Parameter count mismatch calling factory.")
      };

      // NOTE: it's a bit annoying to recover the actual argument types here
      // as that would require applying Tparams etc. But we don't need to --
      // all we need to know is which arguments are optional and which aren't,
      // so we get the calling convention right. We can pretend that the
      // factory takes exactly the argument types we are passing it, since
      // that mild lie will be discarded soon anyway.
      index = -1;
      params.map(x -> {
        !index = index + 1;
        typ = x.ty;

        if (optional[index]) {
          I.Type(typ.pos, I.Tdefault(typ))
        } else {
          typ
        }
      })
    };

    factoryFunType = I.Tfun(
      I.TfunModifiers(I.Fpure(), I.Ftracked()),
      defaultedParams,
      frontEndType,
    );

    // Call the appropriate factory depending whether we want a frozen
    // object or a mutable one.
    factoryName = if (isMutableType(frontEndType)) {
      ".mutableFactory"
    } else {
      ".frozenFactory"
    };

    this.emitMethodCall(
      context,
      I.DotInfo{
        obj_expr => runtimeType,
        field => I.Name(pos, factoryName),
        field_targs => Array[],
        source => name,
        elt_kind => I.EMethod(),
        field_type => I.Type(pos, factoryFunType),
      },
      params,
      true,
      pos,
    )
  }

  private mutable fun emitExpr(
    context: mutable SKStore.Context,
    expr__: I.Expr,
    prettyName: String = "",
  ): GInstr {
    (frontEndType, pos, top_expr) = (expr__.ty, expr__.pos, expr__.expr);

    typ = this.convertType(context, frontEndType);

    instr = top_expr match {
    | I.DefaultArg() -> this.constantDefaultArg(typ)
    | I.Unreachable() ->
      // This terminates control without producing any value.
      _ = this.emitInstr(GUnreachable{why => "no value", pos});

      // Start a dummy block just so any following instructions have
      // somewhere to go. This block will be discarded.
      this.startBlock(this.newBlock(pos, "unreachable"));

      // The front end will use the value of an Unreachable so we need
      // to make something for it.
      this.constantZero(typ)
    | I.ELiteral(lit) ->
      lit match {
      | I.LBool(value) -> this.constantBool(value)
      | I.LChar(value) -> this.constantChar(Char::fromCode(value))
      | I.LFloat(value) -> this.constantFloat(value)
      | I.LInt(value) -> this.constantInt(value)
      | I.LString(value) -> this.constantString(UTF8String::make(value))
      | I.LVoid() ->
        evoid = I.Object(I.Name(pos, "Void"), Array[], Positional(Array[]));
        this.emitExpr(context, I.Expr(frontEndType, pos, evoid), prettyName)
      }
    | I.Const(I.Name(_, name)) ->
      this.emitInstr(GGetConst{typ, pos, name => ConstID(name)})
    | I.Local(I.Name(_, name)) ->
      localValue = this.getLocal(name, pos);
      if (typ == localValue.getType()) {
        localValue
      } else {
        this.emitCast(localValue, typ, pos)
      }
    | I.DynamicConstruction(expr, name, types, params) ->
      this.emitFactoryCall(
        context,
        expr,
        frontEndType,
        name,
        types,
        params,
        pos,
      )
    | I.Object(name, types, params) ->
      if (hasDefaultArg(params)) {
        // Missing at least one constructor argument, so call the factory.
        meta = I.Expr(
          I.Type(pos, I.Tapply(I.Name(pos, "Concrete"), Array[frontEndType])),
          pos,
          I.Classname(name),
        );
        this.emitFactoryCall(
          context,
          meta,
          frontEndType,
          name,
          types,
          params,
          pos,
        )
      } else {
        cd = this.converter.program.getClass(context, name.id);
        args = this.emitParams(
          context,
          params,
          paramTypes(getFields(cd, pos)),
          true,
        );

        this.emitInstr(GObject{typ, pos, prettyName, args})
      }
    | I.Call(funcExpr, params) ->
      this.emitClosureCall(context, funcExpr, params, pos)
    | I.FunCall(name, tparams, params) ->
      def = this.converter.program.getFun(context, name.id);

      this.emitCallFunction(
        FrontEndLazyGFun{frontEndName => name.id},
        this.emitParams(context, params, paramTypes(def.params)),
        this.converter.convertTypes(context, tparams),
        typ,
        pos,
      )
    | I.MethodCall(info, params) ->
      this.emitMethodCall(context, info, params, false, pos)
    | I.StaticCall(info, params) ->
      this.emitMethodCall(context, info, params, true, pos)
    | I.Dot(info) ->
      obj = this.emitExpr(context, info.obj_expr);

      info.elt_kind match {
      | I.EConst _ -> pos.die("Cannot handle impossible Dot EConst.")
      | I.EMethod _ -> pos.die("Cannot handle impossible Dot EMethod.")
      | I.EProperty _ ->
        if (!info.field_targs.isEmpty()) {
          pos.die("type parameters unexpected here.")
        };

        this.emitInstr(GGetField{typ, pos, obj, field => info.field.id})
      }
    | I.StaticDot(info) ->
      info.elt_kind match {
      | I.EMethod _ -> pos.die("Cannot handle impossible StaticDot EMethod.")
      | I.EProperty _ ->
        pos.die("Cannot handle impossible StaticDot EProperty.")
      | I.EConst _ ->
        if (!info.field_targs.isEmpty()) {
          pos.die("type parameters unexpected here.")
        };

        // Desugar accessing a static class const into a static method
        // call. We need to do this because consts can be overridden.
        callInfo = info with {
          field => I.Name(info.field.pos, "getConst:" + info.field.id),
          elt_kind => I.EMethod(),
          field_type => I.Type(
            pos,
            I.Tfun(
              I.TfunModifiers(I.Fpure(), I.Ftracked()),
              Positional::create(),
              frontEndType,
            ),
          ),
        };

        this.emitMethodCall(context, callInfo, Positional::create(), true, pos)
      }
    | I.Lambda(params, _, captured, body, yields) ->
      (flatParams, _, _) = flattenParams(params, params.map(b -> b.ty));
      this.emitLambda{
        context,
        paramVars => flatParams,
        captured => captured.values().map(p -> p.name).collect(Array),
        body,
        closureClassNameHint => "Closure",
        callMethodType => this.converter.convertRawTfun(
          context,
          this.converter.asTfun(context, frontEndType),
        ),
        yields => yields.isSome(),
        pos,
      }
    | I.EArray(exprs) ->
      this.emitInstr(
        GEArray{typ, pos, args => exprs.map(e -> this.emitExpr(context, e))},
      )
    | I.Freeze(expr) ->
      this.emitInstr(GFreeze{typ, pos, obj => this.emitExpr(context, expr)})
    | I.GetClass(expr) ->
      // Desugar class(x) -> x..getClass()
      // These methods are machine-generated and never throw so we don't
      // need to worry about "invoke" vs "call".
      obj = this.emitExpr(context, expr);
      this.emitInstr(
        GCallMethod{
          typ,
          pos,
          method => kGetClassMethodName,
          args => Array[obj],
          targs => Array[],
          source => obj.getType() match {
          | GTapply(generic, _, _) -> generic
          | _ ->
            // source is barely used so it should be OK if we somehow
            // don't know it here.
            FrontEndLazyGClass("<no source for getClass>")
          },
        },
      )
    | I.Classname _ ->
      // Allocate an instance of the metatype, knowing that
      // post-specialization this can get optimized into a singleton.
      this.emitInstr(GObject{typ, pos, args => Array[]})
    | I.With(expr, fieldAssignments) ->
      this.emitWith(context, expr, typ, fieldAssignments)
    | I.Cast(castType, expr) ->
      _typ = this.convertType(context, castType);
      this.emitCast(this.emitExpr(context, expr), typ, pos)
    };

    instr
  }

  private mutable fun emitJumpTo(label: I.Name): void {
    (pos, name) = (label.pos, label.id);
    this.labels.maybeGet(name) match {
    | Some(blockID) -> this.maybeEmitJump(blockID, pos)
    | None() -> pos.die("Label `" + name + "` not in scope")
    }
  }

  private mutable fun emitJumpBlock(
    context: mutable SKStore.Context,
    entries: List<I.LabeledStmt>,
  ): void {
    items = mutable Vector[];
    for (lstmt in entries) {
      (label, stmt) = (lstmt.label, lstmt.stmt);
      (pos, name) = (label.pos, label.id);
      line = getLineStr(pos);
      block = this.newBlock(pos, "jumpBlock_" + name + "_" + line);
      this.labels.add(name, block.id);
      items.push(mutable JumpBlockInfo{pos, name, stmt, block})
    };

    size = items.size();
    for (i in Range(0, size)) {
      item = items[i];
      this.labels.remove(item.name);
      this.emitStmt(context, item.stmt);
      this.maybeEmitJump(items[0].block.id, item.pos);
      this.startBlock(items[(i + 1) % size].block)
    }
  }

  private mutable fun emitIf(
    context: mutable SKStore.Context,
    predInstr: GInstr,
    trueBody: I.Stmt,
    falseBody: I.Stmt,
    pos: FileRange,
  ): void {
    lineStr = getLineStr(pos);

    trueBlock = this.newBlock(pos, "if_true_" + lineStr);
    falseBlock = this.newBlock(pos, "if_false_" + lineStr);
    joinBlock = this.newBlock(pos, "join_if_" + lineStr);

    _ = this.emitInstr(
      GIf{
        pos,
        predicate => predInstr,
        successors => Array[trueBlock.id, falseBlock.id],
      },
    );

    // Emit the "if true" clause.
    this.startBlock(trueBlock);
    this.emitStmt(context, trueBody);
    this.maybeEmitJump(joinBlock.id, pos);

    // Emit the "if false" clause.
    this.startBlock(falseBlock);
    this.emitStmt(context, falseBody);
    this.maybeEmitJump(joinBlock.id, pos);

    this.startBlock(joinBlock)
  }

  private mutable fun emitLoopForever(
    context: mutable SKStore.Context,
    pos: FileRange,
    body: I.Stmt,
  ): void {
    block = this.newBlock(pos, "loop_forever");
    this.maybeEmitJump(block.id, pos);

    oldContinueID = this.continueID;
    this.!continueID = block.id;

    // Emit the body.
    this.startBlock(block);
    this.emitStmt(context, body);
    this.maybeEmitJump(block.id, pos);

    this.!continueID = oldContinueID;
  }

  private mutable fun emitTypeSwitch(
    context: mutable SKStore.Context,
    switchExpr: I.Expr,
    branchList: List<I.TypeSwitchBranch>,
    defaultBody: ?I.Stmt,
  ): void {
    switchValue = this.emitExpr(context, switchExpr);
    pos = switchExpr.pos;

    // Create a "default" body if there isn't one already. TODO: What
    // exactly should it do? It's supposed to be impossible to match
    // so it's OK to die horribly, but how?
    default = defaultBody match {
    | Some(b) -> b
    | None() -> unreachableFrontEndStmt(pos)
    };

    // The first action is "default", the rest are for the cases.
    // Some of those are shared by fall-throughs.
    actions = mutable Vector[];
    actions.push(
      mutable SwitchAction(default, this.newBlock(pos, "type_switch_default")),
    );

    // Convert the branches list to array form.
    seen = UnorderedSet::mcreate(branchList.size());
    branchesBuf = mutable Vector<SwitchBranch<GClassName>>[];
    for (b in branchList) {
      // Only emit the body block at most once.
      madeBodyBlock = false;
      for (case in b.cases) {
        (casePos, caseValueLiteral) = case;

        // Extract the "case" value.
        caseValue = GClassName(caseValueLiteral.name.id);

        // If we see duplicate values (probably shouldn't happen?), drop the
        // later one as unreachable.
        // TODO: We can stop doing this, it will be optimized away later.
        if (seen.maybeInsert(caseValue)) {
          if (!madeBodyBlock) {
            !madeBodyBlock = true;

            casePrettyName =
              "type_switch_case_" +
              (if (b.cases.size() == 1) {
                // No fall-through, so use the case value to name the block.
                caseValue.idValue()
              } else {
                // Fall-throughs, so give up and just use the line number.
                getLineStr(casePos)
              });

            block = this.newBlock(casePos, casePrettyName);
            actions.push(mutable SwitchAction(b.action, block))
          };

          // Emit a case that jumps to the latest action.
          branchesBuf.push(SwitchBranch(caseValue, actions.size() - 1, casePos))
        }
      }
    };
    branches = branchesBuf.toArray();

    _ = this.emitInstr(
      GTypeSwitch{
        pos,
        value => switchValue,
        cases => branches.map(b -> b.value),
        successors => Array::fillBy(branches.size() + 1, i -> {
          actionIndex = if (i == 0) {
            0
          } else {
            branches[i - 1].actionIndex
          };
          actions[actionIndex].block.id
        }),
      },
    );

    joinBlock = this.newBlock(pos, "type_switch_join" + getLineStr(pos));

    // Emit the action blocks.
    for (action in actions) {
      this.startBlock(action.block);
      this.emitStmt(context, action.body);
      this.maybeEmitJump(joinBlock.id, action.block.pos)
    };

    this.startBlock(joinBlock)
  }

  private mutable fun emitIntSwitch(
    context: mutable SKStore.Context,
    switchValue: GInstr,
    branchList: List<I.SwitchBranch>,
    default: I.Stmt,
    pos: FileRange,
    charSwitch: Bool = false,
  ): void {
    // The first action is "default", the rest are for the cases.
    // Some of those are shared by fall-throughs.
    actions = mutable Vector[];
    actions.push(
      mutable SwitchAction(default, this.newBlock(pos, "switch_default")),
    );

    // Convert the branches list to array form.
    seen = UnorderedSet::mcreate(branchList.size());
    branchesBuf = mutable Vector<SwitchBranch<Int>>[];
    for (b in branchList) {
      madeBodyBlock = false;
      for (case in b.cases) {
        (casePos, caseValueLiteral) = case;

        // Extract an Int "case" value.
        caseValue = (caseValueLiteral, charSwitch) match {
        | (I.LChar(value), true)
        | (I.LInt(value), false) ->
          value
        | _ -> casePos.die("Wrong literal type")
        };

        // If we see duplicate values, drop the later one as unreachable.
        // This could happen when FloatSwitch adds -0.0 for 0.0, and maybe
        // from the front end (?)
        if (seen.maybeInsert(caseValue)) {
          if (!madeBodyBlock) {
            !madeBodyBlock = true;

            casePrettyName =
              "switch_case_" +
              (if (b.cases.size() == 1) {
                // No fall-through, so use the case value to name the block.
                caseValue.toString()
              } else {
                // Fall-throughs, so give up and just use the line number.
                getLineStr(casePos)
              });

            block = this.newBlock(casePos, casePrettyName);
            actions.push(mutable SwitchAction(b.action, block))
          };

          // Emit a case that jumps to the latest action.
          branchesBuf.push(SwitchBranch(caseValue, actions.size() - 1, casePos))
        }
      }
    };
    branches = branchesBuf.toArray();

    _ = this.emitInstr(
      GIntSwitch{
        pos,
        value => switchValue,
        cases => branches.map(b -> b.value),
        successors => Array::fillBy(branches.size() + 1, i -> {
          actionIndex = if (i == 0) {
            0
          } else {
            branches[i - 1].actionIndex
          };
          actions[actionIndex].block.id
        }),
      },
    );

    joinBlock = this.newBlock(pos, "switch_join" + getLineStr(pos));

    // Emit the action blocks.
    for (action in actions) {
      this.startBlock(action.block);
      this.emitStmt(context, action.body);
      this.maybeEmitJump(joinBlock.id, action.block.pos)
    };

    this.startBlock(joinBlock)
  }

  private mutable fun emitStringSwitch(
    context: mutable SKStore.Context,
    switchValue: GInstr,
    branchList: List<I.SwitchBranch>,
    default: I.Stmt,
    pos: FileRange,
  ): void {
    // The first action is "default", the rest are for the cases.
    // Some of those are shared by fall-throughs.
    actions = mutable Vector[];
    actions.push(
      mutable SwitchAction(default, this.newBlock(pos, "switch_default")),
    );

    // Convert the branches list to array form.
    seen = UnorderedSet::mcreate(branchList.size());
    branchesBuf = mutable Vector<SwitchBranch<UTF8String>>[];
    for (b in branchList) {
      madeBodyBlock = false;
      for (case in b.cases) {
        (casePos, caseValueLiteral) = case;

        // Extract the "case" value.
        caseValue = caseValueLiteral match {
        | I.LString(value) -> UTF8String::make(value)
        | _ -> casePos.die("Expected Int literal")
        };

        // If we see duplicate values, drop the later one as unreachable.
        // This could happen when FloatSwitch adds -0.0 for 0.0, and maybe
        // from the front end (?)
        if (seen.maybeInsert(caseValue)) {
          if (!madeBodyBlock) {
            !madeBodyBlock = true;

            casePrettyName =
              "switch_case_" +
              (if (b.cases.size() == 1) {
                // No fall-through, so use the case value to name the block.
                caseValue.toString()
              } else {
                // Fall-throughs, so give up and just use the line number.
                getLineStr(casePos)
              });

            block = this.newBlock(casePos, casePrettyName);
            actions.push(mutable SwitchAction(b.action, block))
          };

          // Emit a case that jumps to the latest action.
          branchesBuf.push(SwitchBranch(caseValue, actions.size() - 1, casePos))
        }
      }
    };
    branches = branchesBuf.toArray();

    _ = this.emitInstr(
      GStringSwitch{
        pos,
        value => switchValue,
        cases => branches.map(b -> this.constantString(b.value)),
        successors => Array::fillBy(branches.size() + 1, i -> {
          actionIndex = if (i == 0) {
            0
          } else {
            branches[i - 1].actionIndex
          };
          actions[actionIndex].block.id
        }),
      },
    );

    joinBlock = this.newBlock(pos, "switch_join" + getLineStr(pos));

    // Emit the action blocks.
    for (action in actions) {
      this.startBlock(action.block);
      this.emitStmt(context, action.body);
      this.maybeEmitJump(joinBlock.id, action.block.pos)
    };

    this.startBlock(joinBlock)
  }

  // We compile a Float switch as an IntSwitch on the raw IEEE FP bits.
  private mutable fun emitFloatSwitch(
    context: mutable SKStore.Context,
    switchValue: GInstr,
    branchList: List<I.SwitchBranch>,
    default: I.Stmt,
    pos: FileRange,
  ): void {
    zeroBits = (0.0).toBits();
    minusZeroBits = (-0.0).toBits();

    // Transform the Float cases into Int cases by using the raw IEEE bit
    // patterns. The tricky part is that 0.0 and -0.0 are equal but have
    // different bit patterns, so we need to expand any zero to both variants.
    intBranchList = branchList.map(b -> {
      intCases = mutable Vector[];

      for (case in b.cases) {
        (casePos, caseValueLiteral) = case;

        // Extract the "case" value.
        caseValue = caseValueLiteral match {
        | I.LFloat(value) -> value
        | _ -> casePos.die("Expected Float literal")
        };

        // NaNs are unmatchable via equality semantics, so ignore them here.
        if (!caseValue.isNaN()) {
          bits = caseValue.toBits();
          intCases.push((casePos, I.LInt(bits)));

          // 0.0 also matches -0.0 and vice versa.
          if (bits == zeroBits) {
            intCases.push((casePos, I.LInt(minusZeroBits)))
          } else if (bits == minusZeroBits) {
            intCases.push((casePos, I.LInt(zeroBits)))
          }
        }
      };

      I.SwitchBranch(List::createFromItems(intCases.toArray()), b.action)
    });

    bits = this.emitInstr(
      GCallMethod{
        typ => gtInt,
        pos,
        method => "toBits",
        args => Array[switchValue],
        source => gtFloat.generic,
      },
    );

    this.emitIntSwitch(context, bits, intBranchList, default, pos)
  }

  private mutable fun emitThrow(exc: GInstr, pos: FileRange): void {
    this.tryInfo match {
    | None() -> _ = this.emitInstr(GThrow{pos, exception => exc})
    | Some(tryInfo) ->
      // A "throw" inside a "try" becomes a jump to the catch block.
      this.setLocal(tryInfo.exceptionVariable, exc, pos);
      this.maybeEmitJump(tryInfo.catchMatch, pos)
    };

    // Start a dummy block just so any following instructions have
    // somewhere to go. This block will be discarded.
    this.startBlock(this.newBlock(pos, "unreachable"))
  }

  mutable fun emitTry(
    context: mutable SKStore.Context,
    body: I.Stmt,
    emitCatchMatch: () -> void,
    excBinding: I.Binding,
    pos: FileRange,
  ): void {
    // Declare an internal local variable to hold the exception.
    // We don't use the user's excBinding since it may be
    // declared as not being reassigned, but we can reassign
    // when a throw appears lexically inside a try.
    excVar = excBinding.name.id;
    excType = this.convertType(context, excBinding.ty);
    tmpExcVar = "tmp:exc:" + excVar;
    this.emitBind(
      tmpExcVar,
      excType,
      this.constantZero(excType),
      SkipOuterIstUtils.nonconst_binding_info,
      pos,
    );

    lineStr = getLineStr(pos);

    llvmLandingPad = this.newBlock(pos, "rawcatch_" + lineStr);
    recordExc = this.newBlock(pos, "record_exc_" + lineStr);
    catchMatchBlock = this.newBlock(pos, "catch_" + lineStr);
    afterTry = this.newBlock(pos, "after_try_" + lineStr);

    this.!nextTryID = this.nextTryID + 1;

    // Compile the body inside the "try".
    oldTryInfo = this.tryInfo;
    this.!tryInfo = Some(
      TryInfo{
        llvmLandingPad => llvmLandingPad.id,
        catchMatch => catchMatchBlock.id,
        exceptionVariable => tmpExcVar,
      },
    );
    this.emitStmt(context, body);
    this.!tryInfo = oldTryInfo;

    this.maybeEmitJump(afterTry.id, pos);

    // Compile the low-level block catching the raw exception.
    this.startBlock(llvmLandingPad);
    landingPadInstr = this.emitInstr(
      GLandingPad{pos, successors => Array[recordExc.id]},
    );

    // Create a block that can stash the LandingPad in tmpExcVar.
    this.startBlock(recordExc);
    this.setLocal(tmpExcVar, landingPadInstr, pos);
    this.maybeEmitJump(catchMatchBlock.id, pos);

    // Compile the high-level block doing the catches.
    this.startBlock(catchMatchBlock);

    // Declare the user's exception variable.
    this.emitBind(
      excVar,
      excType,
      this.getLocal(tmpExcVar, pos),
      excBinding.info,
      pos,
    );

    emitCatchMatch();

    this.maybeEmitJump(afterTry.id, pos);

    this.startBlock(afterTry)
  }

  mutable fun maybeEmitJump(target: GBlockID, pos: FileRange): void {
    if (this.blockActive) {
      _ = this.emitInstr(GJump{pos, successors => Array[target]})
    }
  }

  private mutable fun emitBind(
    name: String,
    typ: GType,
    value: GInstr,
    info: I.BindingInfo,
    pos: FileRange,
  ): void {
    this.locals.maybeGet(name) match {
    | Some _ -> pos.die("Encountered multiple Binds of " + name)
    | None() ->
      bind = if (typ == gtVoid) {
        (this.constantVoid(), false)
      } else if (!info.updated) {
        (value, false)
      } else {
        // Allocate a Localvalue to hold the variable's value.

        // TODO: It would be more efficient to have closures simply
        // point into a single object containing all captured
        // variables, rather than having to set up a separate LocalVariable for
        // every capture-by-reference variable. But if we allow non-downward
        // lambdas we would still want to split them up to avoid excessive
        // GC lifetimes for these LocalVariable.

        refType = GTapply(kLocalVarType, Mutable(), Array[typ]);

        ref = this.emitInstr(
          GObject{
            typ => refType,
            pos,
            args => Array[value],
            // Allow LocalVariable<_> for _ local variables, which crop up
            // occasionally but are not used in a problematic way
            // (T24439354, T25366751). Delete once T25379806 is fixed.
            forceCanInstantiate => true,
            prettyName => name,
          },
        );

        (ref, true)
      };

      this.locals.set(name, bind)
    }
  }

  mutable fun emitReturn(value: GInstr, pos: FileRange): void {
    returningValue = this.lazy.returnTempType() != gtVoid;
    if (returningValue) {
      this.setLocal(kImplicitReturnVariableName, value, pos);
    };

    if (this.exitBlockID != GBlockID::none) {
      this.maybeEmitJump(this.exitBlockID, pos)
    } else {
      // This is the first Return we have processed, create the exit block.
      exitBlock = this.newBlock(pos, "exit");
      this.!exitBlockID = exitBlock.id;

      this.maybeEmitJump(exitBlock.id, pos);

      this.startBlock(exitBlock);

      logicalReturnValue = if (returningValue) {
        this.getLocal(kImplicitReturnVariableName, pos)
      } else {
        this.constantVoid()
      };

      this.lazy.emitReturn(this, logicalReturnValue, pos)
    }
  }

  // From within a generator, figure out the type of values being
  // "yielded", then wrap it in the given generic and mutability.
  private mutable fun generatorOptionType(
    context: mutable SKStore.Context,
    generic: String,
    mutability: Mutability,
  ): GType {
    // We are inside the "ramp up" function that creates the Generator instance.
    // The return type holds the specific subclass of Iterator we produce.
    // Fetch its "next" method's return type, which should be
    // readonly Option<XX>.
    pos = this.pos;
    ta = this.funInfo.funType.returnType.asGTapply(pos);
    gc = this.converter.getGClass(context, ta.generic, pos);
    method = gc.methods["next"];
    opt = this.converter.getGFunction(
      context,
      method.function.fromSome("No next method found")(context, ta.generic),
    ).funInfo.funType.returnType;

    targs = opt match {
    | GTapply(FrontEndLazyGClass("Option"), _, targs) if (targs.size() == 1) ->
      targs
    | t -> pos.die(`Expected next method to return Option, not ${t}`)
    };
    GTapply(FrontEndLazyGClass(generic), mutability, targs)
  }

  private mutable fun generatorNone(
    context: mutable SKStore.Context,
    pos: FileRange,
  ): GInstr {
    this.emitInstr(
      GObject{
        typ => this.generatorOptionType(context, "None", DeepFrozen()),
        pos,
        args => Array[],
      },
    )
  }

  private mutable fun emitYield(
    context: mutable SKStore.Context,
    value: GInstr,
    pos: FileRange,
  ): void {
    // Yield always yields Some(x), to make it easier for later compilation
    // stages to eventually turn this into a Return of that value, to
    // match with the Iterator::next return type.
    some = this.emitInstr(
      GObject{
        typ => this.generatorOptionType(context, "Some", Readonly()),
        pos,
        args => Array[value],
      },
    );
    none = this.generatorNone(context, pos);
    _ = this.emitInstr(GYield{pos, value => some, none})
  }

  private mutable fun emitYieldBreak(
    context: mutable SKStore.Context,
    pos: FileRange,
  ): void {
    // Compute the proper None() type here, to make it easier to access later.
    none = this.generatorNone(context, pos);
    _ = this.emitInstr(GYieldBreak{pos, none})
  }

  mutable fun emitStmt(context: mutable SKStore.Context, stmt: I.Stmt): void {
    stmt match {
    | I.JumpTo(name) -> this.emitJumpTo(name)
    | I.JumpBlock(entries, _) -> this.emitJumpBlock(context, entries)
    | I.SingleExpr(e) -> _ = this.emitExpr(context, e)
    | I.Bind(var, expr_opt) ->
      (pos, name) = (var.name.pos, var.name.id);

      typ = this.convertType(context, var.ty);
      value = expr_opt match {
      | Some(expr) -> this.emitExpr(context, expr)
      | None() -> this.constantZero(typ)
      };

      this.emitBind(name, typ, value, var.info, pos)
    | I.Assign(var, expr) ->
      this.setLocal(var.name.id, this.emitExpr(context, expr), expr.pos)
    | I.AssignField(
      I.LocalVar(varType, varName),
      _,
      I.Name(pos, field),
      expr,
    ) ->
      obj = this.emitExpr(context, I.Expr(varType, pos, I.Local(varName)));
      value = this.emitExpr(context, expr);

      _ = this.emitInstr(GSetField{pos, obj, field, value})
    | I.Seq(stmts) -> for (stmt2 in stmts) this.emitStmt(context, stmt2)
    | I.If(e, t, f) ->
      pos = e.pos;
      this.emitIf(context, this.emitExpr(context, e), t, f, pos)
    | I.LoopForever(pos, body) -> this.emitLoopForever(context, pos, body)
    | I.Match(expr, _branches) -> expr.pos.die("Match should have been lowered")
    | I.Switch(expr, branches, default) ->
      pos = expr.pos;
      val = this.emitExpr(context, expr);

      if (branches.isEmpty()) {
        pos.die("Trivial match should have been lowered away earlier.")
      };

      // Currently only Bool matches can be exhaustive (because
      // other types have vastly more values), and those get lowered
      // to "if" before we get here.
      defaultBody = default match {
      | Some(d) -> d
      | None() ->
        pos.die(
          val.getType().toString() +
            " match is missing a default clause but is not exhaustive.",
        )
      };

      val.getType() match {
      | t if (t == gtInt) ->
        this.emitIntSwitch(context, val, branches, defaultBody, pos)
      | t if (t == gtChar) ->
        // Widen to "Int" and use IntSwitch.
        wide = this.emitInstr(GZeroExtend{typ => gtInt, pos, value => val});
        this.emitIntSwitch(context, wide, branches, defaultBody, pos, true)
      | t if (t == gtString) ->
        this.emitStringSwitch(context, val, branches, defaultBody, pos)
      | t if (t == gtFloat) ->
        this.emitFloatSwitch(context, val, branches, defaultBody, pos)
      | t if (t == gtBool) ->
        pos.die("Bool match should have been lowered to 'if' already.")
      | t -> pos.die("Switch not handled on type " + t)
      }
    | I.TypeSwitch(expr, branches, default) ->
      this.emitTypeSwitch(context, expr, branches, default)
    | I.Return(expr) ->
      pos = expr.pos;
      value = this.emitExpr(context, expr);
      this.emitReturn(value, pos)
    | I.Try _ -> this.funInfo.die("Try should have been lowered")
    | I.TryCatch(pos, body, excBinding, catchMatch) ->
      this.emitTry(
        context,
        body,
        () -> this.emitStmt(context, catchMatch),
        excBinding,
        pos,
      )
    | I.Throw(e) -> this.emitThrow(this.emitExpr(context, e), e.pos)
    | I.Yield(e) -> this.emitYield(context, this.emitExpr(context, e), e.pos)
    | I.YieldBreak(pos) -> this.emitYieldBreak(context, pos)
    }
  }
}

// Creates a unique mapping from Array<Tclass> to Int.
mutable private base class SuperpositionInterner<T>(
  protected map: mutable UnorderedMap<
    Array<Tclass>,
    Int,
  > = mutable UnorderedMap[],
  keys: mutable Vector<Array<Tclass>> = mutable Vector[],
) {
  protected mutable fun getInt(tclasses: Array<Tclass>): Int {
    this.map.getOrAdd(tclasses, () -> {
      this.keys.push(tclasses);
      this.keys.size() - 1
    })
  }

  readonly fun computeNames(): Array<String> {
    Array::fillBy(this.keys.size(), i -> {
      v = this.keys[i];
      if (v.isEmpty()) {
        ""
      } else {
        "<" + v.join(", ") + ">"
      }
    })
  }
}

private const kEmptyMethods: UnorderedMap<
  MethodKey,
  SFunctionID,
> = UnorderedMap[];

private fun makeOuterIst(context: mutable SKStore.Context): OuterIst.Program {
  // run the compiler front end from parsing to type checking
  typedAst = SkipMain.type_program(context);
  // OuterIst skeleton is built here, but code is done lazily
  SkipMakeOuterIst.program(context, typedAst)
}

class ConstFile(value: OuterIstToIR.ConstLazyGFun) extends SKStore.File
class ConstsArrayFile(
  value: Array<OuterIstToIR.ConstLazyGFun>,
) extends SKStore.File

const constsArrayDirName: SKStore.DirName = SKStore.DirName::create(
  "/constsArray/",
);
const constsArrayDir: SKStore.EHandle<
  SKStore.SID,
  ConstsArrayFile,
> = SKStore.EHandle(
  SKStore.SID::keyType,
  ConstsArrayFile::type,
  constsArrayDirName,
);

fun createIR(
  context: mutable SKStore.Context,
  config: Config.Config,
  shouldDisasm: (I.FunDef ~> Bool),
  shouldRuntimeExport: (I.FunDef ~> Bool),
  outerIst: I.Program,
  converter: Converter,
  constsProj: SKStore.EHandle<SKStore.UnitID, I.ConstDefFile>,
  funDefsProj: SKStore.EHandle<SKStore.UnitID, I.FunDefFile>,
): GlobalEnv {
  consts = converter.getConsts(context, constsProj);
  funDefs = outerIst.getFuns(context, funDefsProj);

  forceCompile = mutable Vector<LazyGFun>[];
  disasm = mutable UnorderedSet[];

  for (c in consts) {
    forceCompile.push(c)
  };

  runtimeFunctions = mutable Vector[];

  for (funDef in funDefs) {
    pos = funDef.name.pos;
    name = funDef.name.id;
    annotations = funDef.annotations;

    isParametric = !funDef.tparams.isEmpty();

    // Should we forcibly create a Function for this, even if it appears unused?
    force = (None() : ?LazyGFun);

    // TODO: If the user explicitly requests we disassemble a specific
    // function, and either (1) we can't find it at all or (2) it's
    // parametric and we happen to need no instantiations, perhaps we
    // should complain.
    //
    // In some cases the tool requesting the disassembly could complain
    // based on the JSON it receives.
    if (shouldDisasm(funDef)) {
      disasm.insert(name);
      !force = Some(FrontEndLazyGFun{frontEndName => name})
    };

    if (
      (shouldRuntimeExport(funDef) &&
        annotationsContainParam(annotations, "@cpp_extern", pos).isNone() &&
        annotationsContainParam(annotations, "@cpp_runtime", pos).isNone())
    ) {
      if (isParametric) {
        pos.die(
          `Cannot export function ${name} because it takes type parameters.`,
        )
      };
      !force = Some(FrontEndLazyGFun{frontEndName => name})
    };

    // Guarantee we create Functions for all native runtime functions,
    // so later stages of the compiler can look them up by name even
    // if they aren't obviously used until later (e.g. lowering). Since
    // they are native, they have no implementation so this is cheap.
    if (
      funDef.native_.isSome() &&
      !isParametric &&
      annotationsContainParam(annotations, "@cpp_runtime", pos).isSome()
    ) {
      runtimeFunctions.push(FrontEndLazyGFun{frontEndName => name});
      !force = Some(FrontEndLazyGFun{frontEndName => name})
    };

    force match {
    | Some(fn) -> forceCompile.push(fn)
    | None() -> void
    }
  };

  reportMemoryStatistics("native/createIR after convert functions");

  // Export request functions outside of Skip.
  if (forceCompile.isEmpty()) {
    invariant_violation("Failed to find any functions to compile.")
  };

  reportMemoryStatistics("native/createIR after specialize");

  reportMemoryStatistics("native/createIR after force compile constant inits");

  // Find every relevant type and function in the program.
  specializer = Specializer::make(context, config, converter);

  for (gid in forceCompile) {
    _ = specializer.requestFunction(context, gid, Array[])
  };

  specializer.findAllFunctionsAndSClasses(context);

  reportMemoryStatistics("native/createIR after findAllFunctionsAndSClasses");

  // Latch the sub- and supertypes.
  for (info in specializer.untrackedSClasses()) {
    !info.sclass = info.sclass with {
      subtypes => info.subtypes,
      supertypes => info.supertypes,
    };
    specializer.untrackedSClassSet(info.sclass.id, info);
  };
  reportMemoryStatistics("native/createIR after latch sub/super");

  // Flatten value class fields into scalars.
  specializer.scalarizeAllFields(specializer.sclasses.items().map(x -> x.i1));
  reportMemoryStatistics("native/createIR after scalarizeAllFields");

  specializer.withRegion(context, (_context, specializer) ~> {
    // Choose offsets for every field.
    FieldLayoutChooser::run(specializer, config);
    reportMemoryStatistics("native/createIR after FieldLayoutChooser");
  });

  // Split up functions based on which ones can share machine code.
  sclasses = specializer.createNewSClassesMap();
  env = GlobalEnv::make(sclasses);
  !env = specializer.partitionFunctions(
    context,
    runtimeFunctions,
    env,
    config,
    consts,
    disasm,
  );

  reportMemoryStatistics("native/createIR end");

  env
}

module end;
