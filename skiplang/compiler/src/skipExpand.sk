/**
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

/*****************************************************************************/
/* Module Expansion.
 *
 * This pass does a series of code transformations "expanding" names and
 * definitions.
 *
 * It actually does two passes: one to collect all definitions into modules,
 * and one where it resolves names and fully qualifies all modules.
 *
 * In the first pass, we collect definitions into modules and expand any
 * classes created by the "children" keyword. For example:
 *
 *    >  base class X {
 *    >     children = Y | Z
 *    >  }
 *
 *    Is transformed into:
 *    >  base class X {} // The children field has been removed
 *    >
 *    >  class Y extends X // Y is now defined outside of X
 *    >                    // (and extends it explicitly)
 *    >  class Z extends X
 *
 * In the second pass, we expand modules. For every definition within a
 * module, the module's name is "pushed" on its definitions. For example:
 *
 *    > module M;
 *    > class X
 *
 * Becomes:
 *    > class M.X
 *
 * We also expand module aliases. For example:
 *    > module alias MLN = MyLongName
 * Then MLN is replaced with MyLongName across the entire module.
 *
 * As a special case, naming a class "." in a module MyModule
 * renames the class to by MyModule in the global scope.
 *
 * Here we also resolve named references to type parameters. The bulk
 * of name resolution is done in SkipNaming, but because type parameters
 * are lexically scoped, it's important to resolve references to them
 * before we begin to move definitions around, as in Skip Inherit.
 *
 */
/*****************************************************************************/
/*****************************************************************************/
/* The environment. */
/*****************************************************************************/
module alias A = SkipAst;

/*****************************************************************************/
/* For every class, computes the transitive closure of the children of that
 * class (and adds it to the field children__set).
 */
/*****************************************************************************/
module ChildMap;

const childDirName: SKStore.DirName = SKStore.DirName::create("/childCache/");

fun getChildren(
  context: mutable SKStore.Context,
  childDir: SKStore.EHandle<SKStore.SID, SKStore.StringFile>,
  className: String,
): SSet {
  childDir
    .getArray(context, SKStore.SID(className))
    .map(x -> x.value)
    .foldl(
      (result, child) ->
        getChildren(context, childDir, child).set(child).union(result),
      SSet[],
    )
}

fun populateCache(
  context: mutable SKStore.Context,
  defsDir: SKStore.EHandle<SKStore.SID, SkipExpand.DefsFile>,
): SKStore.EHandle<SKStore.SID, SKStore.StringFile> {
  defsDir.map(
    SKStore.SID::keyType,
    SKStore.StringFile::type,
    context,
    childDirName,
    (context, writer, _key, defsFiles) ~> {
      SkipError.catchErrors(1, context, () -> {
        map = mutable Map[];
        defs = defsFiles.assertUnique().value.i1;
        for (classDef in defs.class_defs) {
          (_fileRange, childStr) = classDef.name;
          for (classExtends in classDef.extends_) {
            (parentClass, _) = classExtends.parent;
            parentStr = parentClass match {
            | A.Tclass((_, x)) -> x
            | _ -> invariant_violation("The name should have been expanded")
            };
            if (!map.containsKey(parentStr)) {
              map![parentStr] = mutable Vector[];
            };
            map[parentStr].push(SKStore.StringFile(childStr));
          }
        };
        for (parentStr => childVec in map) {
          writer.setArray(SKStore.SID(parentStr), childVec.toArray());
        }
      })
    },
  );
}

private fun isConcreteClass(defs: UMap<A.Class_def>, c: String): Bool {
  defs.getOrCrash(c).kind is A.KClass()
}

fun checkCycles(
  context: mutable SKStore.Context,
  defs: SKStore.EHandle<SKStore.SID, GlobalEnv.ExpandedDefFile>,
): void {
  _ = defs.map(
    SKStore.SID::keyType,
    SKStore.StringFile::type,
    context,
    SKStore.DirName::create("/checkCycle/"),
    (context, _writer, _key, defFiles) ~> {
      SkipError.catchErrors(1, context, () -> {
        for (defFile in defFiles) {
          defFile.value match {
          | GlobalEnv.EClass(classDef) ->
            checkCycle(context, SSet[], defs, classDef)
          | _ -> void
          }
        }
      })
    },
  )
}

// Basic check for explicit cycle in a hierarchy. Does not consider
// implicit cycles due to subtyping
private fun checkCycle(
  context: mutable SKStore.Context,
  visited: SSet,
  classDefs: SKStore.EHandle<SKStore.SID, GlobalEnv.ExpandedDefFile>,
  classDef: A.Class_def,
): void {
  (classNamePos, className) = classDef.name;
  if (visited.contains(className)) {
    SkipError.error(classNamePos, "Cyclic class hierarchy")
  };
  !visited = visited.add(className);
  for (parent in classDef.extends_) {
    (parentClassName, _) = parent.parent;
    (parentPos, parentName) = parentClassName match {
    | A.Tclass(x) -> x
    | _ -> invariant_violation("The name should have been expanded")
    };
    parentClass = GlobalEnv.getClass(context, parentName) match {
    | None() ->
      SkipError.error(
        parentPos,
        "Unbound class name for parent '" + parentName + "'",
      )
    | Some(x) -> x
    };
    checkCycle(context, visited, classDefs, parentClass)
  }
}

module end;

module ModuleMap;

const moduleDirName1: SKStore.DirName = SKStore.DirName::create(
  "/moduleCache1/",
);
const moduleDirName: SKStore.DirName = SKStore.DirName::create("/moduleCache/");
const moduleDir: SKStore.EHandle<
  SKStore.SID,
  SKStore.ArrayStringFile,
> = SKStore.EHandle(
  SKStore.SID::keyType,
  SKStore.ArrayStringFile::type,
  moduleDirName,
);

fun containsKey(context: mutable SKStore.Context, key: String): Bool {
  moduleDir.getArray(context, SKStore.SID(key)).size() > 0
}

fun populateCache(
  context: mutable SKStore.Context,
  moduleDefs: SKStore.EHandle<SKStore.SID, SkipExpand.DefsFile>,
): void {
  moduleDirName1 = moduleDefs.map(
    SKStore.SID::keyType,
    SKStore.StringFile::type,
    context,
    moduleDirName1,
    (context, writer, key, values) ~> {
      SkipError.catchErrors(1, context, () -> {
        moduleName = key match {
        | SKStore.SID(x) -> x
        };
        SkipExpand.checkConflicts(values.first.value);
        defMap = mutable Map[];
        pushDef = (prefix, moduleName, defName) -> {
          if (defName.startsWith(".")) {
            !moduleName = "U";
            !defName = defName.getIter().forward(1).collectString();
          };
          !defName = prefix + defName;
          if (!defMap.containsKey(moduleName)) {
            defMap![moduleName] = SortedSet[];
          };
          defMap![moduleName] = defMap[moduleName].set(defName);
        };
        (_, defs) = values.first.value;

        for (cd in defs.class_defs) {
          (_fileRange, defName) = cd.name;
          pushDef("class:", moduleName, defName);
        };
        for (fd in defs.fun_defs) {
          (_fileRange, defName) = fd.name;
          pushDef("fun:", moduleName, defName);
        };
        for (cst in defs.const_defs) {
          (_fileRange, defName) = cst.name;
          pushDef("const:", moduleName, defName);
        };
        for (tyd in defs.type_defs) {
          (_fileRange, defName) = tyd.name;
          pushDef("type:", moduleName, defName);
        };
        for (defModuleName => defSet in defMap) {
          writer.setArray(
            SKStore.SID(defModuleName),
            defSet.collect(Array).map(x -> SKStore.StringFile(x)),
          );
        }
      })
    },
  );
  _ = moduleDirName1.map(
    SKStore.SID::keyType,
    SKStore.ArrayStringFile::type,
    context,
    moduleDirName,
    (context, writer, key, iter) ~> {
      SkipError.catchErrors(1, context, () -> {
        writer.set(
          key,
          SKStore.ArrayStringFile(
            iter.nonEmptyMap(x -> x.value).toArray().sorted(),
          ),
        );
      })
    },
  )
}

module end;

module GlobalEnv;

const defMapDirName1: SKStore.DirName = SKStore.DirName::create("/defMap1/");
const defMapDirName: SKStore.DirName = SKStore.DirName::create("/defMap/");
const defMapDir: SKStore.EHandle<
  SKStore.SID,
  ExpandedDefFile,
> = SKStore.EHandle(SKStore.SID::keyType, ExpandedDefFile::type, defMapDirName);

class ProgramFile(value: A.Program) extends SKStore.File

class ExpandedDefFile(value: ExpandedDef) extends SKStore.File

base class ExpandedDef {
  children =
  | EClass(A.Class_def)
  | EType(A.Type_alias_def)
  | EConst(A.Const_def)
  | EFun(A.Fun_def)
}

fun populateDefinitions(
  context: mutable SKStore.Context,
  expandedDefsDir: SKStore.EHandle<SKStore.SID, SkipExpand.DefsFile>,
): SKStore.EHandle<SKStore.SID, ExpandedDefFile> {
  phase1 = expandedDefsDir.map(
    SKStore.SID::keyType,
    ExpandedDefFile::type,
    context,
    defMapDirName1,
    (context, writer, _key, defsFiles) ~> {
      SkipError.catchErrors(1, context, () -> {
        defs = defsFiles.assertUnique().value.i1;
        for (classDef in defs.class_defs) {
          expandedDefFile = ExpandedDefFile(EClass(classDef));
          writer.set(SKStore.SID("class:" + classDef.name.i1), expandedDefFile);
        };
        for (typeDef in defs.type_defs) {
          expandedDefFile = ExpandedDefFile(EType(typeDef));
          writer.set(SKStore.SID("type:" + typeDef.name.i1), expandedDefFile)
        };
        for (constDef in defs.const_defs) {
          expandedDefFile = ExpandedDefFile(EConst(constDef));
          writer.set(SKStore.SID("const:" + constDef.name.i1), expandedDefFile)
        };
        for (funDef in defs.fun_defs) {
          expandedDefFile = ExpandedDefFile(EFun(funDef));
          writer.set(SKStore.SID("fun:" + funDef.name.i1), expandedDefFile)
        };
      })
    },
  );
  phase1.map(
    SKStore.SID::keyType,
    ExpandedDefFile::type,
    context,
    defMapDirName,
    (context, writer, key, defFiles) ~> {
      SkipError.catchErrors(1, context, () -> {
        name = key match {
        | SKStore.SID(x) -> x
        };
        defFilesArray = defFiles.toArray();
        if (name.startsWith("class:")) {
          roots = mutable Vector[];
          exts = mutable Vector[];
          for (cd in defFilesArray) {
            cd.value match {
            | EClass(c) ->
              if (c.extension is None()) {
                roots.push(c)
              } else {
                exts.push(c)
              }
            | _ ->
              invariant_violation(
                "All values associated with a key class: should be classes",
              )
            }
          };

          if (roots.size() == 0) {
            writer.setArray(key, defFilesArray);
            SkipError.error(
              exts[0].name.i0,
              "Undefined class " + exts[0].name.i1,
            );
          } else if (roots.size() > 1) {
            writer.setArray(
              key,
              roots.map(x -> ExpandedDefFile(EClass(x))).toArray(),
            );
            SkipError.errorl(
              List[
                (
                  roots[0].name.i0,
                  "Multiple definitions for class " + roots[0].name.i1,
                ),
                (
                  roots[1].name.i0,
                  "Previous definition was here " + roots[1].name.i1,
                ),
              ],
            );
          };
          root = roots[0];

          for (c in exts) {
            invariant(c.extension is Some _);
            !root = SkipExpand.merge_class(root, c)
          };
          writer.set(key, ExpandedDefFile(EClass(root)))
        } else {
          writer.setArray(key, defFilesArray)
        }
      })
    },
  );
}

fun getClass(
  context: mutable SKStore.Context,
  className: String,
): ?A.Class_def {
  arr = defMapDir.getArray(context, SKStore.SID("class:" + className));
  if (arr.size() == 0) return None();
  if (arr.size() > 1) invariant_violation("TODO multiple classes");
  Some(
    arr[0].value match {
    | EClass(x) -> x
    | _ -> invariant_violation("Unexpected object type")
    },
  )
}

fun getType(
  context: mutable SKStore.Context,
  typeName: String,
): ?A.Type_alias_def {
  arr = defMapDir.getArray(context, SKStore.SID("type:" + typeName));
  if (arr.size() == 0) return None();
  if (arr.size() > 1) invariant_violation("TODO multiple type");
  Some(
    arr[0].value match {
    | EType(x) -> x
    | _ -> invariant_violation("Unexpected object type")
    },
  )
}

fun getConst(
  context: mutable SKStore.Context,
  constName: String,
): ?A.Const_def {
  arr = defMapDir.getArray(context, SKStore.SID("const:" + constName));
  if (arr.size() == 0) return None();
  if (arr.size() > 1) invariant_violation("TODO multiple consts");
  Some(
    arr[0].value match {
    | EConst(x) -> x
    | _ -> invariant_violation("Unexpected object type")
    },
  )
}

module end;

/* The module doing the module name expansions. */

module SkipExpand;

base class Module_ uses Equality, Show {
  children =
  | Unqualified()
  | Module(A.Name)

  fun ==(other: Module_): Bool
  | Unqualified() ->
    other match {
    | Unqualified() -> true
    | _ -> false
    }
  | Module(thisName) ->
    other match {
    | Module(otherName) -> thisName.i1 == otherName.i1
    | _ -> false
    }

  fun toString(): String
  | Unqualified() -> ""
  | Module(module_name) ->
    (_, x) = module_name;
    x
}

class Defs{
  class_defs: UMap<A.Class_def>,
  const_defs: UMap<A.Const_def>,
  def_pos: ?FileRange,
  fun_defs: UMap<A.Fun_def>,
  type_defs: UMap<A.Type_alias_def>,
} {
  fun toProgram(): A.Program {
    A.Program{
      class_defs => this.class_defs,
      const_defs => this.const_defs,
      fun_defs => this.fun_defs,
      type_defs => this.type_defs,
    }
  }
}

class DefNames(defs: Array<String>) {
  private fun binarySearch(elt: String, i: Int, j: Int): Bool {
    if (i > j) return false;
    pivot = i + (j - i) / 2;
    compare(elt, this.defs[pivot]) match {
    | LT() -> this.binarySearch(elt, i, pivot - 1)
    | GT() -> this.binarySearch(elt, pivot + 1, j)
    | EQ() -> true
    }
  }

  fun containsClass(className: String): Bool {
    this.binarySearch("class:" + className, 0, this.defs.size() - 1)
  }
  fun containsFun(funName: String): Bool {
    this.binarySearch("fun:" + funName, 0, this.defs.size() - 1)
  }
  fun containsConst(constName: String): Bool {
    this.binarySearch("const:" + constName, 0, this.defs.size() - 1)
  }
  fun containsType(typeName: String): Bool {
    this.binarySearch("type:" + typeName, 0, this.defs.size() - 1)
  }

  fun names(): Array<String> {
    this.defs.map(x -> x.split(":")[1])
  }
}

type Module_map_t = SMap<(?FileRange, Defs)>;
class ModuleMapFile(value: Module_map_t) extends SKStore.File

fun name_of_module(x: Module_): String {
  x match {
  | Unqualified() -> "U"
  | Module(n) -> "Z" + n.i1
  }
}

fun module_names_find(context: mutable SKStore.Context, x: Module_): ?DefNames {
  // TODO: this should return none when the module is not defined
  mresult = ModuleMap.moduleDir.getArray(
    context,
    SKStore.SID(name_of_module(x)),
  );
  Some(DefNames(if (mresult.size() == 0) Array[] else mresult[0].value))
}

fun module_map_find(x: Module_, y: Module_map_t): ?Defs {
  y.maybeGet(name_of_module(x)).map(p -> p.i1)
}

fun module_names_find_unsafe(
  context: mutable SKStore.Context,
  x: Module_,
): DefNames {
  module_names_find(context, x) match {
  | None() -> invariant_violation("ICE unbound module")
  | Some(value) -> value
  }
}

fun module_names_mem(context: mutable SKStore.Context, x: Module_): Bool {
  ModuleMap.containsKey(context, name_of_module(x))
}

fun module_map_fold(
  context: mutable SKStore.Context,
  moduleMap: Module_map_t,
): A.Program {
  env = makeEnv();
  emptyProgram = A.Program{
    const_defs => UMap[],
    type_defs => UMap[],
    fun_defs => UMap[],
    class_defs => UMap[],
  };
  moduleMap
    .map((x, y) -> module_expand(context, env, x, y).i1)
    .reduce((y, _, x) -> mergePrograms(x.toProgram(), y), emptyProgram)
}

fun checkConflicts(posDefs: (?FileRange, Defs)): void {
  prog2 = posDefs.i1.toProgram();
  acc = A.Program{
    const_defs => UMap[],
    type_defs => UMap[],
    fun_defs => UMap[],
    class_defs => UMap[],
  };
  prog2.type_defs.each((_, type_def) ->
    !acc = add_tyd_to_acc(type_def.name, type_def, acc)
  );
  prog2.class_defs.each((_, class_def) ->
    !acc = add_cd_to_acc(class_def.name, class_def, acc)
  );
  prog2.fun_defs.each((_, fun_def) ->
    !acc = add_fun_to_acc(fun_def.name, fun_def, acc)
  );
  prog2.const_defs.each((_, const_def) -> {
    !acc = add_con_to_acc(const_def.name, const_def, acc)
  });
  void
}

fun module_expand(
  context: mutable SKStore.Context,
  env: Env,
  moduleName: String,
  posDefs: (?FileRange, Defs),
): (?FileRange, Defs) {
  (pos_opt, defs) = posDefs;
  module_name = {
    kind = moduleName.take(1);
    if (kind == "U") {
      Unqualified()
    } else {
      pos_opt match {
      | None() -> invariant_violation("ICE no pos for module_expand")
      | Some(pos) ->
        Module((pos, moduleName.getIter().forward(1).collectString()))
      }
    }
  };
  (posDefs.i0, module_(context, env, module_name, defs))
}

fun module_map_add(x: Module_, y: Defs, m: Module_map_t): Module_map_t {
  x match {
  | Unqualified() -> m.set(name_of_module(x), (None(), y))
  | Module((pos, _)) -> m.set(name_of_module(x), (Some(pos), y))
  }
}

class Env{
  context_name: String,
  current_module: Module_,
  locals: SSet,
  module_aliases: UMap<A.Module_alias>,
  tparams: SMap<A.Type_parameter>,
  allowMacros: Bool,
}

fun empty_defs(mod_name: Module_): Defs {
  def_pos = {
    mod_name match {
    | Unqualified() -> None()
    | Module((pos, _)) -> Some(pos)
    }
  };
  Defs{
    def_pos,
    type_defs => UMap[],
    class_defs => UMap[],
    fun_defs => UMap[],
    const_defs => UMap[],
  }
}

fun empty_defs_names(): DefNames {
  DefNames(Array[])
}

fun makeEnv(): Env {
  Env{
    context_name => "",
    current_module => Unqualified(),
    locals => SSet[],
    module_aliases => UMap[],
    tparams => SortedMap[],
    allowMacros => false,
  }
}

// state for iterative expr()
class ExprState{
  env: Env,
  stack: List<(A.Expr, Bool)>,
  expr: A.Expr,
  child: Bool,
}

/*****************************************************************************/
/* Function expanding module names. */
/*****************************************************************************/
fun is_uppercase(nm: A.Name): Bool {
  (_, name) = nm;
  name.isEmpty() || name.getIter().next().test(Chars.isUpperCaseLetter)
}

fun expand_module_name<Ta>(_env: Ta, mod_name: A.Name): Module_ {
  assert(is_uppercase(mod_name));
  mod_name match {
  | (_pos, "") -> Unqualified()
  | n -> Module(n)
  }
}

/* Core expansion behavior
 * Given an encasing module/global-namespace, it produces the resolved name
 * For example
 *  (M, "name") => "M.name"
 *  (Unqualified, "name") => "name"
 *  (M, ".name") -> "name"
 */
fun make_qualified_name(
  pos: FileRange,
  module_: Module_,
  name: (FileRange, String),
): (FileRange, String) {
  (_, str) = name;
  dotted_name = str.startsWith(".");
  (module_, name) match {
  | (Module((_, _)), _) if (dotted_name) ->
    (pos, str.getIter().forward(1).collectString())
  | (Unqualified(), _) if (dotted_name) ->
    SkipError.error(
      pos,
      "You can only use '.' to access the global namespace while within a module",
    )
  | (Module((_, m)), _) -> (pos, m + "." + str)
  | (Unqualified(), _) -> name
  }
}

fun make_definition_name(
  env: Env,
  name: (FileRange, String),
): (FileRange, String) {
  make_qualified_name(name.i0, env.current_module, name)
}

fun make_dotted_name<Ta>(
  env: Ta,
  pos: FileRange,
  mod_name: A.Name,
  name: (FileRange, String),
): (FileRange, String) {
  module_ = expand_module_name(env, mod_name);
  make_qualified_name(pos, module_, name)
}

fun element_privacy(md: DefNames, field_str: String): ?Bool {
  if (md.containsClass(field_str)) {
    Some(false)
  } else {
    if (md.containsFun(field_str)) {
      Some(false)
    } else {
      if (md.containsType(field_str)) {
        Some(false)
      } else {
        if (md.containsConst(field_str)) {
          Some(false)
        } else {
          None()
        }
      }
    }
  }
}

fun get_module(
  context: mutable SKStore.Context,
  env: Env,
  mname: A.Name,
): ?DefNames {
  module_names_find(context, expand_module_name(env, mname))
}

fun is_module(context: mutable SKStore.Context, env: Env, mname: A.Name): Bool {
  is_uppercase(mname) && get_module(context, env, mname).isSome()
}

fun is_const_cstr(
  context: mutable SKStore.Context,
  env: Env,
  fr: FileRange,
  name: A.Name,
): Bool {
  env.current_module match {
  | Unqualified() -> is_const_name(context, env, (fr, ""), name)
  | Module(m) ->
    is_const_name(context, env, (fr, ""), name) ||
      is_const_name(context, env, m, name)
  }
}

fun is_const_name(
  context: mutable SKStore.Context,
  env: Env,
  mname: A.Name,
  cname: A.Name,
): Bool {
  get_module(context, env, mname) match {
  | Some(m) -> m.containsConst(cname.i1)
  | None() -> false
  }
}

fun check_module(
  context: mutable SKStore.Context,
  env: Env,
  mname: A.Name,
  f: (FileRange, String),
): void {
  (fpos, field_str) = f;
  (mpos, m_str) = mname;
  if (m_str == "") {
    void
  } else {
    md_name = expand_module_name(env, mname);
    if (!module_names_mem(context, md_name)) {
      SkipError.error(mpos, "Unbound module: " + m_str)
    };
    md = module_names_find_unsafe(context, md_name);
    is_private = element_privacy(md, field_str);
    if (!is_private.isSome()) {
      defs = md.names().map(s -> (s, s)).collect(Map);
      didYouMeanTypos = SkipDidYouMean.didYouMeanTypos(defs, field_str);
      SkipError.errorl(
        List[
          (
            fpos,
            "Unbound name " +
              field_str +
              " in module " +
              m_str +
              didYouMeanTypos,
          ),
        ],
      )
    };
    (is_private.fromSome(), env.current_module) match {
    | (false, _) -> void
    | (true, Module(n)) if (mname.i1 == n.i1) -> void
    | (true, _) ->
      SkipError.errorl(
        List[
          (
            fpos,
            "Cannot access a private module element " +
              field_str +
              " outside of module " +
              m_str,
          ),
        ],
      )
    }
  }
}

fun check_module_element_privacy(
  element_type: String,
  env: Env,
  privacy: ?FileRange,
): void {
  (privacy, env.current_module) match {
  | (None(), _)
  | (_, Module _) ->
    void
  | (Some(vpos), Unqualified()) ->
    SkipError.error(
      vpos,
      "Cannot declare a " + element_type + " as private outside of a module",
    )
  }
}

fun check_class_privacy(env: Env, privacy: ?FileRange): void {
  check_module_element_privacy("class", env, privacy)
}

fun check_fun_privacy(env: Env, privacy: ?FileRange): void {
  check_module_element_privacy("function", env, privacy)
}

fun check_const_privacy(env: Env, x: (FileRange, A.Visibility)): void {
  x match {
  | (_, A.VPublic()) -> void
  | (_, A.VProtected()) -> invariant_violation("ICE proected const")
  | (pos, A.VPrivate()) ->
    check_module_element_privacy("constant", env, Some(pos))
  }
}

fun current_defs_names(context: mutable SKStore.Context, env: Env): DefNames {
  module_names_find(context, env.current_module) match {
  | None() -> empty_defs_names()
  | Some(value) -> value
  }
}

/*****************************************************************************/
/* Apply type names. */
/*****************************************************************************/
fun cstr_name(
  context: mutable SKStore.Context,
  env: Env,
  name: (FileRange, String),
): (FileRange, String) {
  if (name.i1.startsWith(".")) {
    (namePos, nameStr) = name;
    !nameStr = nameStr.getIter().forward(1).collectString();
    make_qualified_name(namePos, Unqualified(), (namePos, nameStr))
  } else {
    mdefs = current_defs_names(context, env);
    module_ = if (mdefs.containsClass(name.i1) || mdefs.containsType(name.i1)) {
      env.current_module
    } else {
      Unqualified()
    };
    make_qualified_name(name.i0, module_, name)
  }
}

fun type_name(
  context: mutable SKStore.Context,
  env: Env,
  x: A.Type_name,
): A.Type_name {
  x match {
  | A.Tmacro(n) ->
    report_macro_usage(env, n.i0);
    x
  | A.Tclass(name @ (_, n)) ->
    env.tparams.maybeGet(n) match {
    | Some((_, id, _, _)) -> A.Tparam(name, id)
    | None() -> A.Tclass(cstr_name(context, env, name))
    }
  | A.Tmodule_class(pos, module_name, class_name) ->
    check_module(context, env, module_name, class_name);
    A.Tclass(make_dotted_name(env, pos, module_name, class_name))
  | param_ref @ A.Tparam _ -> param_ref
  }
}

/*****************************************************************************/
/* Apply variable names. */
/*****************************************************************************/
fun var_name(
  context: mutable SKStore.Context,
  env: Env,
  name: (FileRange, String),
): (FileRange, String) {
  mdefs = current_defs_names(context, env);
  module_ = if (
    !env.locals.contains(name.i1) &&
    (mdefs.containsFun(name.i1) || mdefs.containsConst(name.i1))
  ) {
    env.current_module
  } else {
    Unqualified()
  };
  make_qualified_name(name.i0, module_, name)
}

/*****************************************************************************/
/* Assign unique type parameter ids to the parse trees. */
/*****************************************************************************/
/* Tparams have globably unique names (based on their declared context
 * to make substitution easier in later passes
 */

fun unique_tparams(
  context: String,
  tparams: Array<SkipAst.Type_parameter>,
): Array<SkipAst.Type_parameter> {
  tparams.map(tparam -> {
    tparam match {
    | (var, "", tparam_name, tyo) ->
      (_, tparam_str) = tparam_name;
      (var, tparam_str + ":" + context, tparam_name, tyo)
    | _ -> invariant_violation("ICE non empty context for unique_tparams")
    }
  })
}

// Children-clause classes inherit their tparams but still need unique IDs for
// substitution

fun unique_child_tparams(
  context: String,
  tparams: Array<SkipAst.Type_parameter>,
): Array<SkipAst.Type_parameter> {
  tparams.map(tparam -> {
    tparam match {
    | (_var, "", _, _tyo) ->
      invariant_violation("ICE empty context for unique_child_tparams")
    | (var, _, tparam_name, tyo) ->
      (_, tparam_str) = tparam_name;
      (var, tparam_str + ":" + context, tparam_name, tyo)
    }
  })
}

fun tparams_method(
  context: String,
  met: SkipAst.Method_def,
): SkipAst.Method_def {
  (_, method_name) = met.name;
  method_context = method_name + "<method>:" + context;
  tparams = unique_tparams(method_context, met.tparams);
  met with {tparams}
}

/* Must be here to work around Ocaml type system */
fun malias_type_def_<Ta>(
  env: Env,
  f_body: ((Env, Ta) -> Ta),
  tyd: A.Type_def<Ta>,
): A.Type_def<Ta> {
  tyd with {body => f_body(env, tyd.body)}
}

/*****************************************************************************/
/* The entry point of the pass. */
/*****************************************************************************/
const emptyProgram: A.Program = A.Program{
  type_defs => UMap[],
  class_defs => UMap[],
  fun_defs => UMap[],
  const_defs => UMap[],
};

class DefsFile(value: (?FileRange, SkipExpand.Defs)) extends SKStore.File

fun program(
  context: mutable SKStore.Context,
  files: SKStore.EHandle<FileCache.InputSource, SkipParse.DefsFile>,
): (
  SKStore.EHandle<SKStore.SID, GlobalEnv.ExpandedDefFile>,
  SKStore.EHandle<SKStore.SID, SKStore.StringFile>,
) {
  moduleDefsPhase1Dir = files.map(
    SKStore.SID::keyType,
    DefsFile::type,
    context,
    SKStore.DirName::create("/moduleMap1/"),
    (context, writer, _key, values) ~> {
      for (fileDefs in values) {
        SkipError.catchErrors(1, context, () -> {
          moduleMap = definitions(context, fileDefs.value);
          for (moduleName => defs in moduleMap) {
            writer.set(SKStore.SID(moduleName), DefsFile(defs))
          }
        })
      }
    },
  );
  moduleDefsDir = moduleDefsPhase1Dir.map(
    SKStore.SID::keyType,
    DefsFile::type,
    context,
    SKStore.DirName::create("/moduleMap2/"),
    (context, writer, key, values) ~> {
      SkipError.catchErrors(1, context, () -> {
        acc = values.nonEmptyReduce(
          (acc, d) -> mergeDefs(acc, d.value),
          firstDefFile -> firstDefFile.value,
        );
        moduleName = key match {
        | SKStore.SID(x) -> x
        };
        writer.set(SKStore.SID(moduleName), DefsFile(acc))
      })
    },
  );
  ModuleMap.populateCache(context, moduleDefsDir);
  expandEnv = makeEnv();
  expandedDefs = moduleDefsDir.map(
    SKStore.SID::keyType,
    DefsFile::type,
    context,
    SKStore.DirName::create("/moduleMap3/"),
    (context, writer, key, defsFiles) ~> {
      SkipError.catchErrors(1, context, () -> {
        moduleName = key match {
        | SKStore.SID(x) -> x
        };
        defs = defsFiles.assertUnique().value;
        writer.set(
          key,
          DefsFile(module_expand(context, expandEnv, moduleName, defs)),
        );
      })
    },
  );
  defs = GlobalEnv.populateDefinitions(context, expandedDefs);
  childDir = ChildMap.populateCache(context, expandedDefs);
  ChildMap.checkCycles(context, defs);
  (defs, childDir)
}

/*****************************************************************************/
/* Collecting definitions. */
/*****************************************************************************/
fun add_def(
  env: Env,
  module_defs: Module_map_t,
  f: ((Defs) -> Defs),
): Module_map_t {
  defs = module_map_find(env.current_module, module_defs) match {
  | None() -> empty_defs(env.current_module)
  | Some(x) -> x
  };
  !defs = f(defs);
  !module_defs = module_map_add(env.current_module, defs, module_defs);
  module_defs
}

fun mergeDefs(
  posDefs1: (?FileRange, Defs),
  posDefs2: (?FileRange, Defs),
): (?FileRange, Defs) {
  (pos, defs1) = posDefs1;
  (_, defs2) = posDefs2;
  class_defs = defs1.class_defs;
  for (cd in defs2.class_defs) {
    (!class_defs, _) = add_cd_merge_extentions(class_defs, cd);
  };
  (
    pos,
    defs1 with {
      class_defs,
      const_defs => UMap::union(defs1.const_defs, defs2.const_defs),
      fun_defs => UMap::union(defs1.fun_defs, defs2.fun_defs),
      type_defs => UMap::union(defs1.type_defs, defs2.type_defs),
    },
  )
}

fun mergeModuleMap(map1: Module_map_t, map2: Module_map_t): Module_map_t {
  acc = map1;
  for (name => defs2 in map2) {
    acc.maybeGet(name) match {
    | None() -> !acc = acc.add(name, defs2)
    | Some(defs1) -> !acc = acc.set(name, mergeDefs(defs1, defs2))
    }
  };
  acc
}

fun mergePrograms(prog2: A.Program, prog1: A.Program): A.Program {
  acc = prog1;
  prog2.type_defs.each((_, type_def) ->
    !acc = add_tyd_to_acc(type_def.name, type_def, acc)
  );
  prog2.class_defs.each((_, class_def) ->
    !acc = add_cd_to_acc(class_def.name, class_def, acc)
  );
  prog2.fun_defs.each((_, fun_def) ->
    !acc = add_fun_to_acc(fun_def.name, fun_def, acc)
  );
  prog2.const_defs.each((_, const_def) -> {
    !acc = add_con_to_acc(const_def.name, const_def, acc)
  });
  acc
}

fun definitions(
  context: mutable SKStore.Context,
  file: List<SkipAst.Definition>,
): Module_map_t {
  env = makeEnv();
  module_defs = SortedMap[];
  !env.current_module = Unqualified();
  assert(env.module_aliases.isEmpty());
  (!env, !module_defs) = file.foldl(
    (acc, x) -> definition(context, acc, x),
    (env, module_defs),
  );
  !env.module_aliases = UMap[];
  module_defs
}

fun definition(
  context: mutable SKStore.Context,
  acc: (Env, Module_map_t),
  x: A.Definition,
): (Env, Module_map_t) {
  (env, module_defs) = acc;
  x match {
  | A.DMalias(mal) ->
    if (env.current_module != Unqualified()) {
      SkipError.error(mal.pos, "Expected 'module end;'")
    };
    !env.module_aliases = env.module_aliases.add(mal.mal_name, mal);
    (env, module_defs)
  | A.DModule(pos, module_name) ->
    if (env.current_module != Unqualified()) {
      SkipError.error(pos, "Expected 'module end;'")
    };
    !env.current_module = Module(module_name);
    !env.context_name = "<module>" + env.current_module + ":";
    (env, module_defs)
  | A.DModuleEnd(pos) ->
    if (env.current_module == Unqualified()) {
      SkipError.error(pos, "Unexpected 'module end;'")
    };
    !env.current_module = Unqualified();
    (env, module_defs)
  | A.DType(tyd) ->
    (_, type_name) = tyd.name;
    type_context = "<type>" + type_name + ":" + env.context_name;
    !tyd.tparams = unique_tparams(type_context, tyd.tparams);
    tyd1 = malias_type_def(env, tyd);
    !module_defs = add_def(env, module_defs, defs -> {
      type_defs = defs.type_defs.add(tyd1.name, tyd1);
      defs with {type_defs}
    });
    (env, module_defs)
  | A.DConst(cst) ->
    !cst = malias_const_def(context, env, cst);
    !module_defs = add_def(env, module_defs, defs -> {
      const_defs = defs.const_defs.add(cst.name, cst);
      defs with {const_defs}
    });
    (env, module_defs)
  | A.DFun(fd) ->
    (_, function_name) = fd.name;
    fun_context = "<fun>" + function_name + ":" + env.context_name;
    !fd.tparams = unique_tparams(fun_context, fd.tparams);
    !fd = malias_fun_def(context, env, fd);
    !module_defs = add_def(env, module_defs, defs -> {
      fun_defs = defs.fun_defs.add(fd.name, fd);
      defs with {fun_defs}
    });
    (env, module_defs)
  | A.DClass(cd) ->
    (_, class_name) = cd.name;
    class_context = "<class>" + class_name + ":" + env.context_name;
    !cd = setNativeConstructor(cd);
    !cd.tparams = unique_tparams(class_context, cd.tparams);
    !cd.methods = cd.methods.map((_, cur1) ->
      tparams_method(class_context, cur1)
    );
    !cd = malias_class_def(context, env, cd);
    children_ = cd.children_;
    !module_defs = add_def(env, module_defs, defs -> {
      (class_defs, !cd) = add_cd_merge_extentions(defs.class_defs, cd);
      defs with {class_defs}
    });
    add_child = (chi: A.Child, map: UMap<A.Class_def>) -> {
      map.add(
        chi.chi_name,
        child(
          env.context_name,
          cd.name,
          cd.private_,
          cd.mutable_,
          cd.tparams,
          chi,
        ),
      )
    };
    !module_defs = add_def(env, module_defs, defs -> {
      class_defs = children_.foldr(add_child, defs.class_defs);
      defs with {class_defs}
    });
    (env, module_defs)
  }
}

/* Classes marked 'native' get a native constructor
 * TODO move the native keyword to constructor/field list position
 */
fun setNativeConstructor(cd: A.Class_def): A.Class_def {
  (cd.native_, cd.params) match {
  | (None(), _) -> cd
  | (Some(fr), A.NoParams()) -> cd with {params => A.NativeConstruct(fr)}

  | (Some(fr), A.HasParams(A.Class_params{pos})) ->
    SkipError.errorl(
      List[
        (pos, "Cannot add parameters to a class marked 'native'"),
        (fr, "Declared 'native' here"),
      ],
    )
  | (Some _, A.NativeConstruct _) ->
    invariant_violation("ICE impossible native constructor already set")
  }
}

fun add_cd_merge_extentions(
  class_defs: UMap<A.Class_def>,
  cd: A.Class_def,
): (UMap<A.Class_def>, A.Class_def) {
  class_defs.maybeGet(cd.name) match {
  | None() -> (class_defs.add(cd.name, cd), cd)
  | Some(old_cd) ->
    (root_cd, ext_cd) = {
      (cd.extension, old_cd.extension) match {
      | (None(), None()) ->
        SkipError.errorl(
          List[
            (cd.name.i0, "Name already bound"),
            (old_cd.name.i0, "Previously defined here"),
          ],
        )
      | (Some _, None()) -> (old_cd, cd)
      | (Some _, Some _)
      | (None(), Some _) ->
        (cd, old_cd)
      }
    };
    !cd = merge_class(root_cd, ext_cd);
    cdefs = class_defs.set(cd.name, cd);
    (cdefs, cd)
  }
}

fun merge_class(cd: A.Class_def, ext_cd: A.Class_def): A.Class_def {
  if (!ext_cd.tparams.isEmpty()) {
    SkipError.error(
      ext_cd.name.i0,
      "Invalid extension. Extension classes cannot add generics.",
    )
  };
  not_set(ext_cd.native_);
  (cd.kind, ext_cd.kind) match {
  | (A.KTrait(), A.KTrait())
  | (A.KClass(), A.KClass())
  | (A.KBase(), A.KBase()) ->
    void
  | _ ->
    SkipError.errorl(
      List[
        (ext_cd.name.i0, "Incompatible extension"),

        (cd.name.i0, "The class kinds are incompatible"),
      ],
    )
  };
  not_set(ext_cd.value);
  not_set(ext_cd.data);
  !ext_cd = ext_class_tparams(cd.tparams, ext_cd);
  params = (cd.params, ext_cd.params) match {
  | (_, A.NativeConstruct _) ->
    invariant_violation("ICE native set on extension class")
  | (A.NoParams(), x)
  | (x, A.NoParams()) ->
    x
  | (A.NativeConstruct(fr), A.HasParams(A.Class_params{pos})) ->
    SkipError.errorl(
      List[
        (
          pos,
          "Extension classes cannot add parameters to a class marked 'native'",
        ),
        (fr, "Declared 'native' here"),
      ],
    )
  | (A.HasParams(cp), A.HasParams(ext_cp)) ->
    A.HasParams(merge_class_params(cp, ext_cp))
  };
  extends_ = cd.extends_.concat(ext_cd.extends_);
  use = cd.use.concat(ext_cd.use);
  children_ = cd.children_.concat(ext_cd.children_);
  consts = UMap::union(cd.consts, ext_cd.consts);
  types = UMap::union(cd.types, ext_cd.types);
  methods = UMap::union(cd.methods, ext_cd.methods);
  annotations = cd.annotations.union(ext_cd.annotations);
  fields = cd.fields.concat(ext_cd.fields);
  cd with {
    params,
    extends_,
    use,
    children_,
    consts,
    types,
    methods,
    annotations,
    fields,
  }
}

fun not_set(x: ?FileRange): void {
  x match {
  | None() -> void
  | Some(pos) -> SkipError.error(pos, "Invalid modifier in a class extension")
  }
}

/* Merges params/fields for extension classes */
fun merge_class_params(
  cp: A.Class_params,
  ext_cp: A.Class_params,
): A.Class_params {
  not_set(ext_cp.final_);
  params = {
    (cp.params, ext_cp.params) match {
    | (Positional _, Positional _) ->
      SkipError.errorl(
        List[
          (cp.pos, "Cannot define multiple positional parameters"),
          (ext_cp.pos, "Previously defined here"),
        ],
      )
    | (Named _, Positional _)
    | (Positional _, Named _) ->
      SkipError.errorl(
        List[
          (cp.pos, "Incompatible class parameters"),
          (ext_cp.pos, "Previously defined here"),
        ],
      )
    | (Named(m1), Named(m2)) ->
      add = (map: UMap<A.Parameter>, n: A.Name, p: A.Parameter) ->
        map.add(n, p);
      ps = m1.reduce<UMap<A.Parameter>>(add, m2);
      Named(ps)
    }
  };
  (cp.visibility.i1, ext_cp.visibility.i1) match {
  | (A.VPrivate(), A.VPrivate())
  | (A.VPublic(), A.VPublic())
  | (A.VProtected(), A.VProtected()) ->
    void
  | _ ->
    SkipError.errorl(
      List[
        (cp.visibility.i0, "Incompatible constructor visibility"),

        (ext_cp.visibility.i0, "Previously defined here"),
      ],
    )
  };
  ext_cp.visibility match {
  | (_, A.VPublic()) -> void
  | (pos, _) ->
    SkipError.error(pos, "Cannot set constructor visibility in an extension")
  };
  cp with {params}
}

/*****************************************************************************/
/* Expanding module aliases. */
/*****************************************************************************/
fun malias_type_def(env: Env, tyd: A.Type_alias_def): A.Type_alias_def {
  if (env.module_aliases.isEmpty()) {
    tyd
  } else {
    malias_type_def_alias(env, tyd)
  }
}

fun malias_type_def_alias(env: Env, tyd: A.Type_alias_def): A.Type_alias_def {
  malias_type_def_(env, malias_type, tyd)
}

fun f(env: Env, x: A.Cla_tyd): A.Cla_tyd {
  x match {
  | A.TydAbstract(tyo1, tyo2) ->
    A.TydAbstract(
      tyo1.map(ty -> malias_type(env, ty)),
      tyo2.map(ty -> malias_type(env, ty)),
    )
  | A.TydDefined(ty) -> A.TydDefined(malias_type(env, ty))
  }
}

fun malias_type_consts(env: Env, tyd: A.Cla_type_def): A.Cla_type_def {
  malias_type_def_(env, f, tyd)
}

fun malias_const_def(
  context: mutable SKStore.Context,
  env: Env,
  cst: A.Const_def,
): A.Const_def {
  if (env.module_aliases.isEmpty()) {
    cst
  } else {
    cst with {
      type => malias_type(env, cst.type),
      value => malias_body(context, env, cst.value),
    }
  }
}

fun malias_fun_def(
  context: mutable SKStore.Context,
  env: Env,
  fd: A.Fun_def,
): A.Fun_def {
  if (env.module_aliases.isEmpty()) {
    fd
  } else {
    fd with {
      tparams => malias_tparams(env, fd.tparams),
      params => malias_params(context, env, fd.params),
      return_ => malias_type(env, fd.return_),
      body => fd.body.map(ex ->
        (context) ~> malias_expr(context, env, ex(context))
      ),
    }
  }
}

fun malias_class_def(
  context: mutable SKStore.Context,
  env: Env,
  cd: A.Class_def,
): A.Class_def {
  if (env.module_aliases.isEmpty()) {
    cd
  } else {
    consts = cd.consts.map((_, cur1) -> malias_const_def(context, env, cur1));
    types = cd.types.map((_, cur1) -> malias_type_consts(env, cur1));
    methods = cd.methods.map((_, cur1) -> malias_methods(context, env, cur1));
    cd with {
      tparams => malias_tparams(env, cd.tparams),
      params => cd.params.mapClassParams(cps ->
        malias_class_params(context, env, cps)
      ),
      extends_ => malias_parents(env, cd.extends_),
      use => malias_parents(env, cd.use),
      children_ => malias_children(context, env, cd.children_),
      consts,
      types,
      methods,
    }
  }
}

fun malias_tparams(
  env: Env,
  tparams: Array<A.Type_parameter>,
): Array<A.Type_parameter> {
  tparams.map(cur1 -> malias_tparam(env, cur1))
}

fun malias_tparam(env: Env, tp: A.Type_parameter): A.Type_parameter {
  (v, i, n, tylo) = tp;
  (v, i, n, tylo.map((l -> l.map(cur1 -> malias_type(env, cur1)))))
}

fun malias_when_params(
  env: Env,
  tparams: Array<A.When_type_clause>,
): Array<A.When_type_clause> {
  tparams.map(cur1 -> malias_when_clause(env, cur1))
}

fun malias_when_clause(env: Env, wc: A.When_type_clause): A.When_type_clause {
  (ty, tyl) = wc;
  (malias_type(env, ty), tyl.map(t -> malias_type(env, t)))
}

fun malias_params(
  context: mutable SKStore.Context,
  env: Env,
  params: Parameters<A.Parameter>,
): Parameters<A.Parameter> {
  params.map(ps -> malias_param(context, env, ps))
}

fun malias_param(
  context: mutable SKStore.Context,
  env: Env,
  p: A.Parameter,
): A.Parameter {
  p with {
    type => malias_type(env, p.type),
    value => p.value.map(ex -> malias_expr(context, env, ex)),
  }
}

fun malias_class_params(
  context: mutable SKStore.Context,
  env: Env,
  cp: A.Class_params,
): A.Class_params {
  cp with {params => malias_params(context, env, cp.params)}
}

fun malias_parents(env: Env, pl: Array<A.Parent>): Array<A.Parent> {
  pl.map(cur1 -> malias_parent(env, cur1))
}

fun malias_parent(env: Env, p: A.Parent): A.Parent {
  !p.parent = (
    maybe_malias_ty_name(env, p.parent.i0),
    p.parent.i1.map(ty -> malias_type(env, ty)),
  );
  !p.conditions = p.conditions.map(c -> malias_when_clause(env, c));
  p
}

fun report_macro_usage(env: Env, pos: FileRange): void {
  if (!env.allowMacros) {
    SkipError.error(
      pos,
      "Macros may only be used inside bodies of methods marked 'macro'.",
    )
  };
}

fun malias_children(
  context: mutable SKStore.Context,
  env: Env,
  sk_children: A.Children,
): A.Children {
  sk_children.map(cur1 -> malias_child(context, env, cur1))
}

fun malias_child(
  context: mutable SKStore.Context,
  env: Env,
  child: A.Child,
): A.Child {
  child with {
    chi_params => child.chi_params.map(cps ->
      malias_class_params(context, env, cps)
    ),
  }
}

fun malias_methods(
  context: mutable SKStore.Context,
  env: Env,
  met: A.Method_def,
): A.Method_def {
  met with {
    whenparams => malias_when_params(env, met.whenparams),
    tparams => malias_tparams(env, met.tparams),
    params => malias_params(context, env, met.params),
    return_ => malias_type(env, met.return_),
    body => malias_body(
      context,
      env with {allowMacros => met.isMacro()},
      met.body,
    ),
  }
}

fun malias_type(env: Env, ty: A.Type_): A.Type_ {
  lam: (Env, void, A.Type_) ~> (void, A.Type_) = (
    env1: Env,
    _: void,
    ty1: A.Type_,
  ) ~> {
    (ty1 match {
    | (pos, A.Tapply(n, tyl)) ->
      (void, (pos, A.Tapply(maybe_malias_ty_name(env1, n), tyl)))
    | (pos, A.Tabstract(n, tyl)) ->
      (void, (pos, A.Tabstract(maybe_malias_ty_name(env1, n), tyl)))
    | _ -> (void, ty1)
    } : (void, A.Type_))
  };
  (_, ty1) = SkipAstUtils.type<Env, void>(lam, env, void, ty);
  ty1
}

fun malias_key_values(
  context: mutable SKStore.Context,
  env: Env,
  x: (A.Expr, A.Expr),
): (A.Expr, A.Expr) {
  (e1, e2) = x;
  (malias_expr(context, env, e1), malias_expr(context, env, e2))
}

fun maybe_malias_ty_name(env: Env, x: A.Type_name): A.Type_name {
  x match {
  | A.Tclass(n @ (cpos, _)) if (env.module_aliases.containsKey(n)) ->
    ma = env.module_aliases[n];
    (_, new_str) = ma.mal_rhs_name;
    A.Tclass((cpos, new_str))
  | A.Tmodule_class(
    pos,
    n @ (cpos, _),
    n2,
  ) if (env.module_aliases.containsKey(n)) ->
    ma = env.module_aliases[n];
    (_, new_str) = ma.mal_rhs_name;
    A.Tmodule_class(pos, (cpos, new_str), n2)
  | A.Tmacro(n) ->
    report_macro_usage(env, n.i0);
    x
  | tn -> tn
  }
}

fun malias_body(
  context: mutable SKStore.Context,
  env: Env,
  m: A.Inherited_body,
): A.Inherited_body {
  (p, mb) = m;
  (p, malias_body_(context, env, mb))
}

fun malias_body_(
  context: mutable SKStore.Context,
  env: Env,
  x: A.Inherited_body_,
): A.Inherited_body_ {
  x match {
  | A.Inherited _ ->
    invariant_violation("ICE inherited method body before inherit")
  | A.Body(eb) -> A.Body(malias_expr_body(context, env, eb))
  }
}

fun malias_expr_body(
  context: mutable SKStore.Context,
  env: Env,
  x: A.Expr_body,
): A.Expr_body {
  x match {
  | A.BAlgebraic(mbl) -> A.BAlgebraic(malias_match_branches(context, env, mbl))
  | A.BExpr(e) -> A.BExpr((context) ~> malias_expr(context, env, e(context)))
  | A.BFrom(tn) -> A.BFrom(maybe_malias_ty_name(env, tn))
  | A.BNative _
  | A.BNone() ->
    x
  }
}

fun malias_lam_param(env: Env, param: A.Lam_parameter): A.Lam_parameter {
  param match {
  | (nm, Some(ty)) -> (nm, Some(malias_type(env, ty)))
  | _ -> param
  }
}

fun malias_lam_params(
  env: Env,
  params: Parameters<A.Lam_parameter>,
): Parameters<A.Lam_parameter> {
  params.map(lp -> malias_lam_param(env, lp))
}

fun malias_expr(
  context: mutable SKStore.Context,
  env: Env,
  ex: A.Expr,
): A.Expr {
  (pos, e) = ex;
  (pos, malias_expr_(context, env, pos, e))
}

fun malias_expr_(
  context: mutable SKStore.Context,
  env: Env,
  pos: FileRange,
  e: A.Expr_,
): A.Expr_ {
  k = ex -> malias_expr(context, env, ex);
  e match {
  | A.Literal _
  | A.Var _ ->
    e
  | A.MacroVar _ ->
    report_macro_usage(env, pos);
    e
  | A.Seq(e1, e2) -> A.Seq(k(e1), k(e2))
  | A.If(e1, e2, e3) -> A.If(k(e1), k(e2), k(e3))
  | A.Cstr(n @ (cpos, _), tyl) if (env.module_aliases.containsKey(n)) ->
    ma = env.module_aliases[n];
    (_, new_str) = ma.mal_rhs_name;
    A.Cstr((cpos, new_str), tyl.map(cur1 -> malias_type(env, cur1)))
  | A.Cstr(cn, tyl) -> A.Cstr(cn, tyl.map(cur1 -> malias_type(env, cur1)))
  | A.Call(e1, tyl, ep) ->
    A.Call(
      k(e1),
      tyl.map(cur1 -> malias_type(env, cur1)),
      malias_call_args(context, env, ep),
    )
  | A.CallArray(e1, tyl, ep) ->
    A.CallArray(
      k(e1),
      tyl.map(cur1 -> malias_type(env, cur1)),
      malias_call_args(context, env, ep),
    )
  | A.CallMap(e1, tyl, ep) ->
    A.CallMap(
      k(e1),
      tyl.map(cur1 -> malias_type(env, cur1)),
      ep.map(cur1 -> malias_key_values(context, env, cur1)),
    )
  | A.Annotated(e1, ty) -> A.Annotated(k(e1), malias_type(env, ty))
  | A.Dot(e1, n) -> A.Dot(k(e1), n)
  | A.StaticDot(e1, n) -> A.StaticDot(k(e1), n)
  | A.MacroDot(e1, n) ->
    report_macro_usage(env, pos);
    A.MacroDot(k(e1), n)
  | A.MacroStaticDot(e1, n) ->
    report_macro_usage(env, pos);
    A.MacroStaticDot(k(e1), n)
  | A.Pipe(e1, e2) -> A.Pipe(k(e1), k(e2))
  | A.Binop(bop, e1, e2) -> A.Binop(bop, k(e1), k(e2))
  | A.Unop(uop, e1) -> A.Unop(uop, k(e1))
  | A.Is(e1, pat) -> A.Is(k(e1), malias_pattern(context, env, pat))
  | A.As(e1, pat) -> A.As(k(e1), malias_pattern(context, env, pat))
  | A.Match(e1, mbl) -> A.Match(k(e1), malias_match_branches(context, env, mbl))
  | A.Lambda(m, p, e1) -> A.Lambda(m, malias_lam_params(env, p), k(e1))
  | A.Tuple(el) -> A.Tuple(el.map(k))
  | A.TemplateLiteral(ep) ->
    A.TemplateLiteral(malias_call_args(context, env, ep))
  | A.Try(e1, mbl) -> A.Try(k(e1), malias_match_branches(context, env, mbl))
  | A.Await(e1) -> A.Await(k(e1))
  | A.Return(e1) -> A.Return(k(e1))
  | A.Yield(e1) -> A.Yield(k(e1))
  | A.YieldBreak() -> A.YieldBreak()
  | A.Async(e1) -> A.Async(k(e1))
  | A.Throw(e1) -> A.Throw(k(e1))
  | A.With(e1, args) ->
    A.With(
      k(e1),
      args.map((_, cur1) -> malias_ordered_expr(context, env, cur1)),
    )
  | A.Bind(lv, e1, e2) -> A.Bind(malias_lvalue(context, env, lv), k(e1), k(e2))
  | A.Mutable(e1) -> A.Mutable(k(e1))
  | A.Continue() -> A.Continue()
  | A.Break(eb) -> A.Break(k(eb))
  | A.Loop(eb) -> A.Loop(k(eb))
  | A.DoWhile(body, condition, withoutBreak) ->
    A.DoWhile(k(body), k(condition), k(withoutBreak))
  | A.While(condition, body, withoutBreak) ->
    A.While(k(condition), k(body), k(withoutBreak))
  | A.ForEach(binding, collection, body, withoutBreak) ->
    A.ForEach(binding, k(collection), k(body), k(withoutBreak))
  | A.ForEachFieldMacro(field, fieldName, body) ->
    report_macro_usage(env, pos);
    A.ForEachFieldMacro(field, fieldName, k(body))
  | A.ForEachFunctionMacro(annotation, function, functionName, body) ->
    report_macro_usage(env, pos);
    A.ForEachFunctionMacro(annotation, function, functionName, k(body))
  }
}

fun malias_call_args(
  context: mutable SKStore.Context,
  env: Env,
  args: A.Call_args,
): A.Call_args {
  args.map(p -> malias_ordered_expr(context, env, p))
}

fun malias_ordered_expr(
  context: mutable SKStore.Context,
  env: Env,
  oe: A.Ordered_expr,
): A.Ordered_expr {
  (i, e) = oe;
  (i, malias_expr(context, env, e))
}

fun malias_lvalue(
  context: mutable SKStore.Context,
  env: Env,
  l: A.Lvalue,
): A.Lvalue {
  (fr, lvalue_) = l;
  lvalue_ match {
  | A.Lvalue_bind_local _ -> l
  | A.Lvalue_assign(avalue) ->
    !avalue = malias_lvalue_assign_value(context, env, avalue);
    (fr, A.Lvalue_assign(avalue))
  | A.Lvalue_array_set(ea, el) ->
    (
      fr,
      A.Lvalue_array_set(
        malias_expr(context, env, ea),
        malias_call_args(context, env, el),
      ),
    )
  | A.Lvalue_tuple(lvl) ->
    !lvl = lvl.map(lv -> malias_lvalue(context, env, lv));
    (fr, A.Lvalue_tuple(lvl))
  }
}

fun malias_lvalue_assign_value(
  context: mutable SKStore.Context,
  env: Env,
  l: A.Lvalue_assign_value,
): A.Lvalue_assign_value {
  l match {
  | A.Lvalue_assign_local _ -> l
  | A.Lvalue_assign_field(e, n) ->
    !e = malias_expr(context, env, e);
    A.Lvalue_assign_field(e, n)
  | A.Lvalue_assign_with(avalue, n) ->
    !avalue = malias_lvalue_assign_value(context, env, avalue);
    A.Lvalue_assign_with(avalue, n)
  | A.Lvalue_assign_array_set(avalue, el) ->
    A.Lvalue_assign_array_set(
      malias_lvalue_assign_value(context, env, avalue),
      malias_call_args(context, env, el),
    )
  }
}

fun malias_match_branches(
  context: mutable SKStore.Context,
  env: Env,
  mbl: List<A.Match_branch>,
): List<A.Match_branch> {
  mbl.map(cur1 -> malias_match_branch(context, env, cur1))
}

fun malias_match_branch(
  context: mutable SKStore.Context,
  env: Env,
  mb: A.Match_branch,
): A.Match_branch {
  (pats, maybe_guard, e) = mb;
  (
    pats.map(cur1 -> malias_pattern(context, env, cur1)),
    maybe_guard.map(ex -> malias_expr(context, env, ex)),
    malias_expr(context, env, e),
  )
}

fun malias_pattern(
  context: mutable SKStore.Context,
  env: Env,
  pat: A.Pattern,
): A.Pattern {
  (pos, p) = pat;
  (pos, malias_pattern_(context, env, p))
}

fun malias_pattern_(
  context: mutable SKStore.Context,
  env: Env,
  x: A.Pattern_,
): A.Pattern_ {
  x match {
  | A.Pat_type(tid, nparams, complete) ->
    new_tid = malias_tid(env, tid);
    new_nparams = nparams.map(ps ->
      ps.map(p -> malias_pattern(context, env, p))
    );
    A.Pat_type(new_tid, new_nparams, complete)
  | A.Pat_tuple(pats) ->
    A.Pat_tuple(pats.map(cur1 -> malias_pattern(context, env, cur1)))
  | A.Pat_as(p, n) -> A.Pat_as(malias_pattern(context, env, p), n)
  | A.Pat_const(ex) -> A.Pat_const(malias_expr(context, env, ex))
  | A.Pat_var _
  | A.Pat_literal _ ->
    x
  }
}

fun malias_tid(env: Env, x: A.TypeIdentifier): A.TypeIdentifier {
  x match {
  | A.Tid_object(tn) -> A.Tid_object(maybe_malias_ty_name(env, tn))
  | x1 @ A.Tid_static _ -> x1
  }
}

/*****************************************************************************/
/* Substitute tparams for ext classes.
 * If this substitution is not done, the tparams will not be properly
 * resolved for code written inside the extension class
 * ALTERNATIVE TODO. Another option woould be to require extension classes to
 */

/*****************************************************************************/

fun ext_class_tparams_type_consts(
  subst: SMap<A.Tparam>,
  tyd: A.Cla_type_def,
): A.Cla_type_def {
  tyd with {
    body => tyd.body match {
    | A.TydAbstract(tyo1, tyo2) ->
      A.TydAbstract(
        tyo1.map(ty -> ext_class_tparams_type(subst, ty)),
        tyo2.map(ty -> ext_class_tparams_type(subst, ty)),
      )
    | A.TydDefined(ty) -> A.TydDefined(ext_class_tparams_type(subst, ty))
    },
  }
}

fun ext_class_tparams_const_def(
  subst: SMap<A.Tparam>,
  cst: A.Const_def,
): A.Const_def {
  cst with {
    type => ext_class_tparams_type(subst, cst.type),
    value => ext_class_tparams_body(subst, cst.value),
  }
}

fun ext_class_tparams(
  tparams: Array<A.Type_parameter>,
  cd: A.Class_def,
): A.Class_def {
  if (tparams.isEmpty()) {
    cd
  } else {
    subst =
      tparams.values().map(tp -> (tp.i2.i1, A.Tparam(tp.i2, tp.i1))) |>
      SortedMap::createFromIterator;
    consts = cd.consts.map((_, cur1) ->
      ext_class_tparams_const_def(subst, cur1)
    );
    types = cd.types.map((_, cur1) ->
      ext_class_tparams_type_consts(subst, cur1)
    );
    methods = cd.methods.map((_, cur1) ->
      ext_class_tparams_methods(subst, cur1)
    );
    cd with {
      tparams => ext_class_tparams_tparams(subst, cd.tparams),
      params => cd.params.mapClassParams(cps ->
        ext_class_tparams_class_params(subst, cps)
      ),
      extends_ => ext_class_tparams_parents(subst, cd.extends_),
      use => ext_class_tparams_parents(subst, cd.use),
      children_ => ext_class_tparams_children(subst, cd.children_),
      consts,
      types,
      methods,
    }
  }
}

fun ext_class_tparams_tparams(
  subst: SMap<A.Tparam>,
  tparams: Array<A.Type_parameter>,
): Array<A.Type_parameter> {
  tparams.map(cur1 -> ext_class_tparams_tparam(subst, cur1))
}

fun ext_class_tparams_tparam(
  subst: SMap<A.Tparam>,
  tp: A.Type_parameter,
): A.Type_parameter {
  (v, i, n, tylo) = tp;
  (v, i, n, tylo.map((l -> l.map(cur1 -> ext_class_tparams_type(subst, cur1)))))
}

fun ext_class_tparams_when_params(
  subst: SMap<A.Tparam>,
  tparams: Array<A.When_type_clause>,
): Array<A.When_type_clause> {
  tparams.map(cur1 -> ext_class_tparams_when_clause(subst, cur1))
}

fun ext_class_tparams_when_clause(
  subst: SMap<A.Tparam>,
  wc: A.When_type_clause,
): A.When_type_clause {
  (ty, tyl) = wc;
  (
    ext_class_tparams_type(subst, ty),
    tyl.map(t -> ext_class_tparams_type(subst, t)),
  )
}

fun ext_class_tparams_params(
  subst: SMap<A.Tparam>,
  params: Parameters<A.Parameter>,
): Parameters<A.Parameter> {
  params.map(ps -> ext_class_tparams_param(subst, ps))
}

fun ext_class_tparams_param(
  subst: SMap<A.Tparam>,
  p: A.Parameter,
): A.Parameter {
  p with {
    type => ext_class_tparams_type(subst, p.type),
    value => p.value.map(ex -> ext_class_tparams_expr(subst, ex)),
  }
}

fun ext_class_tparams_class_params(
  subst: SMap<A.Tparam>,
  cp: A.Class_params,
): A.Class_params {
  cp with {params => ext_class_tparams_params(subst, cp.params)}
}

fun ext_class_tparams_parents(
  subst: SMap<A.Tparam>,
  pl: Array<A.Parent>,
): Array<A.Parent> {
  pl.map(cur1 -> ext_class_tparams_parent(subst, cur1))
}

fun ext_class_tparams_parent(subst: SMap<A.Tparam>, p: A.Parent): A.Parent {
  !p.parent = (
    maybe_ext_class_tparams_ty_name(subst, p.parent.i0),
    p.parent.i1.map(ty -> ext_class_tparams_type(subst, ty)),
  );
  !p.conditions = p.conditions.map(c ->
    ext_class_tparams_when_clause(subst, c)
  );
  p
}

fun ext_class_tparams_children(
  subst: SMap<A.Tparam>,
  sk_children: A.Children,
): A.Children {
  sk_children.map(cur1 -> ext_class_tparams_child(subst, cur1))
}

fun ext_class_tparams_child(subst: SMap<A.Tparam>, child: A.Child): A.Child {
  child with {
    chi_params => child.chi_params.map(cps ->
      ext_class_tparams_class_params(subst, cps)
    ),
  }
}

fun ext_class_tparams_methods(
  subst: SMap<A.Tparam>,
  met: A.Method_def,
): A.Method_def {
  metsTparams =
    met.tparams.values().map(tp -> tp.i2.i1) |> SSet::createFromIterator;
  !subst = subst.filter((k, _) -> !metsTparams.contains(k));
  if (subst.isEmpty()) {
    met
  } else {
    met with {
      whenparams => ext_class_tparams_when_params(subst, met.whenparams),
      tparams => ext_class_tparams_tparams(subst, met.tparams),
      params => ext_class_tparams_params(subst, met.params),
      return_ => ext_class_tparams_type(subst, met.return_),
      body => ext_class_tparams_body(subst, met.body),
    }
  }
}

fun ext_class_tparams_type(subst: SMap<A.Tparam>, ty: A.Type_): A.Type_ {
  lam: (SMap<A.Tparam>, void, A.Type_) ~> (void, A.Type_) = (
    subst1: SMap<A.Tparam>,
    _: void,
    ty1: A.Type_,
  ) ~> {
    (ty1 match {
    | (pos, A.Tapply(n, tyl)) ->
      (void, (pos, A.Tapply(maybe_ext_class_tparams_ty_name(subst1, n), tyl)))
    | (pos, A.Tabstract(n, tyl)) ->
      (
        void,
        (pos, A.Tabstract(maybe_ext_class_tparams_ty_name(subst1, n), tyl)),
      )
    | _ -> (void, ty1)
    } : (void, A.Type_))
  };
  (_, ty1) = SkipAstUtils.type<SMap<A.Tparam>, void>(lam, subst, void, ty);
  ty1
}

fun ext_class_tparams_key_values(
  subst: SMap<A.Tparam>,
  x: (A.Expr, A.Expr),
): (A.Expr, A.Expr) {
  (e1, e2) = x;
  (ext_class_tparams_expr(subst, e1), ext_class_tparams_expr(subst, e2))
}

fun maybe_ext_class_tparams_ty_name(
  subst: SMap<A.Tparam>,
  x: A.Type_name,
): A.Type_name {
  x match {
  | A.Tclass(name @ (_, c)) if (subst.containsKey(c)) -> subst[c] with {name}
  | _ -> x
  }
}

fun ext_class_tparams_body(
  subst: SMap<A.Tparam>,
  m: A.Inherited_body,
): A.Inherited_body {
  (p, mb) = m;
  (p, ext_class_tparams_body_(subst, mb))
}

fun ext_class_tparams_body_(
  subst: SMap<A.Tparam>,
  x: A.Inherited_body_,
): A.Inherited_body_ {
  x match {
  | A.Inherited _ ->
    invariant_violation("ICE inherited method body before inherit")
  | A.Body(eb) -> A.Body(ext_class_tparams_expr_body(subst, eb))
  }
}

fun ext_class_tparams_expr_body(
  subst: SMap<A.Tparam>,
  x: A.Expr_body,
): A.Expr_body {
  x match {
  | A.BAlgebraic(mbl) ->
    A.BAlgebraic(ext_class_tparams_match_branches(subst, mbl))
  | A.BExpr(e) ->
    A.BExpr((context) ~> ext_class_tparams_expr(subst, e(context)))
  | A.BFrom(tn) -> A.BFrom(maybe_ext_class_tparams_ty_name(subst, tn))
  | A.BNative _
  | A.BNone() ->
    x
  }
}

fun ext_class_tparams_lam_param(
  subst: SMap<A.Tparam>,
  param: A.Lam_parameter,
): A.Lam_parameter {
  param match {
  | (nm, Some(ty)) -> (nm, Some(ext_class_tparams_type(subst, ty)))
  | _ -> param
  }
}

fun ext_class_tparams_lam_params(
  subst: SMap<A.Tparam>,
  params: Parameters<A.Lam_parameter>,
): Parameters<A.Lam_parameter> {
  params.map(lp -> ext_class_tparams_lam_param(subst, lp))
}

fun ext_class_tparams_expr(subst: SMap<A.Tparam>, ex: A.Expr): A.Expr {
  (pos, e) = ex;
  (pos, ext_class_tparams_expr_(subst, pos, e))
}

fun ext_class_tparams_expr_(
  subst: SMap<A.Tparam>,
  _pos: FileRange,
  e: A.Expr_,
): A.Expr_ {
  k = ex -> ext_class_tparams_expr(subst, ex);
  e match {
  | A.Literal _
  | A.Var _
  | A.MacroVar _ ->
    e
  | A.Seq(e1, e2) -> A.Seq(k(e1), k(e2))
  | A.If(e1, e2, e3) -> A.If(k(e1), k(e2), k(e3))
  | A.Cstr(cn, tyl) ->
    A.Cstr(cn, tyl.map(cur1 -> ext_class_tparams_type(subst, cur1)))
  | A.Call(e1, tyl, ep) ->
    A.Call(
      k(e1),
      tyl.map(cur1 -> ext_class_tparams_type(subst, cur1)),
      ext_class_tparams_call_args(subst, ep),
    )
  | A.CallArray(e1, tyl, ep) ->
    A.CallArray(
      k(e1),
      tyl.map(cur1 -> ext_class_tparams_type(subst, cur1)),
      ext_class_tparams_call_args(subst, ep),
    )
  | A.CallMap(e1, tyl, ep) ->
    A.CallMap(
      k(e1),
      tyl.map(cur1 -> ext_class_tparams_type(subst, cur1)),
      ep.map(cur1 -> ext_class_tparams_key_values(subst, cur1)),
    )
  | A.Annotated(e1, ty) -> A.Annotated(k(e1), ext_class_tparams_type(subst, ty))
  | A.Dot(e1, n) -> A.Dot(k(e1), n)
  | A.StaticDot(e1, n) -> A.StaticDot(k(e1), n)
  | A.MacroDot(e1, n) -> A.MacroDot(k(e1), n)
  | A.MacroStaticDot(e1, n) -> A.MacroStaticDot(k(e1), n)
  | A.Pipe(e1, e2) -> A.Pipe(k(e1), k(e2))
  | A.Binop(bop, e1, e2) -> A.Binop(bop, k(e1), k(e2))
  | A.Unop(uop, e1) -> A.Unop(uop, k(e1))
  | A.Is(e1, pat) -> A.Is(k(e1), ext_class_tparams_pattern(subst, pat))
  | A.As(e1, pat) -> A.As(k(e1), ext_class_tparams_pattern(subst, pat))
  | A.Match(e1, mbl) ->
    A.Match(k(e1), ext_class_tparams_match_branches(subst, mbl))
  | A.Lambda(m, p, e1) ->
    A.Lambda(m, ext_class_tparams_lam_params(subst, p), k(e1))
  | A.Tuple(el) -> A.Tuple(el.map(k))
  | A.TemplateLiteral(ep) ->
    A.TemplateLiteral(ext_class_tparams_call_args(subst, ep))
  | A.Try(e1, mbl) -> A.Try(k(e1), ext_class_tparams_match_branches(subst, mbl))
  | A.Await(e1) -> A.Await(k(e1))
  | A.Return(e1) -> A.Return(k(e1))
  | A.Yield(e1) -> A.Yield(k(e1))
  | A.YieldBreak() -> A.YieldBreak()
  | A.Async(e1) -> A.Async(k(e1))
  | A.Throw(e1) -> A.Throw(k(e1))
  | A.With(e1, args) ->
    A.With(
      k(e1),
      args.map((_, cur1) -> ext_class_tparams_ordered_expr(subst, cur1)),
    )
  | A.Bind(lv, e1, e2) ->
    A.Bind(ext_class_tparams_lvalue(subst, lv), k(e1), k(e2))
  | A.Mutable(e1) -> A.Mutable(k(e1))
  | A.Continue() -> A.Continue()
  | A.Break(eb) -> A.Break(k(eb))
  | A.Loop(eb) -> A.Loop(k(eb))
  | A.DoWhile(body, condition, withoutBreak) ->
    A.DoWhile(k(body), k(condition), k(withoutBreak))
  | A.While(condition, body, withoutBreak) ->
    A.While(k(condition), k(body), k(withoutBreak))
  | A.ForEach(binding, collection, body, withoutBreak) ->
    A.ForEach(binding, k(collection), k(body), k(withoutBreak))
  | A.ForEachFieldMacro(field, fieldName, body) ->
    A.ForEachFieldMacro(field, fieldName, k(body))
  | A.ForEachFunctionMacro(annotation, function, functionName, body) ->
    A.ForEachFunctionMacro(annotation, function, functionName, k(body))
  }
}

fun ext_class_tparams_call_args(
  subst: SMap<A.Tparam>,
  args: A.Call_args,
): A.Call_args {
  args.map(p -> ext_class_tparams_ordered_expr(subst, p))
}

fun ext_class_tparams_ordered_expr(
  subst: SMap<A.Tparam>,
  oe: A.Ordered_expr,
): A.Ordered_expr {
  (i, e) = oe;
  (i, ext_class_tparams_expr(subst, e))
}

fun ext_class_tparams_lvalue(subst: SMap<A.Tparam>, l: A.Lvalue): A.Lvalue {
  (fr, lvalue_) = l;
  lvalue_ match {
  | A.Lvalue_bind_local _ -> l
  | A.Lvalue_assign(avalue) ->
    !avalue = ext_class_tparams_lvalue_assign_value(subst, avalue);
    (fr, A.Lvalue_assign(avalue))
  | A.Lvalue_array_set(ea, el) ->
    (
      fr,
      A.Lvalue_array_set(
        ext_class_tparams_expr(subst, ea),
        ext_class_tparams_call_args(subst, el),
      ),
    )
  | A.Lvalue_tuple(lvl) ->
    !lvl = lvl.map(lv -> ext_class_tparams_lvalue(subst, lv));
    (fr, A.Lvalue_tuple(lvl))
  }
}

fun ext_class_tparams_lvalue_assign_value(
  subst: SMap<A.Tparam>,
  l: A.Lvalue_assign_value,
): A.Lvalue_assign_value {
  l match {
  | A.Lvalue_assign_local _ -> l
  | A.Lvalue_assign_field(e, n) ->
    !e = ext_class_tparams_expr(subst, e);
    A.Lvalue_assign_field(e, n)
  | A.Lvalue_assign_with(avalue, n) ->
    !avalue = ext_class_tparams_lvalue_assign_value(subst, avalue);
    A.Lvalue_assign_with(avalue, n)
  | A.Lvalue_assign_array_set(avalue, el) ->
    A.Lvalue_assign_array_set(
      ext_class_tparams_lvalue_assign_value(subst, avalue),
      ext_class_tparams_call_args(subst, el),
    )
  }
}

fun ext_class_tparams_match_branches(
  subst: SMap<A.Tparam>,
  mbl: List<A.Match_branch>,
): List<A.Match_branch> {
  mbl.map(cur1 -> ext_class_tparams_match_branch(subst, cur1))
}

fun ext_class_tparams_match_branch(
  subst: SMap<A.Tparam>,
  mb: A.Match_branch,
): A.Match_branch {
  (pats, maybe_guard, e) = mb;
  (
    pats.map(cur1 -> ext_class_tparams_pattern(subst, cur1)),
    maybe_guard.map(ex -> ext_class_tparams_expr(subst, ex)),
    ext_class_tparams_expr(subst, e),
  )
}

fun ext_class_tparams_pattern(
  subst: SMap<A.Tparam>,
  pat: A.Pattern,
): A.Pattern {
  (pos, p) = pat;
  (pos, ext_class_tparams_pattern_(subst, p))
}

fun ext_class_tparams_pattern_(
  subst: SMap<A.Tparam>,
  x: A.Pattern_,
): A.Pattern_ {
  x match {
  | A.Pat_type(tid, nparams, complete) ->
    new_tid = ext_class_tparams_tid(subst, tid);
    new_nparams = nparams.map(ps ->
      ps.map(p -> ext_class_tparams_pattern(subst, p))
    );
    A.Pat_type(new_tid, new_nparams, complete)
  | A.Pat_tuple(pats) ->
    A.Pat_tuple(pats.map(cur1 -> ext_class_tparams_pattern(subst, cur1)))
  | A.Pat_as(p, n) -> A.Pat_as(ext_class_tparams_pattern(subst, p), n)
  | A.Pat_const(ex) -> A.Pat_const(ext_class_tparams_expr(subst, ex))
  | A.Pat_var _
  | A.Pat_literal _ ->
    x
  }
}

fun ext_class_tparams_tid(
  subst: SMap<A.Tparam>,
  x: A.TypeIdentifier,
): A.TypeIdentifier {
  x match {
  | A.Tid_object(tn) -> A.Tid_object(maybe_ext_class_tparams_ty_name(subst, tn))
  | x1 @ A.Tid_static _ -> x1
  }
}

/*****************************************************************************/
/* Expanding names. */
/*****************************************************************************/
fun add_cd_to_acc(name: A.Name, cd: A.Class_def, acc: A.Program): A.Program {
  (cpos, cstr) = name;
  if (acc.type_defs.containsRawKey(cstr)) {
    (tpos, _) = acc.type_defs.getRawOrCrash(cstr);
    SkipError.errorl(
      List[
        (cpos, cstr + " was already defined as a type"),
        (tpos, "Defined here"),
      ],
    )
  };
  (class_defs, _cd) = add_cd_merge_extentions(acc.class_defs, cd);
  acc with {class_defs}
}

fun add_fun_to_acc(name: A.Name, fd: A.Fun_def, acc: A.Program): A.Program {
  (fpos, fstr) = name;
  if (acc.const_defs.containsRawKey(fstr)) {
    (cpos, _) = acc.const_defs.getRawOrCrash(fstr);
    SkipError.errorl(
      List[
        (fpos, fstr + " was already defined as a constant"),
        (cpos, "Defined here"),
      ],
    )
  };
  acc with {fun_defs => acc.fun_defs.add(name, fd)}
}

fun add_con_to_acc(name: A.Name, cd: A.Const_def, acc: A.Program): A.Program {
  (cpos, cstr) = name;
  if (acc.fun_defs.containsRawKey(cstr)) {
    (fpos, _) = acc.fun_defs.getRawOrCrash(cstr);
    SkipError.errorl(
      List[
        (cpos, cstr + " was already defined as a function"),
        (fpos, "Defined here"),
      ],
    )
  };
  acc with {const_defs => acc.const_defs.add(name, cd)}
}

fun add_tyd_to_acc(
  td_name: A.Name,
  td: A.Type_alias_def,
  acc: A.Program,
): A.Program {
  (tpos, tstr) = td_name;
  if (acc.class_defs.containsRawKey(tstr)) {
    (cpos, _) = acc.class_defs.getRawOrCrash(tstr);
    SkipError.errorl(
      List[
        (tpos, tstr + " was already defined as a class"),
        (cpos, "Defined here"),
      ],
    )
  };
  acc with {type_defs => acc.type_defs.add(td_name, td)}
}

fun module_(
  context: mutable SKStore.Context,
  env: Env,
  module_name: Module_,
  defs: Defs,
): Defs {
  env1 = env with {current_module => module_name};
  fun_defs = defs.fun_defs.map((_, cur1) -> fun_def(context, env1, cur1));
  const_defs = defs.const_defs.map((_, cur1) ->
    const_def(context, env1, None(), cur1)
  );
  type_defs = defs.type_defs.map((_, cur1) ->
    type_alias_def(context, env1, cur1)
  );
  class_defs = defs.class_defs.map((_, cur1) -> class_def(context, env1, cur1));
  Defs{def_pos => defs.def_pos, fun_defs, const_defs, type_defs, class_defs}
}

/*****************************************************************************/
/* Function definition. */
/*****************************************************************************/
fun fun_def(
  context: mutable SKStore.Context,
  env: Env,
  fd: A.Fun_def,
): A.Fun_def {
  t__ = fd;
  native_ = t__.native_;
  async_ = t__.async_;
  untracked_ = t__.untracked_;
  fun_private = t__.fun_private;
  annotations = t__.annotations;
  name = t__.name;
  tparams = t__.tparams;
  params = t__.params;
  return_ = t__.return_;
  body = t__.body;
  check_fun_privacy(env, fun_private);
  name1 = make_definition_name(env, name);
  (env1, tparams1) = type_parameters(context, env, tparams);
  (env2, params1) = fun_parameters(context, env1, None(), params);
  return_1 = type(context, env2, return_);
  body1 = body.map(ex -> (context) ~> expr(context, env2, ex(context)));
  A.Fun_def{
    annotations,
    native_,
    async_,
    untracked_,
    fun_private,
    name => name1,
    tparams => tparams1,
    params => params1,
    return_ => return_1,
    body => body1,
  }
}

/*****************************************************************************/
/* Constant definition. */
/*****************************************************************************/
fun const_def(
  context: mutable SKStore.Context,
  env: Env,
  source: ?(FileRange, String),
  con: A.Const_def,
): A.Const_def {
  t__ = con;
  annotations = t__.annotations;
  native_ = t__.native_;
  visibility = t__.visibility;
  overridable_ = t__.overridable_;
  deferred_ = t__.deferred_;
  name = t__.name;
  con_type = t__.type;
  value = t__.value;
  name1 = {
    if (source.isSome()) {
      name
    } else {
      check_const_privacy(env, visibility);
      make_definition_name(env, name)
    }
  };
  type1 = type(context, env, con_type);
  (value_pos, value_val) = value;
  value1 = {
    value_val match {
    | A.Inherited _ -> invariant_violation("ICE inherited const_def")
    | A.Body(value1) -> value1
    }
  };
  con_value1 = (
    value_pos,
    A.Body(
      (value1, native_) match {
      | (A.BNone(), None()) -> A.BNone()
      | (A.BNone(), Some(pos)) -> A.BNative(pos)
      | (A.BNative _, _) -> invariant_violation("ICE native const_def")
      | (_, Some(pos)) ->
        SkipError.error(pos, "Native constants cannot have bodies")
      | (A.BExpr(e), None()) ->
        A.BExpr((context) ~> expr(context, env, e(context)))
      | (A.BFrom(tn), None()) -> A.BFrom(type_name(context, env, tn))
      | (A.BAlgebraic _, None()) ->
        invariant_violation("ICE algebraic const_def")
      },
    ),
  );
  A.Const_def{
    annotations,
    native_,
    visibility,
    overridable_,
    deferred_,
    name => name1,
    type => type1,
    value => con_value1,
  }
}

/*****************************************************************************/
/* type_def map. */
/*****************************************************************************/
fun cla_tyd(
  context: mutable SKStore.Context,
  env: Env,
  x: A.Cla_tyd,
): A.Cla_tyd {
  x match {
  | A.TydAbstract(tyd_type, def) ->
    A.TydAbstract(
      tyd_type.map(ty -> type(context, env, ty)),
      def.map(ty -> type(context, env, ty)),
    )
  | A.TydDefined(value) -> A.TydDefined(type(context, env, value))
  }
}

fun cla_type_def(
  context: mutable SKStore.Context,
  env: Env,
  source: ?A.Name,
  tyd: A.Type_def<A.Cla_tyd>,
): A.Type_def<A.Cla_tyd> {
  t__ = tyd;
  annotations = t__.annotations;
  visibility = t__.visibility;
  name = t__.name;
  tparams = t__.tparams;
  name1 = {
    if (source.isSome()) {
      name
    } else {
      make_definition_name(env, name)
    }
  };
  (env1, tparams1) = type_parameters(context, env, tparams);
  body1 = cla_tyd(context, env1, tyd.body);
  assert(tyd.source.isNone());
  A.Cla_type_def{
    annotations,
    visibility,
    name => name1,
    tparams => tparams1,
    body => body1,
    source,
  }
}

fun type_alias(
  context: mutable SKStore.Context,
  env: Env,
  tyd_value: A.Type_,
): A.Type_ {
  type(context, env, tyd_value)
}

fun type_alias_def(
  context: mutable SKStore.Context,
  env: Env,
  tyd: A.Type_alias_def,
): A.Type_def<A.Type_> {
  t__ = tyd;
  annotations = t__.annotations;
  visibility = t__.visibility;
  name = t__.name;
  tparams = t__.tparams;
  name1 = make_definition_name(env, name);
  (env1, tparams1) = type_parameters(context, env, tparams);
  body1 = type_alias(context, env1, tyd.body);
  assert(tyd.source.isNone());
  source = None();
  A.Type_alias_def{
    annotations,
    visibility,
    name => name1,
    tparams => tparams1,
    body => body1,
    source,
  }
}

/*****************************************************************************/
/* Class definition. */
/*****************************************************************************/
fun class_def(
  context: mutable SKStore.Context,
  env: Env,
  cd: A.Class_def,
): A.Class_def {
  depth = cd.depth;
  extension = cd.extension;
  native_ = cd.native_;
  kind = cd.kind;
  value = cd.value;
  data = cd.data;
  name = cd.name;
  tparams = cd.tparams;
  params = cd.params;
  extends_ = cd.extends_;
  use = cd.use;
  consts = cd.consts;
  types = cd.types;
  methods = cd.methods;
  private_ = cd.private_;
  annotations = cd.annotations;
  mutable_ = cd.mutable_;
  check_class_privacy(env, private_);
  check_constructor(kind, params);
  name1 = make_definition_name(env, name);
  (env1, tparams1) = type_parameters(context, env, tparams);
  (env2, params1) = class_parameters(context, env1, name1, params);
  extends_1 = extend_list(context, env2, extends_);
  use1 = extend_list(context, env2, use);
  consts1 = consts.map((_, cur1) ->
    const_def(context, env2, Some(name1), cur1)
  );
  types1 = types.map((_, cur1) ->
    cla_type_def(context, env2, Some(name1), cur1)
  );
  methods1 = methods.map((_, cur1) -> method_def(context, env2, cd, cur1));
  fields = Array[];
  check_children(cd);
  A.Class_def{
    range => cd.range,
    depth,
    extension,
    native_,
    kind,
    value,
    data,
    name => name1,
    tparams => tparams1,
    params => params1,
    extends_ => extends_1,
    use => use1,
    children_ => List[],
    consts => consts1,
    types => types1,
    methods => methods1,
    private_,
    annotations,
    fields,
    mutable_,
  }
}

fun check_valid_algebraic_methods(
  acc: A.Program,
  class_defs: UMap<A.Class_def>,
): void {
  for (cur1 => cur2 in class_defs) {
    check_valid_algebraic_cd(acc.class_defs, cur1.i1, cur2)
  }
}

fun check_valid_algebraic_cd(
  classes: UMap<A.Class_def>,
  name: String,
  cd: A.Class_def,
): void {
  for (cur1 => cur2 in cd.methods) {
    check_valid_algebraic_met(classes, name, cur1.i1, cur2)
  }
}

fun check_valid_algebraic_met(
  classes: UMap<A.Class_def>,
  parent_name: String,
  _name: String,
  met: A.Method_def,
): void {
  met.body match {
  | (_, A.Body(A.BAlgebraic(mbl))) ->
    for (mb in mbl) {
      (pats, _, _) = mb;
      for (cur1 in pats) {
        check_valid_algebraic_branch(classes, parent_name, cur1)
      }
    }
  | _ -> void
  }
}

fun check_valid_algebraic_branch(
  classes: UMap<A.Class_def>,
  parent_str: String,
  x: A.Pattern,
): void {
  x match {
  | (_, A.Pat_const _) -> void
  | (_, A.Pat_var _) -> void
  | (_, A.Pat_literal _) -> void
  | (_, A.Pat_as(p, _)) -> check_valid_algebraic_branch(classes, parent_str, p)
  | (_, A.Pat_type(A.Tid_object(A.Tmodule_class _), _, _)) ->
    invariant_violation("ICE unexpanded algebraic branch")
  | (_, A.Pat_type(A.Tid_object(A.Tclass(_)), _, _)) -> void
  | (_, A.Pat_type(A.Tid_object(A.Tmacro(_)), _, _)) -> void
  | (pos, A.Pat_type(A.Tid_object(A.Tparam _), _, _)) ->
    SkipError.error(
      pos,
      "Type parameters are not valid for Algebraic method branches",
    )
  | (pos, A.Pat_type(A.Tid_static _, _, _)) ->
    SkipError.error(
      pos,
      "Type constants are not valid for Algebraic method branches",
    )
  | (_, A.Pat_tuple _) -> void
  }
}

fun check_constructor(kind: A.Class_kind, x: A.MaybeClassParams): void {
  x match {
  | A.NoParams()
  | A.NativeConstruct _ ->
    void
  | A.HasParams(cp) ->
    (kind, cp.final_) match {
    | (A.KClass(), Some(pos)) ->
      SkipError.error(pos, "Concrete classes already have final constructors")
    | (A.KTrait(), Some(pos)) ->
      SkipError.error(pos, "Traits cannot have final constructors")
    | _ -> void
    }
  }
}

/*****************************************************************************/
/* Checks that the children are defined in a base class. */
/*****************************************************************************/
fun check_children(cd: A.Class_def): void {
  (cd.kind, cd.children_) match {
  | (A.KBase(), _) -> void
  | (_, List.Nil()) -> void
  | _ -> SkipError.error(cd.name.i0, "Only a base class can define children")
  }
}

/*****************************************************************************/
/* Class children expansion. */
/*****************************************************************************/
fun child(
  context: String,
  base_class_name: A.Name,
  private_: ?FileRange,
  mutable_: ?FileRange,
  tparams: Array<A.Type_parameter>,
  chi: A.Child,
): A.Class_def {
  (_, child_name) = chi.chi_name;
  child_context = child_name + "<class>:" + context;
  unique_tparams = unique_child_tparams(child_context, tparams);
  targs = SkipAstUtils.targs_of_tparams(unique_tparams);
  extends_ = Array[
    A.Parent{
      source => base_class_name,
      parent => (A.Tclass(base_class_name), targs),
      conditions => Array[],
    },
  ];
  name = chi.chi_name;
  params = chi.chi_params match {
  | None() -> A.NoParams()
  | Some(cp) -> A.HasParams(cp)
  };
  A.Class_def{
    range => chi.chi_range,
    depth => -2,
    extension => None(),
    native_ => None(),
    kind => A.KClass(),
    value => None(),
    data => None(),
    name,
    tparams => unique_tparams,
    private_,
    params,
    extends_,
    use => Array[],
    children_ => List[],
    consts => UMap[],
    types => UMap[],
    methods => UMap[],
    annotations => chi.chi_annotations,
    fields => Array[],
    mutable_ => mutable_,
  }
}

/*****************************************************************************/
/* Type definition (defined within classes). */
/*****************************************************************************/
fun extend_list(
  context: mutable SKStore.Context,
  env: Env,
  l: Array<A.Parent>,
): Array<A.Parent> {
  l.map(cur1 -> extend_type(context, env, cur1))
}

fun type_parameters(
  context: mutable SKStore.Context,
  env: Env,
  tparams: Array<A.Type_parameter>,
): (Env, Array<A.Type_parameter>) {
  !tparams = tparams.map(tp -> {
    (!env, tp_fixed) = type_parameter(context, env, tp);
    tp_fixed
  });
  (env, tparams)
}

fun type_parameter(
  context: mutable SKStore.Context,
  env: Env,
  tp: A.Type_parameter,
): (Env, A.Type_parameter) {
  (variance, ident, name, ty) = tp;
  tparam = (
    variance,
    ident,
    name,
    ty.map((l -> l.map(cur1 -> type(context, env, cur1)))),
  );
  tparams = env.tparams.set(name.i1, tparam);
  (env with {tparams}, tparam)
}

fun when_params(
  context: mutable SKStore.Context,
  env: Env,
  wparams: Array<A.When_type_clause>,
): Array<A.When_type_clause> {
  wparams.map(wc -> {
    subtype = type(context, env, wc.i0);
    supertypes = wc.i1.map(t -> type(context, env, t));
    (subtype, supertypes)
  })
}

fun type(
  context: mutable SKStore.Context,
  env: Env,
  ty: SkipAst.Type_,
): A.Type_ {
  lam = (env1, _, ty1) -> {
    ty1 match {
    | (pos, A.Tapply(x, y)) ->
      (void, (pos, A.Tapply(type_name(context, env, x), y)))
    | (pos, A.Tabstract(n, ntl)) ->
      (void, (pos, A.Tabstract(type_name(context, env1, n), ntl)))
    | x -> (void, x)
    }
  };
  (_, ty1) = SkipAstUtils.type(lam, env, void, ty);
  ty1
}

fun type_option(
  context: mutable SKStore.Context,
  env: Env,
  x: ?A.Type_,
): ?A.Type_ {
  x match {
  | None() -> None()
  | Some(ty) -> Some(type(context, env, ty))
  }
}

fun named_type(
  context: mutable SKStore.Context,
  env: Env,
  nt: A.Named_type,
): A.Named_type {
  (tname, class_arguments) = nt;
  (
    type_name(context, env, tname),
    class_arguments.map(cur1 -> type(context, env, cur1)),
  )
}

fun extend_type(
  context: mutable SKStore.Context,
  env: Env,
  et: A.Parent,
): A.Parent {
  et with {
    parent => named_type(context, env, et.parent),
    conditions => when_params(context, env, et.conditions),
  }
}

/*****************************************************************************/
/* Binding names. */
/*****************************************************************************/
fun bind_local(env: Env, name: A.Name): Env {
  locals = env.locals.set(name.i1);
  env with {locals}
}

fun bind_locals(env: Env, names: Parameters<A.Name>): Env {
  names.foldl(bind_local, env)
}

fun bind_locals_option(env: Env, x: ?Parameters<A.Name>): Env {
  x match {
  | None() -> env
  | Some(params) -> bind_locals(env, params)
  }
}

/*****************************************************************************/
/* Class parameters. */
/*****************************************************************************/
fun class_parameters(
  context: mutable SKStore.Context,
  env: Env,
  source: A.Name,
  x: A.MaybeClassParams,
): (Env, A.MaybeClassParams) {
  x match {
  | A.NativeConstruct _
  | A.NoParams() ->
    (env, x)
  | A.HasParams(cp) ->
    (env1, params) = fun_parameters(context, env, Some(source), cp.params);
    (env1, A.HasParams(cp with {params, source => source}))
  }
}

/*****************************************************************************/
/* Function parameters. */
/*****************************************************************************/
fun fun_parameters(
  context: mutable SKStore.Context,
  env: Env,
  source: ?A.Name,
  params: Parameters<A.Parameter>,
): (Env, Parameters<A.Parameter>) {
  params1 = params.map(p -> parameter(context, env, source, p));
  names = params1.map((par: A.Parameter) -> par.name);
  env1 = bind_locals(env, names);
  (env1, params1)
}

fun parameter(
  context: mutable SKStore.Context,
  env: Env,
  source: ?A.Name,
  par: A.Parameter,
): A.Parameter {
  t__ = par;
  annotations = t__.annotations;
  visibility = t__.visibility;
  anonymous = t__.anonymous;
  mutable_ = t__.mutable_;
  name = t__.name;
  value = t__.value;
  deferred_ = t__.deferred_;
  index = t__.index;
  type1 = type(context, env, t__.type);
  value1 = value.map(ex -> expr(context, env, ex));
  assert(par.source.isNone());
  source1 = source;
  A.Parameter{
    annotations,
    visibility,
    anonymous,
    mutable_,
    name,
    type => type1,
    value => value1,
    source => source1,
    deferred_,
    index,
  }
}

/*****************************************************************************/
/* Methods. */
/*****************************************************************************/
fun method_def(
  context: mutable SKStore.Context,
  env: Env,
  cd: A.Class_def,
  met: A.Method_def,
): A.Method_def {
  visibility = met.visibility;
  macro_ = met.macro_;
  mutable_ = met.mutable_;
  async_ = met.async_;
  static_ = met.static_;
  annotations = met.annotations;
  overridable_ = met.overridable_;
  frozen_ = met.frozen_;
  readonly_ = met.readonly_;
  native_ = met.native_;
  deferred_ = met.deferred_;
  untracked_ = met.untracked_;
  name = met.name;
  whenparams = met.whenparams;
  tparams = met.tparams;
  params = met.params;
  return_ = met.return_;
  body = met.body;
  if (cd.kind != A.KBase() && deferred_.isSome()) {
    SkipError.error(
      deferred_.fromSome(),
      "deferred methods can only be declared in base classes",
    )
  };
  if (cd.kind != A.KBase() && body.i1 is A.Body(A.BAlgebraic(_))) {
    SkipError.error(
      body.i0,
      "Algebraic bodies can only be defined in base classes",
    )
  };
  check_late_static_body(deferred_, body);
  (env1, tparams1) = type_parameters(context, env, tparams);
  whenparams1 = when_params(context, env1, whenparams);
  (env2, params1) = fun_parameters(context, env1, Some(cd.name), params);
  return_1 = type(context, env2, return_);
  body1 = method_body(
    context,
    env2 with {allowMacros => met.isMacro()},
    native_,
    body,
  );
  A.Method_def{
    range => met.range,
    visibility,
    macro_,
    mutable_,
    async_,
    static_,
    annotations,
    overridable_,
    frozen_,
    readonly_,
    native_,
    deferred_,
    untracked_,
    name,
    whenparams => whenparams1,
    tparams => tparams1,
    params => params1,
    return_ => return_1,
    body => body1,
  }
}

fun method_body(
  context: mutable SKStore.Context,
  env: Env,
  sk_native: ?FileRange,
  b: A.Inherited_body,
): A.Inherited_body {
  (pos, body) = b;
  (pos, method_body_(context, env, sk_native, body))
}

fun method_body_(
  context: mutable SKStore.Context,
  env: Env,
  sk_native: ?FileRange,
  x: A.Inherited_body_,
): A.Inherited_body_ {
  x match {
  | A.Inherited _ ->
    invariant_violation("ICE inherited met body before inherit")
  | A.Body(mb) -> A.Body(method_body__(context, env, sk_native, mb))
  }
}

fun method_body__(
  context: mutable SKStore.Context,
  env: Env,
  sk_native: ?FileRange,
  body: A.Expr_body,
): A.Expr_body {
  (body, sk_native) match {
  | (A.BNone(), None()) -> A.BNone()
  | (A.BNone(), Some(pos)) -> A.BNative(pos)
  | (A.BNative _, _) ->
    invariant_violation("ICE native met body without native mod")
  | (_, Some(pos)) ->
    SkipError.error(pos, "Native constants cannot have bodies")
  | (A.BExpr(e), None()) -> A.BExpr((context) ~> expr(context, env, e(context)))
  | (A.BFrom(tn), None()) -> A.BFrom(type_name(context, env, tn))
  | (A.BAlgebraic(mbl), None()) ->
    A.BAlgebraic(mbl.map(cur1 -> match_branch(context, env, cur1)))
  }
}

fun check_late_static_body(
  deferred_: ?FileRange,
  body: A.Inherited_body,
): void {
  (deferred_, body.i1) match {
  | (Some(pos), A.Body(A.BAlgebraic _)) ->
    SkipError.error(pos, "deferred is meaningless on algebraic functions")
  | _ -> void
  }
}

/*****************************************************************************/
/* Expressions. */
/*****************************************************************************/

// ported from recursive version to avoid stack overflows
// on long chains of A.Bind and A.Seq
//
fun expr(context: mutable SKStore.Context, env_: Env, ex_: A.Expr): A.Expr {
  kids = e ->
    e match {
    | (_, A.Bind _)
    | (_, A.Seq _) ->
      true
    | _ -> false
    };
  init = ExprState{env => env_, stack => List[], expr => ex_, child => false};
  cycle(init, state -> {
    if (state.child == kids(state.expr)) {
      f = state.expr match {
      | (_, A.Bind _)
      | (_, A.Seq _) ->
        state.expr
      | (pos, e_) -> (pos, expr_(context, state.env, pos, e_))
      };
      state.stack match {
      | List.Nil() -> Cycle.Done(f)
      | List.Cons(((pos, A.Bind(lv, _, c2)), false), tl) ->
        (env, !lv) = lvalue(context, state.env, lv);
        bind = (pos, A.Bind(lv, f, c2));
        stack = List.Cons((bind, true), tl);
        Cycle.Next(ExprState{env, stack, expr => c2, child => false})
      | List.Cons(((pos, A.Seq(_, c2)), false), tl) ->
        seq = (pos, A.Seq(f, c2));
        stack = List.Cons((seq, true), tl);
        Cycle.Next(state with {stack, expr => c2, child => false})
      | List.Cons(((pos, A.Bind(lv, c1, _)), true), tl) ->
        bind = (pos, A.Bind(lv, c1, f));
        Cycle.Next(state with {stack => tl, expr => bind, child => true})
      | List.Cons(((pos, A.Seq(c1, _)), true), tl) ->
        seq = (pos, A.Seq(c1, f));
        Cycle.Next(state with {stack => tl, expr => seq, child => true})
      | _ -> invariant_violation("unexpected stack configuration (1)")
      }
    } else {
      (state.expr, state.child) match {
      | ((_, A.Bind(_, c1, _)), false) ->
        Cycle.Next(
          state with {
            stack => List.Cons((state.expr, false), state.stack),
            expr => c1,
            child => false,
          },
        )
      | ((_, A.Seq(c1, _)), false) ->
        Cycle.Next(
          state with {
            stack => List.Cons((state.expr, false), state.stack),
            expr => c1,
            child => false,
          },
        )
      | _ -> invariant_violation("unexpected stack configuration (2)")
      }
    }
  })
}

fun expr_(
  context: mutable SKStore.Context,
  env: Env,
  pos: FileRange,
  x: A.Expr_,
): A.Expr_ {
  x match {
  | A.Literal _ -> x
  | A.MacroVar(name) -> A.MacroVar(name)
  | A.Var(name) -> A.Var(var_name(context, env, name))
  | A.Cstr(name, tyl) ->
    if (tyl.isEmpty() && is_const_cstr(context, env, pos, name)) {
      A.Var(var_name(context, env, name))
    } else {
      A.Cstr(
        cstr_name(context, env, name),
        tyl.map(cur1 -> type(context, env, cur1)),
      )
    }
  | A.Seq _ -> invariant_violation("ICE seq covered in expand expr")
  | A.If(e1, e2, e3) ->
    A.If(expr(context, env, e1), expr(context, env, e2), expr(context, env, e3))
  | A.Call(e, tyl, params) ->
    A.Call(
      expr(context, env, e),
      tyl.map(cur1 -> type(context, env, cur1)),
      call_args(context, env, params),
    )
  | A.CallArray(e, tyl, params) ->
    A.CallArray(
      expr(context, env, e),
      tyl.map(cur1 -> type(context, env, cur1)),
      call_args(context, env, params),
    )
  | A.CallMap(e, tyl, params) ->
    A.CallMap(
      expr(context, env, e),
      tyl.map(cur1 -> type(context, env, cur1)),
      params.map(cur1 -> key_values(context, env, cur1)),
    )
  | A.Annotated(e, ty) ->
    A.Annotated(expr(context, env, e), type(context, env, ty))
  | A.Bind _ -> invariant_violation("ICE bind covered in expand expr")
  | A.Dot(e @ (_, A.Dot((pos2, A.Cstr(cname, tyl)), cname2)), field_name) ->
    if (is_module(context, env, cname2)) {
      check_module(context, env, cname, cname2);
      expanded_name = make_dotted_name(env, pos, cname, cname2);
      tyl1 = tyl.map(cur1 -> type(context, env, cur1));
      expr_(
        context,
        env,
        pos,
        A.Dot((pos2, A.Cstr(expanded_name, tyl1)), field_name),
      )
    } else {
      A.Dot(expr(context, env, e), field_name)
    }
  | A.Dot(e @ (_, A.Cstr(cname, tyl)), field_name) ->
    tyl1 = tyl.map(cur1 -> type(context, env, cur1));
    SkipError.doWithError(() ->
      check_module(context, env, cname, field_name)
    ) match {
    | Success _ ->
      expanded_name = make_dotted_name(env, pos, cname, field_name);
      if (
        is_uppercase(field_name) &&
        !is_const_name(context, env, cname, field_name)
      ) {
        A.Cstr(expanded_name, tyl1)
      } else {
        A.Var(expanded_name)
      }
    | Failure(errors) ->
      (_, cname_str) = cname;
      if (current_defs_names(context, env).containsClass(cname_str)) {
        // Don't error out if there is a class by the same name in scope
        // so as to produce clearer error messages
        A.Dot(expr(context, env, e), field_name)
      } else {
        throw SkipError.SkipErrorException{errors}
      }
    }
  | A.Dot(e, n) -> A.Dot(expr(context, env, e), n)
  | A.StaticDot(e, n) -> A.StaticDot(expr(context, env, e), n)
  | A.MacroDot(e, n) -> A.MacroDot(expr(context, env, e), n)
  | A.MacroStaticDot(e, n) -> A.MacroStaticDot(expr(context, env, e), n)
  | A.Pipe(e1, e2) -> A.Pipe(expr(context, env, e1), expr(context, env, e2))
  | A.Binop(bop, e1, e2) ->
    A.Binop(bop, expr(context, env, e1), expr(context, env, e2))
  | A.Unop(uop, e) -> A.Unop(uop, expr(context, env, e))
  | A.Is(e1, pat) -> A.Is(expr(context, env, e1), pattern(context, env, pat).i1)
  | A.As(e1, pat) -> A.As(expr(context, env, e1), pattern(context, env, pat).i1)
  | A.Match(e, mbl) ->
    A.Match(
      expr(context, env, e),
      mbl.map(cur1 -> match_branch(context, env, cur1)),
    )
  | A.Lambda(mods, params, e) ->
    names = params.map(p -> p.i0);
    params1 = params.map(p -> {
      (n, ty_opt) = p;
      (n, ty_opt.map(ty -> type(context, env, ty)))
    });
    env1 = bind_locals(env, names);
    A.Lambda(mods, params1, expr(context, env1, e))
  | A.Tuple(el) -> A.Tuple(el.map(cur1 -> expr(context, env, cur1)))
  | A.TemplateLiteral(params) ->
    A.TemplateLiteral(call_args(context, env, params))
  | A.Try(e, mbl) ->
    A.Try(
      expr(context, env, e),
      mbl.map(cur1 -> match_branch(context, env, cur1)),
    )
  | A.Await(e) -> A.Await(expr(context, env, e))
  | A.Return(e) -> A.Return(expr(context, env, e))
  | A.Yield(e) -> A.Yield(expr(context, env, e))
  | A.YieldBreak() -> A.YieldBreak()
  | A.Async(e) -> A.Async(expr(context, env, e))
  | A.Throw(e) -> A.Throw(expr(context, env, e))
  | A.With(e, updates) ->
    A.With(
      expr(context, env, e),
      updates.map((_, cur1) -> ordered_expr(context, env, cur1)),
    )
  | A.Mutable(e) -> A.Mutable(expr(context, env, e))
  | A.Continue() -> A.Continue()
  | A.Break(eb) -> A.Break(expr(context, env, eb))
  | A.Loop(eb) -> A.Loop(expr(context, env, eb))
  | A.DoWhile(body, condition, withoutBreak) ->
    A.DoWhile(
      expr(context, env, body),
      expr(context, env, condition),
      expr(context, env, withoutBreak),
    )
  | A.While(condition, body, withoutBreak) ->
    A.While(
      expr(context, env, condition),
      expr(context, env, body),
      expr(context, env, withoutBreak),
    )
  | A.ForEach(binding, collection, body, withoutBreak) ->
    fenv = forEachBinding(env, binding);
    A.ForEach(
      binding,
      expr(context, env, collection),
      expr(context, fenv, body),
      expr(context, env, withoutBreak),
    )
  | A.ForEachFieldMacro(field, fieldName, body) ->
    A.ForEachFieldMacro(field, fieldName, expr(context, env, body))
  | A.ForEachFunctionMacro(annotation, function, functionName, body) ->
    A.ForEachFunctionMacro(
      annotation,
      function,
      functionName,
      expr(context, env, body),
    )
  }
}

fun key_values(
  context: mutable SKStore.Context,
  env: Env,
  x: (A.Expr, A.Expr),
): (A.Expr, A.Expr) {
  (e1, e2) = x;
  (expr(context, env, e1), expr(context, env, e2))
}

fun call_args(
  context: mutable SKStore.Context,
  env: Env,
  args: A.Call_args,
): A.Call_args {
  args.map(oe -> ordered_expr(context, env, oe))
}

fun ordered_expr(
  context: mutable SKStore.Context,
  env: Env,
  oe: A.Ordered_expr,
): A.Ordered_expr {
  (i, e) = oe;
  (i, expr(context, env, e))
}

fun lvalue(
  context: mutable SKStore.Context,
  env: Env,
  l: A.Lvalue,
): (Env, A.Lvalue) {
  (fr, lvalue_) = l;
  lvalue_ match {
  | A.Lvalue_bind_local(name) -> (bind_local(env, name), l)
  | A.Lvalue_assign(avalue) ->
    !avalue = lvalue_assign_value(context, env, avalue);
    (env, (fr, A.Lvalue_assign(avalue)))
  | A.Lvalue_array_set(ea, el) ->
    !ea = expr(context, env, ea);
    (env, (fr, A.Lvalue_array_set(ea, call_args(context, env, el))))
  | A.Lvalue_tuple(lvl) ->
    (!env, !lvl) = lvl.mapAcc((x, y) -> lvalue(context, x, y), env);
    (env, (fr, A.Lvalue_tuple(lvl)))
  }
}

fun lvalue_assign_value(
  context: mutable SKStore.Context,
  env: Env,
  l: A.Lvalue_assign_value,
): A.Lvalue_assign_value {
  l match {
  | A.Lvalue_assign_local _ -> l
  | A.Lvalue_assign_field(e, n) ->
    !e = expr(context, env, e);
    A.Lvalue_assign_field(e, n)
  | A.Lvalue_assign_with(avalue, n) ->
    !avalue = lvalue_assign_value(context, env, avalue);
    A.Lvalue_assign_with(avalue, n)
  | A.Lvalue_assign_array_set(avalue, el) ->
    !avalue = lvalue_assign_value(context, env, avalue);
    A.Lvalue_assign_array_set(avalue, call_args(context, env, el))
  }
}

fun forEachBinding(env: Env, fb: A.ForEachBinding): Env {
  fb match {
  | A.FEKeyed(key, value, _) ->
    !env = bind_local(env, key);
    bind_local(env, value)
  | A.FEIdent(name, _) -> bind_local(env, name)
  | A.FETuple(idents, _) ->
    idents.foldl((fenv, ident) -> bind_local(fenv, ident), env)
  }
}

fun match_branch(
  context: mutable SKStore.Context,
  env: Env,
  mb: A.Match_branch,
): A.Match_branch {
  (pats, maybe_guard, e) = mb;
  (env1, pats1) = pats.map_foldl((x, y) -> pattern(context, x, y), env);
  (
    pats1,
    maybe_guard.map(ex -> expr(context, env1, ex)),
    expr(context, env1, e),
  )
}

fun pattern(
  context: mutable SKStore.Context,
  env: Env,
  pat: A.Pattern,
): (Env, A.Pattern) {
  (pos, p) = pat;
  (env1, p1) = pattern_(context, env, p);
  (env1, (pos, p1))
}

fun pattern_(
  context: mutable SKStore.Context,
  env: Env,
  x: A.Pattern_,
): (Env, A.Pattern_) {
  x match {
  | A.Pat_const(ex) -> (env, A.Pat_const(expr(context, env, ex)))
  | x1 @ A.Pat_var(name) -> (bind_local(env, name), x1)
  | x1 @ A.Pat_literal _ -> (env, x1)
  | A.Pat_type(tid, args, complete) ->
    (env1, args1) = pattern_arguments_opt(context, env, args);
    (env1, A.Pat_type(type_identifier(context, env1, tid), args1, complete))
  | A.Pat_tuple(pats) ->
    (env1, pats1) = pats.mapAcc((x, y) -> pattern(context, x, y), env);
    (env1, A.Pat_tuple(pats1))
  | A.Pat_as(p, n) ->
    (env1, p1) = pattern(context, env, p);
    env2 = bind_local(env1, n);
    (env2, A.Pat_as(p1, n))
  }
}

fun type_identifier(
  context: mutable SKStore.Context,
  env: Env,
  x: A.TypeIdentifier,
): A.TypeIdentifier {
  x match {
  | A.Tid_object(tn) -> A.Tid_object(type_name(context, env, tn))
  | tid @ A.Tid_static _ -> tid
  }
}

fun pattern_arguments_opt(
  context: mutable SKStore.Context,
  env: Env,
  x: ?Parameters<A.Pattern>,
): (Env, ?Parameters<A.Pattern>) {
  x match {
  | None() -> (env, None())
  | Some(args) ->
    (env1, args1) = pattern_arguments(context, env, args);
    (env1, Some(args1))
  }
}

fun pattern_arguments(
  context: mutable SKStore.Context,
  env: Env,
  pats: Parameters<A.Pattern>,
): (Env, Parameters<A.Pattern>) {
  pats.map_foldl((x, y) -> pattern(context, x, y), env)
}

module end;
