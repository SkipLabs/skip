/*****************************************************************************/
/* Eager directories. */
/*****************************************************************************/
module SKFS;

/*****************************************************************************/
/* Constants. */
/*****************************************************************************/

const PURGE_LIMIT: Int = 30;

/*****************************************************************************/
/* We need to be able to iterate after a given starting point. This method
 * should be in SortedMap.sk but I will move it in a separate diff, because
 * otherwise I force everyone to recompile the compiler.
 */
/*****************************************************************************/

mutable class Items<T>(data: mutable Iterator<T>) {
  static fun create(data: mutable Iterator<T>): mutable this {
    mutable static(data)
  }
  mutable fun items(): mutable Iterator<T> {
    this.data
  }
}

extension base class .SortedMap {
  fun itemsAfter<K2: Orderable, V2>[K: K2, V: V2](
    start: ?K2,
  ): mutable Iterator<(K2, V2)> {
    this match {
    | SortedMap.Nil() -> void
    | SortedMap.Node{key, value, left, right} ->
      if (
        start match {
        | None() -> true
        | Some(x) -> key >= x
        }
      ) {
        for (x in left.itemsAfter(start)) {
          yield x;
        };
        yield (key, value);
      };
      for (x in right.itemsAfter(start)) {
        yield x;
      }
    }
  }
}

/*****************************************************************************/
/* The signature of a function used by apply. */
/*****************************************************************************/

type MapFun = (
  mutable Context,
  mutable Writer,
  BaseName,
  mutable Iterator<File>,
) ~> void;

/*****************************************************************************/
/* The action passed to aggregate functions. */
/*****************************************************************************/

value class Aggregate(state: File, reducer: IReducer)

/*****************************************************************************/
/* Compaction types and helpers. */
/*****************************************************************************/

class Reducer{
  reducer: IReducer,
  fixed: Array<(BaseName, Array<File>)>,
  modified: SortedMap<BaseName, Array<File>>,
} {
  static fun create(fixedData: FixedDataMap, reducer: IReducer): this {
    acc = mutable Vector[];
    modified = SortedMap[];
    current = mutable IntRef(0);
    while (current.value < fixedData.data.size()) {
      key = fixedData.data[current.value].key;
      iterator = static::makeCompactKeyIterator(
        fixedData.data,
        key,
        current,
      ).iterator();
      acc.push((key, reducer.init(iterator)));
    };
    fixed = acc.toArray();
    static{reducer, fixed, modified}
  }

  fun unsafeIter(
    start: ?BaseName = None(),
  ): mutable Iterator<(BaseName, mutable Iterator<File>)> {
    current = mutable IntRef(
      start match {
      | None() -> 0
      | Some(key) ->
        pos = binSearch(i ~> this.fixed[i].i0, key, 0, this.fixed.size() - 1);
        if (pos < 0) 0 else pos
      },
    );
    for (key => values in Items::create(this.modified.itemsAfter(start))) {
      while (
        current.value < this.fixed.size() &&
        this.fixed[current.value].i0 < key
      ) {
        fixedKey = this.fixed[current.value].i0;
        fixedFiles = this.fixed[current.value].i1;
        yield (fixedKey, fixedFiles.iterator());
        current.incr();
      };
      while (
        current.value < this.fixed.size() &&
        this.fixed[current.value].i0 == key
      ) {
        current.incr();
      };
      yield (key, values.iterator());
    };
    while (current.value < this.fixed.size()) {
      fixedKey = this.fixed[current.value].i0;
      fixedFiles = this.fixed[current.value].i1;
      yield (fixedKey, fixedFiles.iterator());
      current.incr();
    };
  }

  static fun makeCompactKeyIterator(
    fixedData: FixedData<Array<File>>,
    key: BaseName,
    current: mutable IntRef,
  ): Array<File> {
    result = mutable Vector[];
    while (
      current.value < fixedData.size() &&
      fixedData[current.value].key == key
    ) {
      for (file in fixedData[current.value].value.i1) {
        result.push(file);
      };
      current.incr();
    };
    x = result.toArray();
    x
  }

  fun getArray(key: BaseName): Array<File> {
    this.modified.maybeGet(key) match {
    | None() -> this.getFixedij(key, 0, this.fixed.size() - 1)
    | Some(values) -> values
    }
  }

  private fun getFixedij(key: BaseName, i: Int, j: Int): Array<File> {
    if (i > j) {
      return Array[];
    };
    pivot = i + (j - i) / 2;
    key.compare(this.fixed[pivot].i0) match {
    | LT() -> this.getFixedij(key, i, pivot - 1)
    | EQ() -> this.fixed[pivot].i1
    | GT() -> this.getFixedij(key, pivot + 1, j)
    }
  }

  fun getFixed(key: BaseName): Array<File> {
    this.getFixedij(key, 0, this.fixed.size() - 1)
  }
}

class IReducer{
  init: (mutable Iterator<File> ~> Array<File>),
  update: (Array<File>, Array<File>, Array<File>) ~> ?Array<File>,
}

mutable class IntRef(mutable value: Int) {
  mutable fun incr(): void {
    this.!value = this.value + 1
  }
}

/*****************************************************************************/
/* Ranges. */
/*****************************************************************************/

value class KeyRange(start: BaseName, end: BaseName) uses Orderable, Show {
  fun toString(): String {
    `[${this.start}, ${this.end}]`
  }
}

/*****************************************************************************/
/* Keys and newDirs produced during a mapping. */
/*****************************************************************************/

base class MInfo {
  children =
  | MInfoEmpty()
  | MInfoSingle(BaseName)
  | MInfoFull(Array<BaseName>, Array<DirName>, Array<Path>)

  fun getKeys(): Array<BaseName> {
    this match {
    | MInfoEmpty() -> Array[]
    | MInfoSingle(x) -> Array[x]
    | MInfoFull(keys, _, _) -> keys
    }
  }

  fun getNewDirs(): Array<DirName> {
    this match {
    | MInfoEmpty() -> Array[]
    | MInfoSingle(_) -> Array[]
    | MInfoFull(_, dirs, _) -> dirs
    }
  }
  fun getReads(): Array<Path> {
    this match {
    | MInfoEmpty() -> Array[]
    | MInfoSingle(_) -> Array[]
    | MInfoFull(_, _, reads) -> reads
    }
  }

  static fun create(
    keys: Array<BaseName>,
    newDirs: Array<DirName>,
    reads: Array<Path>,
  ): MInfo {
    if (keys.isEmpty() && newDirs.isEmpty() && reads.isEmpty()) {
      return MInfoEmpty()
    };
    if (keys.size() == 1) return MInfoSingle(keys[0]);
    MInfoFull(keys, newDirs, reads)
  }

  static fun empty(): MInfo {
    MInfoEmpty()
  }

  fun isEmpty(): Bool {
    this is MInfoEmpty()
  }

  fun setNewDirs(newDirs: Array<DirName>): MInfo {
    this match {
    | MInfoEmpty() ->
      if (newDirs.isEmpty()) return this;
      MInfoFull(Array[], newDirs, Array[])
    | MInfoSingle(key) ->
      if (newDirs.isEmpty()) return this;
      MInfoFull(Array[key], newDirs, Array[])
    | MInfoFull(keys, _, reads) -> static::create(keys, newDirs, reads)
    }
  }
}

/*****************************************************************************/
/* The class used for subscriptions. */
/*****************************************************************************/

@cpp_extern("SKIP_notify")
native fun unixNotify(String, Int32): Int32;

/*****************************************************************************/
/* The map containing the new data. */
/*****************************************************************************/

class DataMapValue{
  map: DMap<Source, Array<File>> = DMap::empty(),
  tombs: DMap<Source, Source> = DMap::empty(),
} {
  static fun empty(): this {
    static{}
  }

  fun isEmpty(): Bool {
    this.map.isEmpty() && this.tombs.isEmpty()
  }

  fun set(
    tick: Tick,
    isMasking: Bool,
    origSource: Source,
    writer: Source, // different to origSource when explicitly tombstoning
    files: Array<File>,
  ): this {
    invariant(files.isEmpty() || origSource == writer);
    if (files.isEmpty()) {
      if (isMasking) {
        // mask out fixed data, for when you're iterating without tombs.
        !this.map = this.map.set(TickRange::create(tick), origSource, files)
      } else {
        this.map.maybeGet(origSource) match {
        | None() -> void
        | Some _ -> !this.map = this.map.remove(origSource)
        };
      };
      !this.tombs = this.tombs.set(TickRange::create(tick), origSource, writer);
    } else {
      if (this.tombs.containsKey(origSource)) {
        !this.tombs = this.tombs.remove(origSource)
      };
      !this.map = this.map.set(TickRange::create(tick), origSource, files);
    };
    this
  }

  fun itemsAfter(
    limit: Tick,
  ): mutable Iterator<(Tick, Source, Source, Array<File>)> {
    mapIter = this.map.getChangesAfterIter(limit);
    tombsIter = this.tombs.getChangesAfterIter(limit);
    left = mapIter.next();
    right = tombsIter.next();
    loop {
      (left, right) match {
      | (None(), None()) -> break void
      | (None(), Some((tick, v, w))) ->
        yield (tick, v, w, Array[]);
        !right = tombsIter.next()
      | (Some((tick, k, v)), None()) ->
        yield (tick, k, k, v);
        !left = mapIter.next()
      | (Some((tick, k, v)), Some((_, k2, _))) if (k < k2) ->
        yield (tick, k, k, v);
        !left = mapIter.next()
      | (Some((t1, k1, _)), Some((t2, k2, w))) if (k1 == k2 && t1 == t2) ->
        yield (t2, k2, w, Array[]);
        !left = mapIter.next();
        !right = tombsIter.next()
      | (Some(_), Some((tick, k2, w))) ->
        yield (tick, k2, w, Array[]);
        !right = tombsIter.next()
      }
    }
  }

  fun items(): mutable Iterator<((Tick, Source, Source), Array<File>)> {
    mapIter = this.map.itemsWithTick();
    tombsIter = this.tombs.itemsWithTick();
    left = mapIter.next();
    right = tombsIter.next();
    loop {
      (left, right) match {
      | (None(), None()) -> break void
      | (None(), Some((v, w, tick))) ->
        yield ((tick.current, v, w), Array[]);
        !right = tombsIter.next()
      | (Some((k, v, tick)), None()) ->
        yield ((tick.current, k, k), v);
        !left = mapIter.next()
      | (Some((k, v, tick)), Some((k2, w, _))) if (k < k2) ->
        yield ((tick.current, k, w), v);
        !left = mapIter.next()
      | (Some((k, v, tick)), Some((k2, w, _))) if (k == k2) ->
        yield ((tick.current, k, w), v);
        !left = mapIter.next();
        !right = tombsIter.next()
      | (Some(_), Some((k2, w, tick))) ->
        yield ((tick.current, k2, w), Array[]);
        !right = tombsIter.next()
      }
    }
  }

  fun maybeGet(source: Source): ?Array<File> {
    this.map.maybeGet(source) match {
    | None() -> if (this.tombs.containsKey(source)) Some(Array[]) else None()
    | x @ Some(_) -> x
    }
  }
}

class DataMap{
  data: DMap<BaseName, DMap<Source, Array<File>>> = Nil(),
  tombs: DMap<BaseName, DMap<Source, Source>> = Nil(),
  nbrEntries: Int = 0,
} {
  static fun empty(): this {
    DataMap{}
  }

  fun set(tickRange: TickRange, key: BaseName, value: DataMapValue): this {
    if (value.map.isEmpty()) {
      if (this.data.containsKey(key)) {
        !this.data = this.data.remove(key)
      }
    } else {
      if (!this.data.containsKey(key)) {
        !this.nbrEntries = this.nbrEntries + 1;
      };
      !this.data = this.data.set(tickRange, key, value.map)
    };
    if (value.tombs.isEmpty()) {
      if (this.tombs.containsKey(key)) {
        !this.tombs = this.tombs.remove(key);
      }
    } else {
      if (!this.tombs.containsKey(key)) {
        !this.nbrEntries = this.nbrEntries + 1;
      };
      !this.tombs = this.tombs.set(tickRange, key, value.tombs);
    };
    this
  }

  fun maybeGet(k: BaseName): ?DataMapValue {
    (this.data.maybeGet(k), this.tombs.maybeGet(k)) match {
    | (None(), None()) -> None()
    | (Some(map), None()) -> Some(DataMapValue{map, tombs => DMap::empty()})
    | (None(), Some(tombs)) -> Some(DataMapValue{map => DMap::empty(), tombs})
    | (Some(map), Some(tombs)) -> Some(DataMapValue{map, tombs})
    }
  }

  fun getTick(): ?Tick {
    optFTick = this.tombs.getLastTick();
    optDTick = this.data.getLastTick();
    (optFTick, optDTick) match {
    | (None(), None()) -> None()
    | (Some(t), None())
    | (None(), Some(t)) ->
      Some(t)
    | (Some(ft), Some(dt)) -> Some(max(ft, dt))
    }
  }

  fun eachWithTick(f: (BaseName, Tick) -> void): void {
    dataIter = this.data.itemsWithTick();
    tombsIter = this.tombs.itemsWithTick();
    left = dataIter.next();
    right = tombsIter.next();
    loop {
      (left, right) match {
      | (None(), None()) -> break void
      | (Some((k, _, tick)), None()) ->
        f(k, tick.current);
        !left = dataIter.next()
      | (None(), Some((k, _, tick))) ->
        f(k, tick.current);
        !right = tombsIter.next()
      | (Some((k1, _, tick)), Some((k2, _, _))) if (k1 < k2) ->
        f(k1, tick.current);
        !left = dataIter.next()
      | (Some((k1, _, _)), Some((k2, _, tick))) if (k1 > k2) ->
        f(k2, tick.current);
        !right = tombsIter.next()
      | (Some((k, _, tick1)), Some((_, _, tick2))) ->
        invariant(tick1.current == tick2.current);
        f(k, tick1.current);
        !left = dataIter.next();
        !right = tombsIter.next()
      }
    }
  }

  fun getChangesAfter(tick: Tick): SortedSet<BaseName> {
    this.data.getChangesAfter(tick).union(this.tombs.getChangesAfter(tick))
  }

  fun items(): mutable Iterator<(BaseName, DataMapValue)> {
    dataIter = this.data.itemsWithTick();
    tombsIter = this.tombs.itemsWithTick();
    left = dataIter.next();
    right = tombsIter.next();
    loop {
      (left, right) match {
      | (None(), None()) -> break void
      | (Some((k, map, _)), None()) ->
        yield (k, DataMapValue{map, tombs => DMap::empty()});
        !left = dataIter.next()
      | (None(), Some((k, tombs, _))) ->
        yield (k, DataMapValue{map => DMap::empty(), tombs});
        !right = tombsIter.next()
      | (Some((k1, map, _)), Some((k2, _, _))) if (k1 < k2) ->
        yield (k1, DataMapValue{map, tombs => DMap::empty()});
        !left = dataIter.next()
      | (Some((k1, _, _)), Some((k2, tombs, _))) if (k1 > k2) ->
        yield (k2, DataMapValue{map => DMap::empty(), tombs});
        !right = tombsIter.next()
      | (Some((k, map, _)), Some((_, tombs, _))) ->
        yield (k, DataMapValue{map, tombs});
        !left = dataIter.next();
        !right = tombsIter.next()
      }
    }
  }

  fun itemsAfterKeyHelper(
    lastSkippedOpt: ?Boundary<BaseName>,
  ): mutable Iterator<(BaseName, DMap<Source, Array<File>>)> {
    this.data.itemsAfterKey(lastSkippedOpt).iter
  }

  fun itemsAfterKey(
    lastSkippedOpt: ?Boundary<BaseName>,
  ): mutable IterHolder<BaseName, DMap<Source, Array<File>>> {
    mutable IterHolder(this.itemsAfterKeyHelper(lastSkippedOpt))
  }

  fun getHeight(): Int {
    this.data.getHeight()
  }

  fun remove(k: BaseName): this {
    !this.data = this.data.remove(k);
    !this.tombs = this.tombs.remove(k);
    this
  }
}

class FixedDataMap{data: FixedDir<Array<File>>, tombs: FixedDir<Source>} {
  static fun create(
    vec: mutable Vector<FixedRow<Array<File>>> = mutable Vector[],
    tombs: mutable Vector<FixedRow<Source>> = mutable Vector[],
  ): this {
    static{data => FixedDir::create(vec), tombs => FixedDir::create(tombs)}
  }

  fun size(): Int {
    this.data.size() + this.tombs.size()
  }

  fun getTick(): ?Tick {
    optFTick = this.tombs.getTick();
    optDTick = this.data.getTick();
    (optFTick, optDTick) match {
    | (None(), None()) -> None()
    | (Some(t), None())
    | (None(), Some(t)) ->
      Some(t)
    | (Some(ft), Some(dt)) -> Some(max(ft, dt))
    }
  }

  fun getChangesAfter(tick: Tick): SortedSet<BaseName> {
    this.data.getChangesAfter(tick).union(this.tombs.getChangesAfter(tick))
  }

  fun getIterAll(): mutable Iterator<
    (Tick, Source, Source, BaseName, Array<File>),
  > {
    iter1 = this.data.data.iterator();
    iter2 = this.tombs.data.iterator();
    left = iter1.next();
    right = iter2.next();
    loop {
      (left, right) match {
      | (None(), None()) -> break void
      | (Some(x), None()) ->
        !left = iter1.next();
        yield (x.tag.current, x.value.i0, x.value.i0, x.key, x.value.i1)
      | (None(), Some(y)) ->
        !right = iter2.next();
        yield (y.tag.current, y.value.i0, y.value.i1, y.key, Array[])
      | (Some(x), Some(y)) ->
        if ((x.key, x.value.i0) < (y.key, y.value.i0)) {
          !left = iter1.next();
          yield (x.tag.current, x.value.i0, x.value.i0, x.key, x.value.i1)
        } else if ((x.key, x.value.i0) > (y.key, y.value.i0)) {
          !right = iter2.next();
          yield (y.tag.current, y.value.i0, y.value.i1, y.key, Array[])
        } else {
          invariant_violation("Found a non-empty tomb (getIterAll)");
        }
      }
    }
  }

  fun getIter(
    key: BaseName,
  ): mutable Iterator<(Tick, Source, Source, Array<File>)> {
    iter1 = this.data.getIter(key);
    iter2 = this.tombs.getIter(key);
    left = iter1.next();
    right = iter2.next();
    loop {
      (left, right) match {
      | (None(), None()) -> break void
      | (Some(x), None()) ->
        !left = iter1.next();
        yield (x.i0, x.i1, x.i1, x.i2)
      | (None(), Some(y)) ->
        !right = iter2.next();
        yield (y.i0, y.i1, y.i2, Array[])
      | (Some(x), Some(y)) ->
        if (x.i1 < y.i1) {
          !left = iter1.next();
          yield (x.i0, x.i1, x.i1, x.i2)
        } else if (x.i1 > y.i1) {
          !right = iter2.next();
          yield (y.i0, y.i1, y.i2, Array[])
        } else {
          invariant_violation("Found a non-empty tomb (getIter)");
        }
      }
    }
  }

  fun getIterAfter(
    tick: Tick,
    key: BaseName,
  ): mutable Iterator<(Tick, Source, Source, Array<File>)> {
    iter1 = this.data.getIterAfter(tick, key);
    iter2 = this.tombs.getIterAfter(tick, key);
    left = iter1.next();
    right = iter2.next();
    loop {
      (left, right) match {
      | (None(), None()) -> break void
      | (Some(x), None()) ->
        !left = iter1.next();
        yield (x.i0, x.i1, x.i1, x.i2)
      | (None(), Some(y)) ->
        !right = iter2.next();
        yield (y.i0, y.i1, y.i2, Array[])
      | (Some(x), Some(y)) ->
        if (x.i1 < y.i1) {
          !left = iter1.next();
          yield (x.i0, x.i1, x.i1, x.i2)
        } else if (x.i1 > y.i1) {
          !right = iter2.next();
          yield (y.i0, y.i1, y.i2, Array[])
        } else {
          invariant_violation("Found a non-empty tomb (getIterAfter)");
        }
      }
    }
  }
}

mutable class FixedDataMapIterator<T> private {
  iter: mutable Iterator<T>,
  mutable currentOpt: ?T = None(),
} {
  static fun create(iter: mutable Iterator<T>): mutable this {
    mutable static{currentOpt => iter.next(), iter => iter}
  }

  readonly fun isEnd(): Bool {
    this.currentOpt is None _
  }

  readonly fun current(): T {
    this.currentOpt match {
    | None() -> invariant_violation("Cannot access current")
    | Some(x) -> x
    }
  }

  mutable fun next(): void {
    this.!currentOpt = this.iter.next();
  }
}

/*****************************************************************************/
/* An Eager Directory. */
/*****************************************************************************/

class EagerDir{
  time: Time,
  dirName: DirName,
  input: Bool,
  fixedData: FixedDataMap,
  totalSize: Int,
  creator: ?ArrowKey,
  fixedOld: FixedSingle<Source, MInfo> = FixedSingle::empty(),
  data: DataMap = DataMap::empty(),
  old: SortedMap<Source, MInfo> = SortedMap[],
  parents: FixedSingle<
    DirName,
    (MapFun, ?Array<KeyRange>),
  > = FixedSingle::empty(),
  childDirs: SortedSet<DirName> = SortedSet[],
  slices: RangeMapList<BaseName, DirName> = RangeMapList[],
  reducer: ?Reducer = None(),
  purgeCount: Int = 0,
  tombLimit: ?Tick = None(),
} extends Dir {
  fun reset(
    context: mutable SKFS.Context,
    writerPath: Path,
    keep: SortedSet<BaseName>,
    isVisible: BaseName -> Bool = _ -> true,
    wasSeen: (Tick, Source) ~> Bool = (_, _) ~> true,
  ): this {
    this.unsafeGetFileIter().each(kv -> {
      (key, valueIter) = kv;
      if (!keep.contains(key) && isVisible(key)) {
        valueIter.next() match {
        | None() -> void
        | Some _ ->
          this.unsafeGetDataIterWithoutTombs(key).each(kv -> {
            (tick, source, _values) = kv;
            // do not wipe out data that has not yet been seen
            if (wasSeen(tick, source)) {
              !this = this.writeEntry(
                context,
                source.path(),
                writerPath,
                key,
                Array[],
              )
            }
          })
        }
      }
    });
    context.!toReset = context.toReset.set(this.dirName);

    this
  }

  fun notify(
    context: readonly SKFS.Context,
    sub: Sub,
    isReset: Bool,
    changes: SortedSet<BaseName>,
    tick: Tick,
  ): void {
    lock = unfreezeLock(sub.lock);
    sub.cmd match {
    | NUpdates(csv, filename) ->
      mutexLock(lock);
      file = IO.File::open(
        filename,
        IO.OpenOptions{
          write => true,
          create => true,
          append => true,
          mode => 0o777,
        },
      );
      o = x -> file.write_all(x);
      _ = this.writeDiffStdout(
        context,
        isReset,
        changes,
        o,
        csv,
        sub.filter,
        sub.getDestinationWatermark(context),
      );
      file.close();
      mutexUnlock(lock)
    | NNotify(file) ->
      mutexLock(lock);
      _ = unixNotify(file, Int32::truncate(tick.value));
      mutexUnlock(lock)
    | NTail() ->
      mutexLock(lock);
      cond = unfreezeCond(sub.cond);
      _ = condBroadcast(cond);
      mutexUnlock(lock)
    }
  }

  fun writeDiffStdout(
    context: readonly SKFS.Context,
    isReset: Bool,
    changes: SortedSet<BaseName>,
    o: String -> void,
    format: OutputFormat,
    filter: (SKFS.Context, Bool) ~> (SKFS.BaseName -> Bool),
    destinationTime: ?Tick,
  ): Bool {
    writer = mutable Debug.BufferedWriter(o, 1024);
    filterFun = filter(context.clone(), isReset);

    producedDiffLine = false;

    for (key in changes) {
      if (!filterFun(key)) continue;
      if (!producedDiffLine) {
        writer.write("\n\n");
      };
      values = this.getArrayRaw(key);
      if (values.size() == 0) {
        writer.write(key.toKVStringRemove(format))
      } else {
        key.writeKVString(writer.write, format, values);
      };
      !producedDiffLine = true;
    };

    if (isReset) {
      // Indicates a reset, meaning all the data that was not in
      // this transaction should be removed.
      writer.write("\t\t\n");
    };

    // TODO: this is sql specific
    if (producedDiffLine || isReset) {
      // output a checkpoint, indicated by the leading colon
      ourTime = context.tick.value.toString();
      theirTime = destinationTime match {
      | None() -> ""
      | Some(t) -> " " + t.value.toString()
      };
      writer.write(`:${ourTime}${theirTime}\n`);
    };

    writer.flush();
    flushStdout();

    producedDiffLine
  }

  fun purgeOld(): FixedSingle<Source, MInfo> {
    current = 0;
    acc = mutable Vector[];
    add = minfo -> {
      if (!(minfo.i1 is MInfoEmpty())) {
        acc.push(minfo)
      }
    };
    for (source => minfo in this.old) {
      while (
        current < this.fixedOld.size() &&
        this.fixedOld[current].i0 < source
      ) {
        add(this.fixedOld[current]);
        !current = current + 1;
      };
      while (
        current < this.fixedOld.size() &&
        this.fixedOld[current].i0 == source
      ) {
        !current = current + 1;
      };
      if (!minfo.isEmpty()) {
        add((source, minfo));
      }
    };
    while (current < this.fixedOld.size()) {
      add(this.fixedOld[current]);
      !current = current + 1;
    };
    FixedSingle(acc.toArray());
  }

  private fun flattenData(limit: Tick): FixedDataMap {
    fixedIter = FixedDataMapIterator::create(this.fixedData.getIterAll());
    data = mutable Vector[];
    tombs = mutable Vector[];
    lastOpt: ?(Tick, Source, Source, BaseName, Array<File>) = None();

    addHelper = lastRow -> {
      if (lastRow.i4.size() > 0 || lastRow.i0 > limit) {
        if (lastRow.i4.size() > 0) {
          data.push(
            FixedRow(
              lastRow.i3,
              (lastRow.i1, lastRow.i4),
              TickRange::create(lastRow.i0),
            ),
          );
        } else {
          tombs.push(
            FixedRow(
              lastRow.i3,
              (lastRow.i1, lastRow.i2),
              TickRange::create(lastRow.i0),
            ),
          );
        }
      }
    };

    add = fixedRow -> {
      lastOpt match {
      | Some(
        lastRow,
      ) if (fixedRow.i3 != lastRow.i3 || fixedRow.i1 != lastRow.i1) ->
        addHelper(lastRow)
      | _ -> void
      };
      !lastOpt = Some(fixedRow)
    };

    for (key => _ in this.data) {
      while (!fixedIter.isEnd() && fixedIter.current().i3 < key) {
        add(fixedIter.current());
        fixedIter.next();
      };
      map = this.data.maybeGet(key).fromSome();
      for (tickSource => values in map) {
        (tick, source, writer) = tickSource;
        while (
          !fixedIter.isEnd() &&
          fixedIter.current().i3 == key &&
          fixedIter.current().i1 < source
        ) {
          add(fixedIter.current());
          fixedIter.next();
        };
        add((tick, source, writer, key, values));
        while (
          !fixedIter.isEnd() &&
          fixedIter.current().i3 == key &&
          fixedIter.current().i1 == source
        ) {
          fixedIter.next();
        };
      };
      while (!fixedIter.isEnd() && fixedIter.current().i3 == key) {
        add(fixedIter.current());
        fixedIter.next();
      };
    };

    while (!fixedIter.isEnd()) {
      add(fixedIter.current());
      fixedIter.next();
    };

    lastOpt match {
    | None() -> void
    | Some(lastRow) -> addHelper(lastRow)
    };

    FixedDataMap::create(data, tombs)
  }

  fun purge(context: mutable Context): this {
    limit = Tick(context.tick.value - 1000);
    fixedOld = this.purgeOld();
    fixedData = this.flattenData(limit);
    context.!purgeLimit = Some(limit);
    this with {
      tombLimit => Some(limit),
      data => DataMap::empty(),
      old => SortedMap[],
      fixedData,
      fixedOld,
    }
  }

  fun isInput(): Bool {
    this.input
  }

  fun getTime(): Time {
    this.time
  }

  private fun getAllKeysWithValues(): SortedSet<BaseName> {
    result = SortedSet[];
    this.unsafeGetFileIter().each(kv -> {
      (key, valueIter) = kv;
      valueIter.next() match {
      | None() -> void
      | Some _ -> !result = result.set(key)
      }
    });
    result
  }

  fun getChangesAfter(
    tick: Tick,
    forceReset: Bool = false,
  ): (Bool, SortedSet<BaseName>) {
    this.tombLimit match {
    | _ if (forceReset) -> return (true, this.getAllKeysWithValues())
    | Some(limit) if (tick.value <= limit.value) ->
      return (true, this.getAllKeysWithValues())
    | _ -> void
    };
    new = this.data.getChangesAfter(tick);
    old = this.fixedData.getChangesAfter(tick);
    result = new.union(old);
    (false, result)
  }

  fun getLastTick(): ?Tick {
    optFTick = this.fixedData.getTick();
    optDTick = this.data.getTick();
    (optFTick, optDTick) match {
    | (None(), None()) -> None()
    | (Some(t), None())
    | (None(), Some(t)) ->
      Some(t)
    | (Some(ft), Some(dt)) -> Some(max(ft, dt))
    }
  }

  private static fun fixedMapData(
    context: mutable Context,
    oldVec: mutable Vector<(Source, MInfo)>,
    parent: EagerDir,
    childName: DirName,
    f: MapFun,
    acc: mutable Vector<FixedRow<Array<File>>>,
    current: mutable IntRef,
  ): void {
    key = parent.fixedData.data[current.value].key;
    // fast path
    if (
      parent.reducer is None() &&
      current.value + 1 < parent.fixedData.data.size() &&
      parent.fixedData.data[current.value + 1].key != key
    ) {
      fixedFiles = parent.fixedData.data[current.value].value.i1.iterator();
      static::mapRow(
        context,
        acc,
        oldVec,
        parent.dirName,
        childName,
        key,
        fixedFiles,
        f,
      );
      current.incr();
      return void;
    };

    valueAcc = mutable Vector[];
    while (
      current.value < parent.fixedData.data.size() &&
      parent.fixedData.data[current.value].key == key
    ) {
      for (elt in parent.fixedData.data[current.value].value.i1) {
        valueAcc.push(elt);
      };
      current.incr();
    };
    fixedFiles = parent.reducer match {
    | None() -> valueAcc.iterator()
    | Some(compact) -> compact.getArray(key).iterator()
    };
    static::mapRow(
      context,
      acc,
      oldVec,
      parent.dirName,
      childName,
      key,
      fixedFiles,
      f,
    );
  }

  private static fun subMapData(
    obstack: Obstack,
    context: mutable Context,
    parent: EagerDir,
    childName: DirName,
    f: MapFun,
    currentStart: Int,
    currentEnd: Int,
    start: ?Boundary<BaseName>,
    end: ?BaseName,
  ): (
    readonly Vector<FixedRow<Array<File>>>,
    readonly Vector<(Source, MInfo)>,
    ?BaseName,
    Int,
  ) {
    acc = mutable Vector[];
    oldVec = mutable Vector[];
    current = mutable IntRef(currentStart);
    size = 0;

    for (key => _ in parent.data.itemsAfterKey(start)) {
      end match {
      | Some(endKey) if (key > endKey) -> break void
      | _ -> void
      };
      while (
        current.value <= currentEnd &&
        parent.fixedData.data[current.value].key < key
      ) {
        fixedKey = parent.fixedData.data[current.value].key;
        static::fixedMapData(
          context,
          oldVec,
          parent,
          childName,
          f,
          acc,
          current,
        );
        !size = size + 1;
        if (shouldGC(obstack) != 0) {
          return (acc, oldVec, Some(fixedKey), current.value);
        }
      };
      while (
        current.value <= currentEnd &&
        parent.fixedData.data[current.value].key == key
      ) {
        current.incr();
      };

      static::mapRow(
        context,
        acc,
        oldVec,
        parent.dirName,
        childName,
        key,
        parent.getIterRaw(key),
        f,
      );
      !size = size + 1;
      if (shouldGC(obstack) != 0) {
        return (acc, oldVec, Some(key), current.value);
      }
    };

    while (current.value <= currentEnd) {
      fixedKey = parent.fixedData.data[current.value].key;
      static::fixedMapData(context, oldVec, parent, childName, f, acc, current);
      !size = size + 1;
      if (shouldGC(obstack) != 0) {
        return (acc, oldVec, Some(fixedKey), current.value);
      }
    };
    (acc, oldVec, None(), current.value)
  }

  private static fun mapData(
    context: mutable Context,
    oldVec: mutable Vector<(Source, MInfo)>,
    parent: EagerDir,
    childName: DirName,
    f: MapFun,
    acc: mutable Vector<FixedRow<Array<File>>>,
    rangeOpt: ?KeyRange,
  ): void {
    last: ?Boundary<BaseName> = rangeOpt match {
    | None() -> None()
    | Some(range) -> Some(Inclusive(range.start))
    };
    current = rangeOpt match {
    | None() -> 0
    | Some(range) ->
      pos = parent.fixedData.data.getPos(range.start);
      if (pos < 0) 0 else pos
    };
    end = rangeOpt.map(r -> r.end);
    currentEnd = end match {
    | None() -> parent.fixedData.data.size() - 1
    | Some(key) ->
      pos = parent.fixedData.data.getPos(key);
      if (
        pos < parent.fixedData.data.size() &&
        parent.fixedData.data[pos].key != key
      ) {
        !pos = pos - 1;
      };
      min(parent.fixedData.data.size() - 1, pos)
    };

    loop {
      lcurrent = current;
      llast = last;

      (localAcc, localOldVec, lastSkipped, !current) = withRegion(
        context,
        (obstack, context) ~> {
          static::subMapData(
            obstack,
            context,
            parent,
            childName,
            f,
            lcurrent,
            currentEnd,
            llast,
            end,
          );
        },
      );

      acc.extend(localAcc);
      oldVec.extend(localOldVec);

      !last = lastSkipped.map(x -> Exclusive(x));
      if (last is None _) {
        break void;
      }
    };
  }

  private static fun mapRow(
    context: mutable Context,
    acc: mutable Vector<FixedRow<Array<File>>>,
    oldVec: mutable Vector<(Source, MInfo)>,
    parentName: DirName,
    childName: DirName,
    key: BaseName,
    valueIter: mutable Iterator<File>,
    f: MapFun,
  ): void {
    arrow = ArrowKey(parentName, childName, key);
    context.enter(arrow);

    if (context.debugMode) {
      print_string(`MAP_ROW: ${parentName} ${key}`);
    };

    newDirsCopy = context.newDirs;
    readsCopy = context.reads;

    context.!newDirs = SortedSet[];
    context.!reads = SortedSet[];

    writer = mutable Writer{};
    f(context, writer, key, valueIter);

    kvArray = writer.getWrites();
    newDirs = context.newDirs;
    reads = context.getReads();
    context.!newDirs = newDirsCopy;
    context.!reads = readsCopy;

    context.updateNewDeps(ArrowKey(parentName, childName, key), reads);

    path = Path::create(parentName, key);
    source = Source::create(path);

    for (kv in kvArray) {
      (k, v) = kv;
      acc.push(FixedRow(k, (source, v), TickRange::create(context.tick)))
    };

    if (!kvArray.isEmpty() || !newDirs.isEmpty()) {
      oldVec.push(
        (
          source,
          MInfo::create(
            kvArray.map(kv -> kv.i0),
            newDirs.toArray(),
            reads.toArray(),
          ),
        ),
      );
    };

    context.leave(arrow);
  }

  static fun isReusable(
    context: readonly Context,
    child: EagerDir,
    parents: FixedSingle<DirName, (MapFun, ?Array<KeyRange>)>,
  ): Bool {
    if (context.unsafeReuse) return true;
    same = (native_eq(parents, child.parents) == 0);
    if (same && child.creator != context.currentArrow()) {
      invariant_violation(
        "Duplicate subdirectory: " +
          child.dirName.toString() +
          "\nFirst created: " +
          inspect(child.creator).toString() +
          "\nThen: " +
          inspect(context.currentArrow()).toString(),
      );
    };
    same
  }

  static fun reuseDir(context: mutable Context, childName: DirName): void {
    if (context.debugMode) {
      print_string(`REUSING: ${childName}`);
    };
    context.!newDirs = context.newDirs.set(childName);
  }

  static fun apply(
    context: mutable Context,
    parentName: DirName,
    childName: DirName,
    f: MapFun,
    reducerOpt: ?IReducer = None(),
    rangeOpt: ?Array<KeyRange> = None(),
    unsafeSkipInit: Bool = false,
  ): void {
    parents = FixedSingle::create(mutable Vector[(parentName, (f, rangeOpt))]);
    static::applyMany(context, parents, childName, reducerOpt, unsafeSkipInit);
  }

  static fun applyMany(
    context: mutable Context,
    parents: FixedSingle<DirName, (MapFun, ?Array<KeyRange>)>,
    childName: DirName,
    reducerOpt: ?IReducer = None(),
    unsafeSkipInit: Bool = false,
  ): void {
    context.unsafeMaybeGetEagerDir(childName) match {
    | Some(child) if (static::isReusable(context, child, parents)) ->
      static::reuseDir(context, childName);
      return void
    | _ -> void
    };

    if (context.newDirs.contains(childName)) {
      error(`Error: directory ${childName.toString()} already exists`);
    };

    globalName = "PRE_COMPUTED_" + childName;

    dir = context.getGlobal(globalName) match {
    | Some(x @ EagerDir _) ->
      invariant(x.creator == context.currentArrow());
      context.removeGlobal(globalName);
      x
    | _ ->
      context.!newDirs = context.newDirs.add(childName);

      acc = mutable Vector<FixedRow<Array<File>>>[];
      oldVec = mutable Vector[];

      if (!unsafeSkipInit) {
        for (parentName => parentData in parents) {
          (f, rangeOpt) = parentData;
          parent = context.unsafeGetEagerDir(parentName);
          rangeOpt match {
          | None() ->
            static::mapData(context, oldVec, parent, childName, f, acc, None())
          | Some(ranges) ->
            for (range in ranges) {
              static::mapData(
                context,
                oldVec,
                parent,
                childName,
                f,
                acc,
                Some(range),
              );
            }
          }
        }
      };

      fixedData = FixedDataMap::create(acc);
      time = context.timeStamp();
      totalSize = acc.size();
      reducer = reducerOpt.map(ireducer ->
        Reducer::create(fixedData, ireducer)
      );

      if (context.debugMode) {
        parentNames = parents.items().map(x -> (x.i0, x.i1.i1)).collect(Array);
        print_string(
          `CREATED:  ${childName} (time: ${time}, parents: ${parentNames})`,
        );
      };

      data = DataMap::empty();

      EagerDir{
        time,
        dirName => childName,
        input => false,
        parents,
        fixedData,
        data,
        totalSize,
        creator => context.currentArrow(),
        fixedOld => FixedSingle::create(oldVec),
        childDirs => SortedSet[],
        reducer,
      }
    };
    updateDirtyReaders(context, Path::create(childName.tag(), DirTag()));
    context.setDir(childName, dir);
    for (parentName => parentData in parents) {
      (_, rangeOpt) = parentData;
      static::addChildToParent(context, parentName, childName, rangeOpt);
    };
  }

  static fun addChildToParent(
    context: mutable Context,
    parentName: DirName,
    childName: DirName,
    rangeOpt: ?Array<KeyRange>,
  ): void {
    parent = context.unsafeGetEagerDir(parentName);
    rangeOpt match {
    | None() -> !parent.childDirs = parent.childDirs.set(childName)
    | Some(ranges) ->
      for (range in ranges) {
        !parent.purgeCount = parent.purgeCount + 1;
        !parent.slices = parent.slices.add(range.start, range.end, childName)
      }
    };
    if (parent.purgeCount >= PURGE_LIMIT) {
      !parent = parent with {
        slices => parent.purgeSlices(context),
        purgeCount => 0,
      };
    };
    context.setDir(parent.dirName, parent);
  }

  fun getArrayRaw(key: BaseName): Array<File> {
    this.getIterRaw(key).collect(Array);
  }

  fun unsafeGetAllDataIterAfter(
    limit: Tick,
    key: BaseName,
  ): mutable Iterator<(Tick, Source, Source, Array<File>)> {
    this.data.maybeGet(key) match {
    | None() ->
      fixedIter = this.fixedData.getIterAfter(limit, key);
      for (row in fixedIter) {
        yield row
      }
    | Some(modified) ->
      fixed = FixedDataMapIterator::create(
        this.fixedData.getIterAfter(limit, key),
      );

      for (tickSourceWriterFiles in modified.itemsAfter(limit)) {
        (tick, source, writer, files) = tickSourceWriterFiles;
        while (!fixed.isEnd() && fixed.current().i1 < source) {
          yield fixed.current();
          fixed.next();
        };
        while (!fixed.isEnd() && fixed.current().i1 == source) {
          fixed.next();
        };
        yield (tick, source, writer, files);
      };
      while (!fixed.isEnd()) {
        yield fixed.current();
        fixed.next();
      }
    }
  }

  fun unsafeGetAllDataIter(
    key: BaseName,
  ): mutable Iterator<(Tick, Source, Source, Array<File>)> {
    fixedIter = this.fixedData.getIter(key);
    this.data.maybeGet(key) match {
    | None() ->
      for (row in fixedIter) {
        yield row
      }
    | Some(modified) ->
      fixed = FixedDataMapIterator::create(this.fixedData.getIter(key));

      for (tickSourceWriter => files in modified) {
        (tick, source, writer) = tickSourceWriter;
        while (!fixed.isEnd() && fixed.current().i1 < source) {
          yield fixed.current();
          fixed.next();
        };
        while (!fixed.isEnd() && fixed.current().i1 == source) {
          fixed.next();
        };
        yield (tick, source, writer, files);
      };
      while (!fixed.isEnd()) {
        yield fixed.current();
        fixed.next();
      }
    }
  }

  fun unsafeGetDataIterWithoutTombs(
    key: BaseName,
  ): mutable Iterator<(Tick, Source, Array<File>)> {
    fixedIter = this.fixedData.getIter(key);
    this.data.maybeGet(key) match {
    | None() ->
      for (rows in fixedIter) {
        if (rows.i3.size() > 0) {
          yield (rows.i0, rows.i1, rows.i3);
        }
      }
    | Some(modified) ->
      fixed = FixedDataMapIterator::create(this.fixedData.getIter(key));

      for (sourceFilesTick in modified.map.itemsWithTick()) {
        (source, files, tickRange) = sourceFilesTick;
        tick = tickRange.current;
        while (!fixed.isEnd() && fixed.current().i1 < source) {
          if (fixed.current().i3.size() > 0) {
            yield (fixed.current().i0, fixed.current().i1, fixed.current().i3);
          };
          fixed.next();
        };
        while (!fixed.isEnd() && fixed.current().i1 == source) {
          fixed.next();
        };
        if (files.size() > 0) {
          yield (tick, source, files);
        }
      };
      while (!fixed.isEnd()) {
        if (fixed.current().i3.size() > 0) {
          yield (fixed.current().i0, fixed.current().i1, fixed.current().i3);
        };
        fixed.next();
      }
    }
  }

  private fun getIterRaw(key: BaseName): mutable Iterator<File> {
    this.reducer match {
    | None() ->
      for (arr in this.unsafeGetDataIterWithoutTombs(key)) {
        for (elt in arr.i2) {
          yield elt
        }
      }
    | Some(compact) ->
      for (elt in compact.getArray(key)) {
        yield elt
      }
    }
  }

  private fun getArraySourceKey(source: Source, key: BaseName): Array<File> {
    this.data.maybeGet(key) match {
    | None() -> this.fixedData.data.getArraySourceKey(source, key).flatten()
    | Some(modified) ->
      modified.maybeGet(source) match {
      | None() -> this.fixedData.data.getArraySourceKey(source, key).flatten()
      | Some(v) -> v
      }
    }
  }

  static fun update(
    context: mutable Context,
    contextDirty: readonly Map<DirName, SortedSet<BaseName>>,
    contextDirtyReaders: readonly Map<
      DirName,
      readonly Map<DirName, SortedSet<BaseName>>,
    >,
    parentName: DirName,
    mapFun: MapFun,
    rangeOpt: ?Array<KeyRange>,
    child: EagerDir,
  ): void {
    parent = context.unsafeGetEagerDir(parentName);
    childName = child.dirName;

    dirty = SortedSet[];
    if (contextDirtyReaders.containsKey(parent.dirName)) {
      if (contextDirtyReaders[parent.dirName].containsKey(childName)) {
        for (key in contextDirtyReaders[parent.dirName][childName]) {
          rangeOpt match {
          | Some(
            ranges,
          ) if (!ranges.any(range -> range.start <= key && key <= range.end)) ->
            void
          | _ -> !dirty = dirty.set(key)
          }
        }
      };
    };
    if (contextDirty.containsKey(parent.dirName)) {
      for (key in contextDirty[parent.dirName]) {
        rangeOpt match {
        | Some(
          ranges,
        ) if (!ranges.any(range -> range.start <= key && key <= range.end)) ->
          void
        | _ -> !dirty = dirty.set(key)
        }
      };
    };

    for (key in dirty) {
      context.enter(ArrowKey(parentName, childName, key));
      values = parent.getIterRaw(key);
      path = Path::create(parentName, key);
      source = Source::create(path);
      oldInfo = static::getOld(child, source);
      oldKeys = SortedSet::createFromItems(oldInfo.getKeys());
      writer = mutable Writer{};
      newDirsCopy = context.newDirs;
      readsCopy = context.reads;
      context.!newDirs = SortedSet[];
      context.!reads = SortedSet[];

      mapFun(context, writer, key, values);

      newDirs = context.newDirs;
      reads = context.getReads();
      context.!newDirs = newDirsCopy;
      context.!reads = readsCopy;

      !child = child.updateNewDirs(context, source, newDirs);
      mapped = writer.getWrites();

      for (read in reads) {
        arrowKey = ArrowKey(parentName, child.dirName, key);
        context.!deps = context.deps.set(read, arrowKey);
      };

      for (oldRead in oldInfo.getReads()) {
        if (reads.contains(oldRead)) continue;
        arrowKey = ArrowKey(parentName, child.dirName, key);
        context.!deps = context.deps.remove(oldRead, arrowKey);
      };

      keys = mutable Vector[];

      for (kv in mapped) {
        (k, rvalues) = kv;

        keys.push(k);
        if (oldKeys.contains(k)) {
          !oldKeys = oldKeys.remove(k);
        };
        !child = child.writeEntry(context, path, path, k, rvalues);
      };

      // Let's remove the keys that no longer exist.
      for (k in oldKeys) {
        !child = child.writeEntry(context, path, path, k, Array[]);
      };

      // We need to remember what keys we produced for the next
      // time around.
      minfo = MInfo::create(keys.toArray(), newDirs.toArray(), reads.toArray());
      if (
        !minfo.getKeys().isEmpty() ||
        !minfo.getNewDirs().isEmpty() ||
        !minfo.getReads().isEmpty()
      ) {
        !child.old[source] = minfo
      } else if (child.old.containsKey(source)) {
        !child.old = child.old.remove(source);
      };

      context.leave(ArrowKey(parentName, childName, key));
    };

    context.setDir(child.dirName, child);
  }

  fun getArray(context: mutable Context, key: BaseName): Array<File> {
    this.getIter(context, key).collect(Array);
  }

  fun getIter(context: mutable Context, key: BaseName): mutable Iterator<File> {
    path = Path::create(this.dirName, key);
    context.addDep(path);
    this.getIterRaw(key)
  }

  fun writeEntry(
    context: mutable Context,
    origSourcePath: Path,
    writerPath: Path,
    k: BaseName,
    rvalues: Array<File>,
  ): this {
    origSource = Source::create(origSourcePath);
    oldValues = this.getArraySourceKey(origSource, k);

    if (native_eq(rvalues, oldValues) == 0) {
      return this;
    };

    if (this.data.nbrEntries >= this.fixedData.size()) {
      context.!toPurge = context.toPurge.set(this.dirName);
    };

    totalSize = if (oldValues.size() == 0 && rvalues.size() > 0) {
      this.totalSize + 1
    } else if (oldValues.size() > 0 && rvalues.size() == 0) {
      this.totalSize - 1
    } else {
      this.totalSize
    };

    map = this.data.maybeGet(k) match {
    | None() -> DataMapValue::empty()
    | Some(x) -> x
    };

    isMasking = this.fixedData.data.getIterSourceKey(
      origSource,
      k,
    ).next() is Some _;
    writer = Source::create(writerPath);
    !map = map.set(context.tick, isMasking, origSource, writer, rvalues);

    tag = TickRange::create(context.tick);
    !this.data = this.data.set(tag, k, map);

    reducer = this.reducer match {
    | None() -> None()
    | Some(cdata) ->
      state = cdata.getArray(k);
      if (state.size() == 0) {
        !cdata.modified[k] = cdata.reducer.init(
          this.unsafeGetDataIterWithoutTombs(k)
            .map(x -> x.i2.iterator())
            .flatten(),
        )
      } else {
        cdata.reducer.update(state, oldValues, rvalues) match {
        | None() ->
          !cdata.modified[k] = cdata.reducer.init(
            this.unsafeGetDataIterWithoutTombs(k)
              .map(x -> x.i2.iterator())
              .flatten(),
          )
        | Some(new) -> !cdata.modified[k] = new
        }
      };
      Some(cdata)
    };

    context.!dirty = List.Cons(Path::create(this.dirName, k), context.dirty);

    path = Path::create(this.dirName, k);

    if (this.totalSize != totalSize) {
      sizePath = Path::create(this.dirName.size(), SizeTag());
      updateDirtyReaders(context, sizePath);
      if (
        this.totalSize == 0 && totalSize != 0 ||
        this.totalSize != 0 && totalSize == 0
      ) {
        isEmptyPath = Path::create(this.dirName.size(), IsEmptyTag());
        updateDirtyReaders(context, isEmptyPath);
      }
    };

    filesPath = Path::create(this.dirName.files(), FilesTag());
    updateDirtyReaders(context, filesPath);

    !this = this with {totalSize, reducer};

    updateDirtyReaders(context, path);

    parentTime = this.time;
    childDirs = SortedSet[];

    for (childName in this.childDirs) {
      context.unsafeMaybeGetEagerDir(childName) match {
      | None() -> continue
      | Some(childDir) ->
        !childDirs = childDirs.set(childName);
        context.!toUpdate = context.toUpdate.set(
          (childDir.time, parentTime),
          Arrow(this.dirName, childName),
        )
      }
    };

    purgeCount = this.purgeCount;
    slices = this.slices;

    for (childNameTime in this.slices.get(k)) {
      !purgeCount = purgeCount + 1;
      childName = childNameTime;
      context.unsafeMaybeGetEagerDir(childName) match {
      | None() -> continue
      | Some(childDir) ->
        context.!toUpdate = context.toUpdate.set(
          (childDir.time, parentTime),
          Arrow(this.dirName, childName),
        )
      }
    };

    if (context.debugMode) {
      name = "" + this.dirName + k;
      print_string(`WRITTEN:  ${name}`);
    };

    if (purgeCount >= PURGE_LIMIT) {
      !slices = this.purgeSlices(context);
      !purgeCount = 0;
    };

    this with {childDirs, slices, purgeCount}
  }

  fun purgeSlices(
    context: mutable Context,
  ): RangeMapList<SKFS.BaseName, SKFS.DirName> {
    slices = RangeMapList[];
    childDirs = SortedSet[];
    for (slice in this.slices) {
      for (childDir in slice.i1) {
        !childDirs = childDirs.set(childDir);
      }
    };
    for (child in childDirs) {
      context.unsafeMaybeGetEagerDir(child) match {
      | None() -> continue
      | Some(childDir) ->
        for (parent in childDir.parents.items()) {
          if (parent.i0 != this.dirName) continue;
          parent.i1.i1 match {
          | None() -> continue
          | Some(ranges) ->
            for (range in ranges) {
              !slices = slices.add(range.start, range.end, childDir.dirName)
            }
          }
        }
      }
    };
    slices
  }

  fun unsafeIterKeys(f: (BaseName, Tick) -> void): void {
    fixedData = this.fixedData.data;
    current = 0;
    this.data.eachWithTick((newKey, tick) -> {
      while (current < fixedData.size() && fixedData[current].key < newKey) {
        row = fixedData[current];
        f(row.key, Tick(0));
        !current = current + 1;
      };
      f(newKey, tick);
    });
    while (current < fixedData.size()) {
      row = fixedData[current];
      f(row.key, Tick(0));
      !current = current + 1;
    };
  }

  private fun getFixedFiles(idx: Int): mutable Iterator<File> {
    key = this.fixedData.data[idx].key;
    while (
      idx < this.fixedData.data.size() &&
      this.fixedData.data[idx].key == key
    ) {
      fixedValues = this.fixedData.data[idx].value.i1;
      if (this.reducer is None()) {
        for (elt in fixedValues) {
          yield elt;
        };
      };
      !idx = idx + 1;
    };

    this.reducer match {
    | None() -> void
    | Some(compact) ->
      for (elt in compact.getArray(key)) {
        yield elt
      }
    }
  }

  fun unsafeGetFileIter(
    start: ?BaseName = None(),
  ): mutable Iterator<(BaseName, mutable Iterator<File>)> {
    this.reducer match {
    | None() -> this.unsafeGetFileIterNoReducer(start)
    | Some(reducer) -> reducer.unsafeIter(start)
    }
  }

  fun unsafeGetFileIterNoReducer(
    start: ?BaseName,
  ): mutable Iterator<(BaseName, mutable Iterator<File>)> {
    current = mutable IntRef(
      start match {
      | None() -> 0
      | Some(key) ->
        pos = this.fixedData.data.getPos(key);
        if (pos < 0) 0 else pos
      },
    );
    for (key => _ in this.data.data.itemsAfterKey(
      start match {
      | None() -> None()
      | Some(x) -> Some(Inclusive(x))
      },
    )) {
      while (
        current.value < this.fixedData.data.size() &&
        this.fixedData.data[current.value].key < key
      ) {
        fixedKey = this.fixedData.data[current.value].key;
        fixedFiles = this.getFixedFiles(current.value);
        while (
          current.value < this.fixedData.data.size() &&
          this.fixedData.data[current.value].key == fixedKey
        ) {
          current.incr();
        };
        yield (fixedKey, fixedFiles);
      };
      while (
        current.value < this.fixedData.data.size() &&
        this.fixedData.data[current.value].key == key
      ) {
        current.incr();
      };
      yield (key, this.getIterRaw(key));
    };
    while (current.value < this.fixedData.data.size()) {
      fixedKey = this.fixedData.data[current.value].key;
      fixedFiles = this.getFixedFiles(current.value);
      while (
        current.value < this.fixedData.data.size() &&
        this.fixedData.data[current.value].key == fixedKey
      ) {
        current.incr();
      };
      yield (fixedKey, fixedFiles);
    };
  }

  fun unsafeGetFileIterWithReducer(): mutable Iterator<
    (BaseName, mutable Iterator<File>),
  > {
    current = mutable IntRef(0);
    for (key => _ in this.data) {
      while (
        current.value < this.fixedData.data.size() &&
        this.fixedData.data[current.value].key < key
      ) {
        fixedKey = this.fixedData.data[current.value].key;
        fixedFiles = this.getFixedFiles(current.value);
        while (
          current.value < this.fixedData.data.size() &&
          this.fixedData.data[current.value].key == key
        ) {
          current.incr();
        };
        yield (fixedKey, fixedFiles);
      };
      while (
        current.value < this.fixedData.data.size() &&
        this.fixedData.data[current.value].key == key
      ) {
        current.incr();
      };
      yield (key, this.getIterRaw(key));
    };
    while (current.value < this.fixedData.data.size()) {
      fixedKey = this.fixedData.data[current.value].key;
      fixedFiles = this.getFixedFiles(current.value);
      while (
        current.value < this.fixedData.data.size() &&
        this.fixedData.data[current.value].key == fixedKey
      ) {
        current.incr();
      };
      yield (fixedKey, fixedFiles);
    };
  }

  fun onFiles(
    process: mutable Iterator<(BaseName, mutable Iterator<File>)> -> void,
  ): void {
    process(this.unsafeGetFileIter())
  }

  fun keys(): SortedSet<BaseName> {
    fixedData = this.fixedData.data;
    current = 0;
    keys = SortedSet[];
    for (newKey => newValues in this.data) {
      while (current < fixedData.size() && fixedData[current].key < newKey) {
        row = fixedData[current];
        if (row.value.i1.size() > 0) {
          !keys = keys.set(row.key);
        };
        !current = current + 1;
      };
      if (!newValues.isEmpty()) {
        !keys = keys.set(newKey);
      };
    };
    while (current < fixedData.size()) {
      row = fixedData[current];
      if (row.value.i1.size() > 0) {
        !keys = keys.set(row.key);
      };
      !current = current + 1;
    };
    keys
  }

  fun getDirName(): DirName {
    this.dirName
  }

  static fun getOld(child: EagerDir, key: Source): MInfo {
    if (child.old.containsKey(key)) {
      child.old[key]
    } else {
      child.fixedOld.maybeGet(key) match {
      | None() -> MInfo::empty()
      | Some(v) -> v
      }
    }
  }

  fun updateNewDirs(
    context: mutable Context,
    source: Source,
    newDirs: SortedSet<DirName>,
  ): this {
    removed = mutable Vector[];
    minfo = static::getOld(this, source);
    if (minfo.getNewDirs().isEmpty() || !context.removeSubDirs) return this;

    lastRoundDirs = minfo.getNewDirs();
    for (dirName in lastRoundDirs) {
      if (newDirs.contains(dirName)) continue;
      context.removeDir(dirName);
      removed.push(dirName)
    };
    !minfo = minfo.setNewDirs(newDirs.toArray());
    !this.old[source] = minfo;

    for (dirName in removed) {
      updateDirtyReaders(context, Path::create(dirName.tag(), DirTag()));
    };
    this
  }

  fun writeArrayReturnDir(
    context: mutable Context,
    key: BaseName,
    values: Array<File>,
  ): this {
    source = Path::create(this.dirName, key);
    !this = this.writeEntry(context, source, source, key, values);
    context.!toReset = context.toReset.set(this.dirName);
    this
  }

  fun writeArray(
    context: mutable Context,
    key: BaseName,
    values: Array<File>,
  ): void {
    !this = this.writeArrayReturnDir(context, key, values);
    context.setDir(this.dirName, this);
  }

  fun writeArraySourceManyReturnDir(
    context: mutable Context,
    bindings: mutable Iterator<(BaseName, (Path, Path, Array<File>))>,
  ): this {
    for (kv in bindings) {
      (key, (origSource, writer, values)) = kv;
      !this = this.writeEntry(context, origSource, writer, key, values);
    };
    context.!toReset = context.toReset.set(this.dirName);
    this
  }

  fun writeArraySourceMany(
    context: mutable Context,
    bindings: mutable Iterator<(BaseName, (Path, Path, Array<File>))>,
  ): void {
    !this = this.writeArraySourceManyReturnDir(context, bindings);
    context.setDir(this.dirName, this);
  }

  fun writeArrayMany(
    context: mutable Context,
    bindings: mutable Iterator<(BaseName, Array<File>)>,
  ): void {
    this.writeArraySourceMany(
      context,
      bindings.map(kv -> {
        (key, values) = kv;
        source = Path::create(this.dirName, key);
        (key, (source, source, values))
      }),
    );
  }

  fun size(context: mutable Context): Int {
    context.addDep(Path::create(this.dirName.size(), SizeTag()));
    this.totalSize
  }

  fun getIterator(
    context: mutable Context,
  ): mutable Iterator<(SKFS.BaseName, mutable Iterator<SKFS.File>)> {
    path = Path::create(this.dirName.files(), FilesTag());
    context.addDep(path);
    this.unsafeGetFileIter()
  }

  fun getAllDataIter(
    context: mutable Context,
    key: BaseName,
  ): mutable Iterator<(Tick, Source, Source, Array<File>)> {
    path = Path::create(this.dirName, key);
    context.addDep(path);
    this.unsafeGetAllDataIter(key)
  }

  fun getDataIterWithoutTombs(
    context: mutable Context,
    key: BaseName,
  ): mutable Iterator<(Tick, Source, Array<File>)> {
    path = Path::create(this.dirName, key);
    context.addDep(path);
    this.unsafeGetDataIterWithoutTombs(key)
  }

  fun isEmpty(context: mutable Context): Bool {
    context.addDep(Path::create(this.dirName.size(), IsEmptyTag()));
    this.totalSize == 0
  }

  fun write(context: mutable Context, baseName: BaseName, value: File): void {
    this.writeArray(context, baseName, Array[value]);
  }

  fun remove(context: mutable Context, baseName: BaseName): void {
    this.writeArray(context, baseName, Array[]);
  }

  fun isDeleted(): Bool {
    false
  }
}
