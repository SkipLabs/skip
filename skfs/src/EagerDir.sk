/*****************************************************************************/
/* Eager directories. */
/*****************************************************************************/
module SKStore;

/*****************************************************************************/
/* Constants. */
/*****************************************************************************/

const PURGE_LIMIT: Int = 30;

/*****************************************************************************/
/* We need to be able to iterate after a given starting point. This method
 * should be in SortedMap.sk but I will move it in a separate diff, because
 * otherwise I force everyone to recompile the compiler.
 */
/*****************************************************************************/

mutable class Items<T>(data: mutable Iterator<T>) {
  static fun create(data: mutable Iterator<T>): mutable this {
    mutable static(data)
  }
  mutable fun items(): mutable Iterator<T> {
    this.data
  }
}

extension base class .SortedMap {
  fun itemsAfter<K2: Orderable, V2>[K: K2, V: V2](
    start: ?K2,
  ): mutable Iterator<(K2, V2)> {
    this match {
    | SortedMap.Nil() -> void
    | SortedMap.Node{key, value, left, right} ->
      if (
        start match {
        | None() -> true
        | Some(x) -> key >= x
        }
      ) {
        for (x in left.itemsAfter(start)) {
          yield x;
        };
        yield (key, value);
      };
      for (x in right.itemsAfter(start)) {
        yield x;
      }
    }
  }
}

/*****************************************************************************/
/* The signature of a function used by apply. */
/*****************************************************************************/

type MapFun = (
  mutable Context,
  mutable Writer,
  Key,
  mutable Iterator<File>,
) ~> void;

/*****************************************************************************/
/* The action passed to aggregate functions. */
/*****************************************************************************/

value class Aggregate(state: File, reducer: IReducer)

/*****************************************************************************/
/* Compaction types and helpers. */
/*****************************************************************************/

class Reducer{
  reducer: IReducer,
  fixed: Array<(Key, Array<File>)>,
  modified: SortedMap<Key, Array<File>>,
} {
  static fun create(fixedData: FixedDataMap, reducer: IReducer): this {
    acc = mutable Vector[];
    modified = SortedMap[];
    current = mutable IntRef(0);
    while (current.value < fixedData.data.size()) {
      key = fixedData.data[current.value].key;
      iterator = static::makeCompactKeyIterator(
        fixedData.data,
        key,
        current,
      ).iterator();
      acc.push((key, reducer.init(iterator)));
    };
    fixed = acc.toArray();
    static{reducer, fixed, modified}
  }

  fun unsafeIter(
    start: ?Key = None(),
  ): mutable Iterator<(Key, mutable Iterator<File>)> {
    current = mutable IntRef(
      start match {
      | None() -> 0
      | Some(key) ->
        pos = binSearch(i ~> this.fixed[i].i0, key, 0, this.fixed.size() - 1);
        if (pos < 0) 0 else pos
      },
    );
    for (key => values in Items::create(this.modified.itemsAfter(start))) {
      while (
        current.value < this.fixed.size() &&
        this.fixed[current.value].i0 < key
      ) {
        fixedKey = this.fixed[current.value].i0;
        fixedFiles = this.fixed[current.value].i1;
        yield (fixedKey, fixedFiles.iterator());
        current.incr();
      };
      while (
        current.value < this.fixed.size() &&
        this.fixed[current.value].i0 == key
      ) {
        current.incr();
      };
      yield (key, values.iterator());
    };
    while (current.value < this.fixed.size()) {
      fixedKey = this.fixed[current.value].i0;
      fixedFiles = this.fixed[current.value].i1;
      yield (fixedKey, fixedFiles.iterator());
      current.incr();
    };
  }

  static fun makeCompactKeyIterator(
    fixedData: FixedData<Array<File>>,
    key: Key,
    current: mutable IntRef,
  ): Array<File> {
    result = mutable Vector[];
    while (
      current.value < fixedData.size() &&
      fixedData[current.value].key == key
    ) {
      for (file in fixedData[current.value].value) {
        result.push(file);
      };
      current.incr();
    };
    x = result.toArray();
    x
  }

  fun getArray(key: Key): Array<File> {
    this.modified.maybeGet(key) match {
    | None() -> this.getFixedij(key, 0, this.fixed.size() - 1)
    | Some(values) -> values
    }
  }

  private fun getFixedij(key: Key, i: Int, j: Int): Array<File> {
    if (i > j) {
      return Array[];
    };
    pivot = i + (j - i) / 2;
    key.compare(this.fixed[pivot].i0) match {
    | LT() -> this.getFixedij(key, i, pivot - 1)
    | EQ() -> this.fixed[pivot].i1
    | GT() -> this.getFixedij(key, pivot + 1, j)
    }
  }

  fun getFixed(key: Key): Array<File> {
    this.getFixedij(key, 0, this.fixed.size() - 1)
  }
}

class IReducer{
  init: (mutable Iterator<File> ~> Array<File>),
  update: (Array<File>, Array<File>, Array<File>) ~> ?Array<File>,
}

mutable class IntRef(mutable value: Int) {
  mutable fun incr(): void {
    this.!value = this.value + 1
  }
}

/*****************************************************************************/
/* Ranges. */
/*****************************************************************************/

value class KeyRange(start: Key, end: Key) uses Orderable, Show {
  fun toString(): String {
    `[${this.start}, ${this.end}]`
  }
}

/*****************************************************************************/
/* Keys and newDirs produced during a mapping. */
/*****************************************************************************/

base class MInfo {
  children =
  | MInfoEmpty()
  | MInfoSingle(Key)
  | MInfoFull(Array<Key>, Array<DirName>, Array<Path>)

  fun getKeys(): Array<Key> {
    this match {
    | MInfoEmpty() -> Array[]
    | MInfoSingle(x) -> Array[x]
    | MInfoFull(keys, _, _) -> keys
    }
  }

  fun getNewDirs(): Array<DirName> {
    this match {
    | MInfoEmpty() -> Array[]
    | MInfoSingle(_) -> Array[]
    | MInfoFull(_, dirs, _) -> dirs
    }
  }
  fun getReads(): Array<Path> {
    this match {
    | MInfoEmpty() -> Array[]
    | MInfoSingle(_) -> Array[]
    | MInfoFull(_, _, reads) -> reads
    }
  }

  static fun create(
    keys: Array<Key>,
    newDirs: Array<DirName>,
    reads: Array<Path>,
  ): MInfo {
    if (keys.isEmpty() && newDirs.isEmpty() && reads.isEmpty()) {
      return MInfoEmpty()
    };
    if (keys.size() == 1 && newDirs.isEmpty() && reads.isEmpty()) {
      return MInfoSingle(keys[0])
    };
    MInfoFull(keys, newDirs, reads)
  }

  static fun empty(): MInfo {
    MInfoEmpty()
  }

  fun isEmpty(): Bool {
    this is MInfoEmpty()
  }

  fun setNewDirs(newDirs: Array<DirName>): MInfo {
    this match {
    | MInfoEmpty() ->
      if (newDirs.isEmpty()) return this;
      MInfoFull(Array[], newDirs, Array[])
    | MInfoSingle(key) ->
      if (newDirs.isEmpty()) return this;
      MInfoFull(Array[key], newDirs, Array[])
    | MInfoFull(keys, _, reads) -> static::create(keys, newDirs, reads)
    }
  }
}

/*****************************************************************************/
/* The class used for subscriptions. */
/*****************************************************************************/

@cpp_extern("SKIP_notify")
native fun unixNotify(String, Int32): Int32;

/*****************************************************************************/
/* The map containing the new data. */
/*****************************************************************************/

class DataMapValue{
  map: DMap<Path, (Path, Array<File>)> = DMap::empty(),
  tombs: DMap<Path, Path> = DMap::empty(),
} {
  static fun empty(): this {
    static{}
  }

  fun isEmpty(): Bool {
    this.map.isEmpty() && this.tombs.isEmpty()
  }

  fun set(
    tick: Tick,
    isMasking: Bool,
    origSource: Path,
    writer: Path, // different to origSource when explicitly tombstoning
    files: Array<File>,
  ): this {
    invariant(files.isEmpty() || origSource == writer);
    if (files.isEmpty()) {
      if (isMasking) {
        // mask out fixed data, for when you're iterating without tombs.
        !this.map = this.map.set(
          TickRange::create(tick),
          origSource,
          (writer, files),
        )
      } else {
        this.map.maybeGet(origSource) match {
        | None() -> void
        | Some _ -> !this.map = this.map.remove(origSource)
        };
      };
      !this.tombs = this.tombs.set(TickRange::create(tick), origSource, writer);
    } else {
      if (this.tombs.containsKey(origSource)) {
        !this.tombs = this.tombs.remove(origSource)
      };
      !this.map = this.map.set(
        TickRange::create(tick),
        origSource,
        (writer, files),
      );
    };
    this
  }

  fun itemsAfter(
    limit: Tick,
  ): mutable Iterator<(Tick, Path, Path, Array<File>)> {
    mapIter = this.map.getChangesAfterIter(limit);
    tombsIter = this.tombs.getChangesAfterIter(limit);
    left = mapIter.next();
    right = tombsIter.next();
    loop {
      (left, right) match {
      | (None(), None()) -> break void
      | (None(), Some((tick, v, w))) ->
        yield (tick, v, w, Array[]);
        !right = tombsIter.next()
      | (Some((tick, k, (w, v))), None()) ->
        yield (tick, k, w, v);
        !left = mapIter.next()
      | (Some((tick, k, (w, v))), Some((_, k2, _))) if (k < k2) ->
        yield (tick, k, w, v);
        !left = mapIter.next()
      | (Some((t1, k1, _)), Some((t2, k2, w))) if (k1 == k2 && t1 == t2) ->
        yield (t2, k2, w, Array[]);
        !left = mapIter.next();
        !right = tombsIter.next()
      | (Some(_), Some((tick, k2, w))) ->
        yield (tick, k2, w, Array[]);
        !right = tombsIter.next()
      }
    }
  }

  fun items(): mutable Iterator<((Tick, Path, Path), Array<File>)> {
    mapIter = this.map.itemsWithTick();
    tombsIter = this.tombs.itemsWithTick();
    left = mapIter.next();
    right = tombsIter.next();
    loop {
      (left, right) match {
      | (None(), None()) -> break void
      | (None(), Some((v, w, tick))) ->
        yield ((tick.current, v, w), Array[]);
        !right = tombsIter.next()
      | (Some((k, (w, v), tick)), None()) ->
        yield ((tick.current, k, w), v);
        !left = mapIter.next()
      | (Some((k, (w, v), tick)), Some((k2, _, _))) if (k < k2) ->
        yield ((tick.current, k, w), v);
        !left = mapIter.next()
      | (Some((k, (w, v), tick)), Some((k2, _, _))) if (k == k2) ->
        yield ((tick.current, k, w), v);
        !left = mapIter.next();
        !right = tombsIter.next()
      | (Some(_), Some((k2, w, tick))) ->
        yield ((tick.current, k2, w), Array[]);
        !right = tombsIter.next()
      }
    }
  }

  fun maybeGet(source: Path): ?Array<File> {
    this.map.maybeGet(source) match {
    | None() -> if (this.tombs.containsKey(source)) Some(Array[]) else None()
    | Some(x) -> Some(x.i1)
    }
  }
}

class DataMap{
  data: DMap<Key, DMap<Path, (Path, Array<File>)>> = Nil(),
  tombs: DMap<Key, DMap<Path, Path>> = Nil(),
  nbrEntries: Int = 0,
} {
  static fun empty(): this {
    DataMap{}
  }

  fun set(tickRange: TickRange, key: Key, value: DataMapValue): this {
    if (value.map.isEmpty()) {
      if (this.data.containsKey(key)) {
        !this.data = this.data.remove(key)
      }
    } else {
      if (!this.data.containsKey(key)) {
        !this.nbrEntries = this.nbrEntries + 1;
      };
      !this.data = this.data.set(tickRange, key, value.map)
    };
    if (value.tombs.isEmpty()) {
      if (this.tombs.containsKey(key)) {
        !this.tombs = this.tombs.remove(key);
      }
    } else {
      if (!this.tombs.containsKey(key)) {
        !this.nbrEntries = this.nbrEntries + 1;
      };
      !this.tombs = this.tombs.set(tickRange, key, value.tombs);
    };
    this
  }

  fun maybeGet(k: Key): ?DataMapValue {
    (this.data.maybeGet(k), this.tombs.maybeGet(k)) match {
    | (None(), None()) -> None()
    | (Some(map), None()) -> Some(DataMapValue{map, tombs => DMap::empty()})
    | (None(), Some(tombs)) -> Some(DataMapValue{map => DMap::empty(), tombs})
    | (Some(map), Some(tombs)) -> Some(DataMapValue{map, tombs})
    }
  }

  fun getTick(): ?Tick {
    optFTick = this.tombs.getLastTick();
    optDTick = this.data.getLastTick();
    (optFTick, optDTick) match {
    | (None(), None()) -> None()
    | (Some(t), None())
    | (None(), Some(t)) ->
      Some(t)
    | (Some(ft), Some(dt)) -> Some(max(ft, dt))
    }
  }

  fun eachWithTick(f: (Key, Tick) -> void): void {
    dataIter = this.data.itemsWithTick();
    tombsIter = this.tombs.itemsWithTick();
    left = dataIter.next();
    right = tombsIter.next();
    loop {
      (left, right) match {
      | (None(), None()) -> break void
      | (Some((k, _, tick)), None()) ->
        f(k, tick.current);
        !left = dataIter.next()
      | (None(), Some((k, _, tick))) ->
        f(k, tick.current);
        !right = tombsIter.next()
      | (Some((k1, _, tick)), Some((k2, _, _))) if (k1 < k2) ->
        f(k1, tick.current);
        !left = dataIter.next()
      | (Some((k1, _, _)), Some((k2, _, tick))) if (k1 > k2) ->
        f(k2, tick.current);
        !right = tombsIter.next()
      | (Some((k, _, tick1)), Some((_, _, tick2))) ->
        invariant(tick1.current == tick2.current);
        f(k, tick1.current);
        !left = dataIter.next();
        !right = tombsIter.next()
      }
    }
  }

  fun getChangesAfter(tick: Tick): SortedSet<Key> {
    this.data.getChangesAfter(tick).union(this.tombs.getChangesAfter(tick))
  }

  fun items(): mutable Iterator<(Key, DataMapValue)> {
    dataIter = this.data.itemsWithTick();
    tombsIter = this.tombs.itemsWithTick();
    left = dataIter.next();
    right = tombsIter.next();
    loop {
      (left, right) match {
      | (None(), None()) -> break void
      | (Some((k, map, _)), None()) ->
        yield (k, DataMapValue{map, tombs => DMap::empty()});
        !left = dataIter.next()
      | (None(), Some((k, tombs, _))) ->
        yield (k, DataMapValue{map => DMap::empty(), tombs});
        !right = tombsIter.next()
      | (Some((k1, map, _)), Some((k2, _, _))) if (k1 < k2) ->
        yield (k1, DataMapValue{map, tombs => DMap::empty()});
        !left = dataIter.next()
      | (Some((k1, _, _)), Some((k2, tombs, _))) if (k1 > k2) ->
        yield (k2, DataMapValue{map => DMap::empty(), tombs});
        !right = tombsIter.next()
      | (Some((k, map, _)), Some((_, tombs, _))) ->
        yield (k, DataMapValue{map, tombs});
        !left = dataIter.next();
        !right = tombsIter.next()
      }
    }
  }

  fun itemsAfterKeyHelper(
    lastSkippedOpt: ?Boundary<Key>,
  ): mutable Iterator<(Key, DMap<Path, (Path, Array<File>)>)> {
    this.data.itemsAfterKey(lastSkippedOpt).iter
  }

  fun itemsAfterKey(
    lastSkippedOpt: ?Boundary<Key>,
  ): mutable IterHolder<Key, DMap<Path, (Path, Array<File>)>> {
    mutable IterHolder(this.itemsAfterKeyHelper(lastSkippedOpt))
  }

  fun getHeight(): Int {
    this.data.getHeight()
  }

  fun remove(k: Key): this {
    !this.data = this.data.remove(k);
    !this.tombs = this.tombs.remove(k);
    this
  }
}

class FixedDataMap{data: FixedData<Array<File>>, tombs: FixedDir<Path>} {
  static fun create(
    vec: mutable Vector<FixedRow<Array<File>>> = mutable Vector[],
    tombs: mutable Vector<FixedRow<Path>> = mutable Vector[],
  ): this {
    data = IFixedDir::getMetadata(vec) match {
    | None() -> FixedDir::create(vec)
    | Some(metadata) -> CompactFixedDir::create(vec, metadata)
    };
    static{data, tombs => FixedDir::create(tombs)}
  }

  fun size(): Int {
    this.data.size() + this.tombs.size()
  }

  fun getTick(): ?Tick {
    optFTick = this.tombs.getTick();
    optDTick = this.data.getTick();
    (optFTick, optDTick) match {
    | (None(), None()) -> None()
    | (Some(t), None())
    | (None(), Some(t)) ->
      Some(t)
    | (Some(ft), Some(dt)) -> Some(max(ft, dt))
    }
  }

  fun getChangesAfter(tick: Tick): SortedSet<Key> {
    this.data.getChangesAfter(tick).union(this.tombs.getChangesAfter(tick))
  }

  fun getIterAll(): mutable Iterator<(Tick, Path, Path, Key, Array<File>)> {
    iter1 = this.data.iterator();
    iter2 = this.tombs.data.iterator();
    left = iter1.next();
    right = iter2.next();
    loop {
      (left, right) match {
      | (None(), None()) -> break void
      | (Some(x), None()) ->
        !left = iter1.next();
        yield (x.tag.current, x.source, x.source, x.key, x.value)
      | (None(), Some(y)) ->
        !right = iter2.next();
        yield (y.tag.current, y.source, y.value, y.key, Array[])
      | (Some(x), Some(y)) ->
        if ((x.key, x.source) < (y.key, y.source)) {
          !left = iter1.next();
          yield (x.tag.current, x.source, x.source, x.key, x.value)
        } else if ((x.key, x.source) > (y.key, y.source)) {
          !right = iter2.next();
          yield (y.tag.current, y.source, y.value, y.key, Array[])
        } else {
          invariant_violation("Found a non-empty tomb (getIterAll)");
        }
      }
    }
  }

  fun getIter(key: Key): mutable Iterator<(Tick, Path, Path, Array<File>)> {
    iter1 = this.data.getIter(key);
    iter2 = this.tombs.getIter(key);
    left = iter1.next();
    right = iter2.next();
    loop {
      (left, right) match {
      | (None(), None()) -> break void
      | (Some(x), None()) ->
        !left = iter1.next();
        yield (x.i0, x.i1, x.i1, x.i2)
      | (None(), Some(y)) ->
        !right = iter2.next();
        yield (y.i0, y.i1, y.i2, Array[])
      | (Some(x), Some(y)) ->
        if (x.i1 < y.i1) {
          !left = iter1.next();
          yield (x.i0, x.i1, x.i1, x.i2)
        } else if (x.i1 > y.i1) {
          !right = iter2.next();
          yield (y.i0, y.i1, y.i2, Array[])
        } else {
          invariant_violation("Found a non-empty tomb (getIter)");
        }
      }
    }
  }

  fun getIterAfter(
    tick: Tick,
    key: Key,
  ): mutable Iterator<(Tick, Path, Path, Array<File>)> {
    iter1 = this.data.getIterAfter(tick, key);
    iter2 = this.tombs.getIterAfter(tick, key);
    left = iter1.next();
    right = iter2.next();
    loop {
      (left, right) match {
      | (None(), None()) -> break void
      | (Some(x), None()) ->
        !left = iter1.next();
        yield (x.i0, x.i1, x.i1, x.i2)
      | (None(), Some(y)) ->
        !right = iter2.next();
        yield (y.i0, y.i1, y.i2, Array[])
      | (Some(x), Some(y)) ->
        if (x.i1 < y.i1) {
          !left = iter1.next();
          yield (x.i0, x.i1, x.i1, x.i2)
        } else if (x.i1 > y.i1) {
          !right = iter2.next();
          yield (y.i0, y.i1, y.i2, Array[])
        } else {
          invariant_violation("Found a non-empty tomb (getIterAfter)");
        }
      }
    }
  }
}

mutable class FixedDataMapIterator<T> private {
  iter: mutable Iterator<T>,
  mutable currentOpt: ?T = None(),
} {
  static fun create(iter: mutable Iterator<T>): mutable this {
    mutable static{currentOpt => iter.next(), iter => iter}
  }

  readonly fun isEnd(): Bool {
    this.currentOpt is None _
  }

  readonly fun current(): T {
    this.currentOpt match {
    | None() -> invariant_violation("Cannot access current")
    | Some(x) -> x
    }
  }

  mutable fun next(): void {
    this.!currentOpt = this.iter.next();
  }
}

/*****************************************************************************/
/* An Eager Directory. */
/*****************************************************************************/

class EagerDir{
  time: Time,
  dirName: DirName,
  input: Bool,
  fixedData: FixedDataMap,
  totalSize: Int,
  creator: ?ArrowKey,
  fixedOld: FixedSourceMap = FixedSourceMap::empty(),
  data: DataMap = DataMap::empty(),
  old: SortedMap<Path, MInfo> = SortedMap[],
  parents: FixedSingle<
    DirName,
    Array<
      (MapFun, ?Array<KeyRange>, ?((mutable Context, SortedSet<Key>) ~> void)),
    >,
  > = FixedSingle::empty(),
  childDirs: SortedSet<DirName> = SortedSet[],
  slices: RangeMapList<Key, DirName> = RangeMapList[],
  reducer: ?Reducer = None(),
  purgeCount: Int = 0,
  tombLimit: ?Tick = None(),
} extends Dir {
  fun reset(
    context: mutable SKStore.Context,
    writer: Path,
    keep: SortedSet<Key>,
    isVisible: Key -> Bool = _ -> true,
    wasSeen: (Tick, Path) ~> Bool = (_, _) ~> true,
  ): this {
    this.unsafeGetFileIter().each(kv -> {
      (key, valueIter) = kv;
      if (!keep.contains(key) && isVisible(key)) {
        valueIter.next() match {
        | None() -> void
        | Some _ ->
          this.unsafeGetDataIterWithoutTombs(key).each(kv -> {
            (tick, source, _values) = kv;
            // do not wipe out data that has not yet been seen
            if (wasSeen(tick, source)) {
              !this = this.writeEntry(context, source, writer, key, Array[])
            }
          })
        }
      }
    });
    context.!toReset = context.toReset.set(this.dirName);

    this
  }

  fun writeDiff(
    context: readonly SKStore.Context,
    isReset: Bool,
    changes: mutable Iterator<SKStore.Key>,
    writer: mutable Debug.BufferedWriter,
    entity: String, // the name that this dir goes under during replication
    format: OutputFormat,
    filter: (SKStore.Context, Bool) ~> (SKStore.Key -> Bool),
    destinationTime: ?Tick,
    checkpointInterval: Int = Int::max,
  ): Bool {
    filterFun = filter(context.clone(), isReset);

    changesWritten = 0;

    for (key in changes) {
      if (!filterFun(key)) continue;
      if (changesWritten % checkpointInterval == 0) {
        // output a header for the dir
        theirTime = destinationTime match {
        | None() -> ""
        | Some(t) -> " " + t.value.toString()
        };
        writer.write(`^${entity}${theirTime}\n`)
      };
      values = this.getArrayRaw(key);
      if (values.size() == 0) {
        writer.write(key.toKVStringRemove(format))
      } else {
        key.writeKVString(writer.write, format, values);
      };
      !changesWritten = changesWritten + 1;
      if (changesWritten % checkpointInterval == 0) {
        writer.write(":0\n");
        writer.flush();
        flushStdout();
      };
    };

    if (isReset) {
      if (changesWritten % checkpointInterval == 0) {
        // output a header for the dir
        theirTime = destinationTime match {
        | None() -> ""
        | Some(t) -> " " + t.value.toString()
        };
        writer.write(`^${entity}${theirTime}\n`)
      };
      // Indicates a reset, meaning all the data that was not in
      // this transaction should be removed.
      writer.write("\t\t\n");
      return true
    };

    changesWritten > 0
  }

  fun purgeOld(): FixedSourceMap {
    current = 0;
    acc = mutable Vector[];
    add = minfo -> {
      if (!(minfo.i1 is MInfoEmpty())) {
        acc.push(minfo)
      }
    };
    for (source => minfo in this.old) {
      while (
        current < this.fixedOld.size() &&
        this.fixedOld[current].i0 < source
      ) {
        add(this.fixedOld[current]);
        !current = current + 1;
      };
      while (
        current < this.fixedOld.size() &&
        this.fixedOld[current].i0 == source
      ) {
        !current = current + 1;
      };
      if (!minfo.isEmpty()) {
        add((source, minfo));
      }
    };
    while (current < this.fixedOld.size()) {
      add(this.fixedOld[current]);
      !current = current + 1;
    };
    FixedSourceMap::create(acc)
  }

  private fun flattenData(limit: Tick): FixedDataMap {
    withRegionValue(() ~> {
      fixedIter = FixedDataMapIterator::create(this.fixedData.getIterAll());
      data = Vector::mcreate(
        this.fixedData.data.size() + 1.shl(this.data.data.getHeight()),
      );
      tombs = Vector::mcreate(
        this.fixedData.tombs.size() + 1.shl(this.data.tombs.getHeight()),
      );
      lastOpt: ?(Tick, Path, Path, Key, Array<File>) = None();

      addHelper = lastRow -> {
        if (lastRow.i4.size() > 0) {
          data.push(
            FixedRow(
              lastRow.i3,
              lastRow.i4,
              lastRow.i1,
              TickRange::create(lastRow.i0),
            ),
          );
        } else if (lastRow.i0 > limit) {
          tombs.push(
            FixedRow(
              lastRow.i3,
              lastRow.i2,
              lastRow.i1,
              TickRange::create(lastRow.i0),
            ),
          );
        }
      };

      add = fixedRow -> {
        lastOpt match {
        | Some(
          lastRow,
        ) if (fixedRow.i3 != lastRow.i3 || fixedRow.i1 != lastRow.i1) ->
          addHelper(lastRow)
        | _ -> void
        };
        !lastOpt = Some(fixedRow)
      };

      for (key => map in this.data) {
        while (!fixedIter.isEnd() && fixedIter.current().i3 < key) {
          add(fixedIter.current());
          fixedIter.next();
        };
        for (tickSource => values in map) {
          (tick, source, writer) = tickSource;
          while (
            !fixedIter.isEnd() &&
            fixedIter.current().i3 == key &&
            fixedIter.current().i1 < source
          ) {
            add(fixedIter.current());
            fixedIter.next();
          };
          add((tick, source, writer, key, values));
          while (
            !fixedIter.isEnd() &&
            fixedIter.current().i3 == key &&
            fixedIter.current().i1 == source
          ) {
            fixedIter.next();
          };
        };
        while (!fixedIter.isEnd() && fixedIter.current().i3 == key) {
          add(fixedIter.current());
          fixedIter.next();
        };
      };

      while (!fixedIter.isEnd()) {
        add(fixedIter.current());
        fixedIter.next();
      };

      lastOpt match {
      | None() -> void
      | Some(lastRow) -> addHelper(lastRow)
      };

      FixedDataMap::create(data, tombs)
    });
  }

  fun purge(context: mutable Context, limit: Tick): this {
    this.tombLimit match { // tombLimit must be monotonic
    | Some(tombLimit) if (limit.value <= tombLimit.value) -> return this
    | _ -> void
    };
    fixedOld = this.purgeOld();
    fixedData = this.flattenData(limit);
    context.!purgeLimit = Some(limit);
    this with {
      tombLimit => Some(limit),
      data => DataMap::empty(),
      old => SortedMap[],
      fixedData,
      fixedOld,
    }
  }

  fun isInput(): Bool {
    this.input
  }

  fun getTime(): Time {
    this.time
  }

  private fun getAllKeysWithValues(): SortedSet<Key> {
    result = SortedSet[];
    this.unsafeGetFileIter().each(kv -> {
      (key, valueIter) = kv;
      valueIter.next() match {
      | None() -> void
      | Some _ -> !result = result.set(key)
      }
    });
    result
  }

  fun getChangesAfter(
    tick: Tick,
    forceReset: Bool = false,
  ): (Bool, SortedSet<Key>) {
    this.tombLimit match {
    | _ if (forceReset) -> return (true, this.getAllKeysWithValues())
    | Some(limit) if (tick.value <= limit.value) ->
      return (true, this.getAllKeysWithValues())
    | _ -> void
    };
    new = this.data.getChangesAfter(tick);
    old = this.fixedData.getChangesAfter(tick);
    result = new.union(old);
    (false, result)
  }

  fun getLastTick(): ?Tick {
    optFTick = this.fixedData.getTick();
    optDTick = this.data.getTick();
    (optFTick, optDTick) match {
    | (None(), None()) -> None()
    | (Some(t), None())
    | (None(), Some(t)) ->
      Some(t)
    | (Some(ft), Some(dt)) -> Some(max(ft, dt))
    }
  }

  private static fun fixedMapData(
    context: mutable Context,
    oldVec: mutable Vector<(Path, MInfo)>,
    parent: EagerDir,
    childName: DirName,
    f: MapFun,
    acc: mutable Vector<FixedRow<Array<File>>>,
    current: mutable IntRef,
  ): void {
    key = parent.fixedData.data[current.value].key;
    // fast path
    if (
      parent.reducer is None() &&
      current.value + 1 < parent.fixedData.data.size() &&
      parent.fixedData.data[current.value + 1].key != key
    ) {
      fixedFiles = parent.fixedData.data[current.value].value.iterator();
      static::mapRow(
        context,
        acc,
        oldVec,
        parent.dirName,
        childName,
        key,
        fixedFiles,
        f,
      );
      current.incr();
      return void;
    };

    valueAcc = mutable Vector[];
    while (
      current.value < parent.fixedData.data.size() &&
      parent.fixedData.data[current.value].key == key
    ) {
      for (elt in parent.fixedData.data[current.value].value) {
        valueAcc.push(elt);
      };
      current.incr();
    };
    fixedFiles = parent.reducer match {
    | None() -> valueAcc.iterator()
    | Some(compact) -> compact.getArray(key).iterator()
    };
    static::mapRow(
      context,
      acc,
      oldVec,
      parent.dirName,
      childName,
      key,
      fixedFiles,
      f,
    );
  }

  private static fun subMapData(
    obstack: Obstack,
    context: mutable Context,
    parent: EagerDir,
    childName: DirName,
    f: MapFun,
    currentStart: Int,
    currentEnd: Int,
    start: ?Boundary<Key>,
    end: ?Key,
  ): (
    readonly Vector<FixedRow<Array<File>>>,
    readonly Vector<(Path, MInfo)>,
    ?Key,
    Int,
  ) {
    acc = mutable Vector[];
    oldVec = mutable Vector[];
    current = mutable IntRef(currentStart);
    size = 0;

    for (key => _ in parent.data.itemsAfterKey(start)) {
      end match {
      | Some(endKey) if (key > endKey) -> break void
      | _ -> void
      };
      while (
        current.value <= currentEnd &&
        parent.fixedData.data[current.value].key < key
      ) {
        fixedKey = parent.fixedData.data[current.value].key;
        static::fixedMapData(
          context,
          oldVec,
          parent,
          childName,
          f,
          acc,
          current,
        );
        !size = size + 1;
        if (shouldGC(obstack) != 0) {
          return (acc, oldVec, Some(fixedKey), current.value);
        }
      };
      while (
        current.value <= currentEnd &&
        parent.fixedData.data[current.value].key == key
      ) {
        current.incr();
      };

      static::mapRow(
        context,
        acc,
        oldVec,
        parent.dirName,
        childName,
        key,
        parent.getIterRaw(key),
        f,
      );
      !size = size + 1;
      if (shouldGC(obstack) != 0) {
        return (acc, oldVec, Some(key), current.value);
      }
    };

    while (current.value <= currentEnd) {
      fixedKey = parent.fixedData.data[current.value].key;
      static::fixedMapData(context, oldVec, parent, childName, f, acc, current);
      !size = size + 1;
      if (shouldGC(obstack) != 0) {
        return (acc, oldVec, Some(fixedKey), current.value);
      }
    };
    (acc, oldVec, None(), current.value)
  }

  private static fun mapData(
    context: mutable Context,
    oldVec: mutable Vector<(Path, MInfo)>,
    parent: EagerDir,
    childName: DirName,
    f: MapFun,
    acc: mutable Vector<FixedRow<Array<File>>>,
    rangeOpt: ?KeyRange,
  ): void {
    last: ?Boundary<Key> = rangeOpt match {
    | None() -> None()
    | Some(range) -> Some(Inclusive(range.start))
    };
    current = rangeOpt match {
    | None() -> 0
    | Some(range) ->
      pos = parent.fixedData.data.getPos(range.start);
      if (pos < 0) 0 else pos
    };
    end = rangeOpt.map(r -> r.end);
    currentEnd = end match {
    | None() -> parent.fixedData.data.size() - 1
    | Some(key) ->
      pos = parent.fixedData.data.getPos(key);
      if (
        pos < parent.fixedData.data.size() &&
        parent.fixedData.data[pos].key != key
      ) {
        !pos = pos - 1;
      };
      min(parent.fixedData.data.size() - 1, pos)
    };

    loop {
      lcurrent = current;
      llast = last;

      (localAcc, localOldVec, lastSkipped, !current) = withRegion(
        context,
        (obstack, context) ~> {
          static::subMapData(
            obstack,
            context,
            parent,
            childName,
            f,
            lcurrent,
            currentEnd,
            llast,
            end,
          );
        },
      );

      acc.extend(localAcc);
      oldVec.extend(localOldVec);

      !last = lastSkipped.map(x -> Exclusive(x));
      if (last is None _) {
        break void;
      }
    };
  }

  private static fun mapRow(
    context: mutable Context,
    acc: mutable Vector<FixedRow<Array<File>>>,
    oldVec: mutable Vector<(Path, MInfo)>,
    parentName: DirName,
    childName: DirName,
    key: Key,
    valueIter: mutable Iterator<File>,
    f: MapFun,
  ): void {
    arrow = ArrowKey(parentName, childName, key);
    context.enter(arrow);

    if (context.debugMode) {
      print_string(`MAP_ROW: ${parentName} ${key}`);
    };

    newDirsCopy = context.newDirs;
    readsCopy = context.reads;

    context.!newDirs = SortedSet[];
    context.!reads = SortedSet[];

    writer = mutable Writer{};
    f(context, writer, key, valueIter);

    kvArray = writer.getWrites();
    newDirs = context.newDirs;
    reads = context.getReads();
    context.!newDirs = newDirsCopy;
    context.!reads = readsCopy;

    context.updateNewDeps(ArrowKey(parentName, childName, key), reads);

    source = Path(parentName, key);

    for (kv in kvArray) {
      (k, v) = kv;
      acc.push(FixedRow(k, v, source, TickRange::create(context.tick)))
    };

    if (!kvArray.isEmpty() || !newDirs.isEmpty()) {
      oldVec.push(
        (
          source,
          MInfo::create(
            kvArray.map(kv -> kv.i0),
            newDirs.toArray(),
            reads.toArray(),
          ),
        ),
      );
    };

    context.leave(arrow);
  }

  static fun isReusable(
    context: readonly Context,
    child: EagerDir,
    parents: FixedSingle<
      DirName,
      Array<
        (
          MapFun,
          ?Array<KeyRange>,
          ?((mutable Context, SortedSet<Key>) ~> void),
        ),
      >,
    >,
  ): Bool {
    context.canReuse match {
    | CRAlways() -> true
    | CRNever() -> false
    | CRIfMatch() ->
      same = (native_eq(parents, child.parents) == 0);
      if (same && child.creator != context.currentArrow()) {
        invariant_violation(
          "Duplicate subdirectory: " +
            child.dirName.toString() +
            "\nFirst created: " +
            inspect(child.creator).toString() +
            "\nThen: " +
            inspect(context.currentArrow()).toString(),
        );
      };
      same
    }
  }

  static fun reuseDir(context: mutable Context, childName: DirName): void {
    if (context.debugMode) {
      print_string(`REUSING: ${childName}`);
    };
    context.!newDirs = context.newDirs.set(childName);
  }

  static fun apply(
    context: mutable Context,
    parentName: DirName,
    childName: DirName,
    f: MapFun,
    reducerOpt: ?IReducer = None(),
    rangeOpt: ?Array<KeyRange> = None(),
    onUpdate: ?((mutable Context, SortedSet<Key>) ~> void) = None(),
    unsafeSkipInit: Bool = false,
  ): void {
    parents = FixedSingle::create(
      mutable Vector[(parentName, Array[(f, rangeOpt, onUpdate)])],
    );
    static::applyMany(context, parents, childName, reducerOpt, unsafeSkipInit);
  }

  static fun applyMany(
    context: mutable Context,
    parents: FixedSingle<
      DirName,
      Array<
        (
          MapFun,
          ?Array<KeyRange>,
          ?((mutable Context, SortedSet<Key>) ~> void),
        ),
      >,
    >,
    childName: DirName,
    reducerOpt: ?IReducer = None(),
    unsafeSkipInit: Bool = false,
  ): void {
    context.unsafeMaybeGetEagerDir(childName) match {
    | Some(child) if (static::isReusable(context, child, parents)) ->
      static::reuseDir(context, childName);
      return void
    | _ -> void
    };

    if (context.newDirs.contains(childName)) {
      error(`Error: directory ${childName.toString()} already exists`);
    };

    globalName = "PRE_COMPUTED_" + childName;

    dir = context.getGlobal(globalName) match {
    | Some(x @ EagerDir _) ->
      invariant(x.creator == context.currentArrow());
      context.removeGlobal(globalName);
      x
    | _ ->
      context.!newDirs = context.newDirs.add(childName);

      acc = mutable Vector[];
      oldVec = mutable Vector[];

      if (!unsafeSkipInit) {
        for (parentName => parentData in parents) {
          for (p in parentData) {
            (f, rangeOpt, _) = p;
            parent = context.unsafeGetEagerDir(parentName);
            rangeOpt match {
            | None() ->
              static::mapData(
                context,
                oldVec,
                parent,
                childName,
                f,
                acc,
                None(),
              )
            | Some(ranges) ->
              for (range in ranges) {
                static::mapData(
                  context,
                  oldVec,
                  parent,
                  childName,
                  f,
                  acc,
                  Some(range),
                );
              }
            }
          }
        }
      };

      fixedData = FixedDataMap::create(acc);
      time = context.timeStamp();
      totalSize = acc.size();
      reducer = reducerOpt.map(ireducer ->
        Reducer::create(fixedData, ireducer)
      );

      if (context.debugMode) {
        parentNames = parents
          .items()
          .map(x -> (x.i0, x.i1.map(p -> p.i1)))
          .collect(Array);
        print_string(
          `CREATED:  ${childName} (time: ${time}, parents: ${parentNames})`,
        );
      };

      data = DataMap::empty();
      fixedOld = FixedSourceMap::create(oldVec, true);

      EagerDir{
        time,
        dirName => childName,
        input => false,
        parents,
        fixedData,
        data,
        totalSize,
        creator => context.currentArrow(),
        fixedOld,
        childDirs => SortedSet[],
        reducer,
      }
    };
    updateDirtyReaders(context, Path::create(childName.tag(), DirTag()));
    context.setDir(childName, dir);
    for (parentName => parentData in parents) {
      for (p in parentData) {
        (_, rangeOpt, _) = p;
        static::addChildToParent(context, parentName, childName, rangeOpt);
      }
    };
  }

  static fun addChildToParent(
    context: mutable Context,
    parentName: DirName,
    childName: DirName,
    rangeOpt: ?Array<KeyRange>,
  ): void {
    parent = context.unsafeGetEagerDir(parentName);
    rangeOpt match {
    | None() -> !parent.childDirs = parent.childDirs.set(childName)
    | Some(ranges) ->
      for (range in ranges) {
        !parent.purgeCount = parent.purgeCount + 1;
        !parent.slices = parent.slices.add(range.start, range.end, childName)
      }
    };
    if (parent.purgeCount >= PURGE_LIMIT) {
      !parent = parent with {
        slices => parent.purgeSlices(context),
        purgeCount => 0,
      };
    };
    context.setDir(parent.dirName, parent);
  }

  fun getArrayRaw(key: Key): Array<File> {
    this.getIterRaw(key).collect(Array);
  }

  fun unsafeGetAllDataIterAfter(
    limit: Tick,
    key: Key,
  ): mutable Iterator<(Tick, Path, Path, Array<File>)> {
    this.data.maybeGet(key) match {
    | None() ->
      fixedIter = this.fixedData.getIterAfter(limit, key);
      for (row in fixedIter) {
        yield row
      }
    | Some(modified) ->
      fixed = FixedDataMapIterator::create(
        this.fixedData.getIterAfter(limit, key),
      );

      for (tickSourceWriterFiles in modified.itemsAfter(limit)) {
        (tick, source, writer, files) = tickSourceWriterFiles;
        while (!fixed.isEnd() && fixed.current().i1 < source) {
          yield fixed.current();
          fixed.next();
        };
        while (!fixed.isEnd() && fixed.current().i1 == source) {
          fixed.next();
        };
        yield (tick, source, writer, files);
      };
      while (!fixed.isEnd()) {
        yield fixed.current();
        fixed.next();
      }
    }
  }

  fun unsafeGetAllDataIter(
    key: Key,
  ): mutable Iterator<(Tick, Path, Path, Array<File>)> {
    fixedIter = this.fixedData.getIter(key);
    this.data.maybeGet(key) match {
    | None() ->
      for (row in fixedIter) {
        yield row
      }
    | Some(modified) ->
      fixed = FixedDataMapIterator::create(fixedIter);

      for (tickSourceWriter => files in modified) {
        (tick, source, writer) = tickSourceWriter;
        while (!fixed.isEnd() && fixed.current().i1 < source) {
          yield fixed.current();
          fixed.next();
        };
        while (!fixed.isEnd() && fixed.current().i1 == source) {
          fixed.next();
        };
        yield (tick, source, writer, files);
      };
      while (!fixed.isEnd()) {
        yield fixed.current();
        fixed.next();
      }
    }
  }

  fun unsafeGetDataIterWithoutTombs(
    key: Key,
  ): mutable Iterator<(Tick, Path, Array<File>)> {
    fixedIter = this.fixedData.getIter(key);
    this.data.maybeGet(key) match {
    | None() ->
      for (rows in fixedIter) {
        if (rows.i3.size() > 0) {
          yield (rows.i0, rows.i1, rows.i3);
        }
      }
    | Some(modified) ->
      fixed = FixedDataMapIterator::create(this.fixedData.getIter(key));

      for (sourceFilesTick in modified.map.itemsWithTick()) {
        (source, (_writer, files), tickRange) = sourceFilesTick;
        tick = tickRange.current;
        while (!fixed.isEnd() && fixed.current().i1 < source) {
          if (fixed.current().i3.size() > 0) {
            yield (fixed.current().i0, fixed.current().i1, fixed.current().i3);
          };
          fixed.next();
        };
        while (!fixed.isEnd() && fixed.current().i1 == source) {
          fixed.next();
        };
        if (files.size() > 0) {
          yield (tick, source, files);
        }
      };
      while (!fixed.isEnd()) {
        if (fixed.current().i3.size() > 0) {
          yield (fixed.current().i0, fixed.current().i1, fixed.current().i3);
        };
        fixed.next();
      }
    }
  }

  private fun getIterRaw(key: Key): mutable Iterator<File> {
    this.reducer match {
    | None() ->
      for (arr in this.unsafeGetDataIterWithoutTombs(key)) {
        for (elt in arr.i2) {
          yield elt
        }
      }
    | Some(compact) ->
      for (elt in compact.getArray(key)) {
        yield elt
      }
    }
  }

  private fun getArraySourceKey(source: Path, key: Key): Array<File> {
    this.data.maybeGet(key) match {
    | None() -> this.fixedData.data.getArraySourceKey(source, key).flatten()
    | Some(modified) ->
      modified.maybeGet(source) match {
      | None() -> this.fixedData.data.getArraySourceKey(source, key).flatten()
      | Some(v) -> v
      }
    }
  }

  static fun update(
    context: mutable Context,
    contextDirty: readonly Map<DirName, SortedSet<Key>>,
    contextDirtyReaders: readonly Map<
      DirName,
      readonly Map<DirName, SortedSet<Key>>,
    >,
    parentName: DirName,
    parentMaps: Array<
      (MapFun, ?Array<KeyRange>, ?((mutable Context, SortedSet<Key>) ~> void)),
    >,
    childRef: EagerDir,
  ): void {
    parent = context.unsafeGetEagerDir(parentName);
    childName = childRef.dirName;

    dirty = SortedSet[];
    if (contextDirtyReaders.containsKey(parent.dirName)) {
      if (contextDirtyReaders[parent.dirName].containsKey(childName)) {
        keys = contextDirtyReaders[parent.dirName][childName].values();
        !dirty = withRegionFold(None(), keys, dirty, (_, key, dirtyInRegion) ~> {
          for (p in parentMaps) {
            (_, rangeOpt, _) = p;
            rangeOpt match {
            | Some(
              ranges,
            ) if (
              !ranges.any(range -> range.start <= key && key <= range.end)
            ) ->
              void
            | _ -> !dirtyInRegion = dirtyInRegion.set(key)
            }
          };
          dirtyInRegion;
        })
      }
    };
    if (contextDirty.containsKey(parent.dirName)) {
      keys = contextDirty[parent.dirName].values();
      !dirty = withRegionFold(None(), keys, dirty, (_, key, dirtyInRegion) ~> {
        for (p in parentMaps) {
          (_, rangeOpt, _) = p;
          rangeOpt match {
          | Some(
            ranges,
          ) if (!ranges.any(range -> range.start <= key && key <= range.end)) ->
            void
          | _ -> !dirtyInRegion = dirtyInRegion.set(key)
          }
        };
        dirtyInRegion;
      })
    };

    // Do not remove .collect(Array).iterator();
    // Look at issue #106
    it = dirty.iterator().collect(Array).iterator();
    !childRef = withRegionFold(
      Some(context),
      it,
      childRef,
      (contextOpt, key, child) ~> {
        ctx = contextOpt.fromSome();
        ctx.enter(ArrowKey(parentName, childName, key));
        path = Path::create(parentName, key);
        oldInfo = static::getOld(child, path);
        oldKeys = SortedSet<Key>::createFromItems(oldInfo.getKeys());
        newDirsCopy = ctx.newDirs;
        readsCopy = ctx.reads;
        ctx.!newDirs = SortedSet[];
        ctx.!reads = SortedSet[];

        keys = mutable Vector<Key>[];
        mvalues = SortedMap<Key, mutable Vector<File>>[];

        for (p in parentMaps) {
          writer = mutable Writer{};
          (mapFun, _, _) = p;
          mapFun(ctx, writer, key, parent.getIterRaw(key));
          mapped = writer.getWrites();
          for (kv in mapped) {
            (k, rvalues) = kv;

            keys.push(k);
            if (oldKeys.contains(k)) {
              !oldKeys = oldKeys.remove(k);
            };

            if (!mvalues.containsKey(k)) {
              !mvalues = mvalues.set(k, mutable Vector[]);
            };
            mvalues[k].extend(rvalues);
          };
        };

        newDirs = ctx.newDirs;
        reads = ctx.getReads();
        ctx.!newDirs = newDirsCopy;
        ctx.!reads = readsCopy;

        !child = child.updateNewDirs(ctx, path, newDirs);

        for (read in reads) {
          arrowKey = ArrowKey(parentName, child.dirName, key);
          ctx.!deps = ctx.deps.set(read, arrowKey);
        };

        for (oldRead in oldInfo.getReads()) {
          if (reads.contains(oldRead)) continue;
          arrowKey = ArrowKey(parentName, child.dirName, key);
          ctx.!deps = ctx.deps.remove(oldRead, arrowKey);
        };

        for (k => v in mvalues) {
          !child = child.writeEntry(ctx, path, path, k, v.toArray());
        };

        // Let's remove the keys that no longer exist.
        for (k in oldKeys) {
          !child = child.writeEntry(ctx, path, path, k, Array[]);
        };

        // We need to remember what keys we produced for the next
        // time around.
        minfo = MInfo::create(
          keys.toArray(),
          newDirs.toArray(),
          reads.toArray(),
        );
        // The source cannot be removed from old here
        // => prevent getting fixed data minfo on multiple call durring update
        !child.old[path] = minfo;
        ctx.leave(ArrowKey(parentName, childName, key));
        child
      },
    );

    context.setDir(childRef.dirName, childRef);

    for (p in parentMaps) {
      (_, _, onUpdate) = p;
      onUpdate match {
      | None() -> void
      | Some(f) -> f(context, dirty)
      }
    }
  }

  fun getArray(context: mutable Context, key: Key): Array<File> {
    this.getIter(context, key).collect(Array);
  }

  fun getIter(context: mutable Context, key: Key): mutable Iterator<File> {
    path = Path::create(this.dirName, key);
    context.addDep(path);
    this.getIterRaw(key)
  }

  fun writeEntry(
    context: mutable Context,
    origSource: Path,
    writer: Path,
    k: Key,
    rvalues: Array<File>,
    force: Bool = false,
  ): this {
    oldValues = this.getArraySourceKey(origSource, k);

    if (native_eq(rvalues, oldValues) == 0) {
      return this;
    };

    context.writeChecker match {
    | Some(checker) if (!force) ->
      checker.tables.maybeGet(this.dirName) match {
      | None() -> void
      | Some(indexes) ->
        checker.checkWrite(context, this.dirName, indexes, k, rvalues)
      }
    | _ -> void
    };

    if (this.data.nbrEntries >= this.fixedData.size()) {
      context.!toPurge = context.toPurge.set(this.dirName);
    };

    totalSize = if (oldValues.size() == 0 && rvalues.size() > 0) {
      this.totalSize + 1
    } else if (oldValues.size() > 0 && rvalues.size() == 0) {
      this.totalSize - 1
    } else {
      this.totalSize
    };

    map = this.data.maybeGet(k) match {
    | None() -> DataMapValue::empty()
    | Some(x) -> x
    };

    isMasking = this.fixedData.data.getIterSourceKey(
      origSource,
      k,
    ).next() is Some _;
    !map = map.set(context.tick, isMasking, origSource, writer, rvalues);

    tag = TickRange::create(context.tick);
    !this.data = this.data.set(tag, k, map);

    reducer = this.reducer match {
    | None() -> None()
    | Some(cdata) ->
      state = cdata.getArray(k);
      if (state.size() == 0) {
        !cdata.modified[k] = cdata.reducer.init(
          this.unsafeGetDataIterWithoutTombs(k)
            .map(x -> x.i2.iterator())
            .flatten(),
        )
      } else {
        cdata.reducer.update(state, oldValues, rvalues) match {
        | None() ->
          !cdata.modified[k] = cdata.reducer.init(
            this.unsafeGetDataIterWithoutTombs(k)
              .map(x -> x.i2.iterator())
              .flatten(),
          )
        | Some(new) -> !cdata.modified[k] = new
        }
      };
      Some(cdata)
    };

    context.!dirty = List.Cons(Path::create(this.dirName, k), context.dirty);

    path = Path::create(this.dirName, k);

    if (this.totalSize != totalSize) {
      sizePath = Path::create(this.dirName.size(), SizeTag());
      updateDirtyReaders(context, sizePath);
      if (
        this.totalSize == 0 && totalSize != 0 ||
        this.totalSize != 0 && totalSize == 0
      ) {
        isEmptyPath = Path::create(this.dirName.size(), IsEmptyTag());
        updateDirtyReaders(context, isEmptyPath);
      }
    };

    filesPath = Path::create(this.dirName.files(), FilesTag());
    updateDirtyReaders(context, filesPath);

    !this = this with {totalSize, reducer};

    updateDirtyReaders(context, path);

    parentTime = this.time;
    childDirs = SortedSet[];

    for (childName in this.childDirs) {
      context.unsafeMaybeGetEagerDir(childName) match {
      | None() -> continue
      | Some(childDir) ->
        !childDirs = childDirs.set(childName);
        context.addToUpdate(
          (childDir.time, parentTime),
          Arrow(this.dirName, childName),
        )
      }
    };

    purgeCount = this.purgeCount;
    slices = this.slices;

    for (childNameTime in this.slices.get(k)) {
      !purgeCount = purgeCount + 1;
      childName = childNameTime;
      context.unsafeMaybeGetEagerDir(childName) match {
      | None() -> continue
      | Some(childDir) ->
        context.addToUpdate(
          (childDir.time, parentTime),
          Arrow(this.dirName, childName),
        )
      }
    };

    if (context.debugMode) {
      name = "" + this.dirName + k;
      print_string(`WRITTEN:  ${name}`);
    };

    if (purgeCount >= PURGE_LIMIT) {
      !slices = this.purgeSlices(context);
      !purgeCount = 0;
    };

    this with {childDirs, slices, purgeCount}
  }

  fun purgeSlices(
    context: mutable Context,
  ): RangeMapList<SKStore.Key, SKStore.DirName> {
    slices = RangeMapList[];
    childDirs = SortedSet[];
    for (slice in this.slices) {
      for (childDir in slice.i1) {
        !childDirs = childDirs.set(childDir);
      }
    };
    for (child in childDirs) {
      context.unsafeMaybeGetEagerDir(child) match {
      | None() -> continue
      | Some(childDir) ->
        for (parent in childDir.parents.items()) {
          if (parent.i0 != this.dirName) continue;
          for (p in parent.i1) {
            p.i1 match {
            | None() -> continue
            | Some(ranges) ->
              for (range in ranges) {
                !slices = slices.add(range.start, range.end, childDir.dirName)
              }
            }
          }
        }
      }
    };
    slices
  }

  fun unsafeIterKeys(f: (Key, Tick) -> void): void {
    fixedData = this.fixedData.data;
    current = 0;
    this.data.eachWithTick((newKey, tick) -> {
      while (current < fixedData.size() && fixedData[current].key < newKey) {
        row = fixedData[current];
        f(row.key, Tick(0));
        !current = current + 1;
      };
      f(newKey, tick);
    });
    while (current < fixedData.size()) {
      row = fixedData[current];
      f(row.key, Tick(0));
      !current = current + 1;
    };
  }

  private fun getFixedFiles(idx: Int): mutable Iterator<File> {
    key = this.fixedData.data[idx].key;
    while (
      idx < this.fixedData.data.size() &&
      this.fixedData.data[idx].key == key
    ) {
      fixedValues = this.fixedData.data[idx].value;
      if (this.reducer is None()) {
        for (elt in fixedValues) {
          yield elt;
        };
      };
      !idx = idx + 1;
    };

    this.reducer match {
    | None() -> void
    | Some(compact) ->
      for (elt in compact.getArray(key)) {
        yield elt
      }
    }
  }

  fun unsafeGetFileIter(
    start: ?Key = None(),
  ): mutable Iterator<(Key, mutable Iterator<File>)> {
    this.reducer match {
    | None() -> this.unsafeGetFileIterNoReducer(start)
    | Some(reducer) -> reducer.unsafeIter(start)
    }
  }

  fun unsafeGetFileIterNoReducer(
    start: ?Key,
  ): mutable Iterator<(Key, mutable Iterator<File>)> {
    current = mutable IntRef(
      start match {
      | None() -> 0
      | Some(key) ->
        pos = this.fixedData.data.getPos(key);
        if (pos < 0) 0 else pos
      },
    );
    for (key => _ in this.data.data.itemsAfterKey(
      start match {
      | None() -> None()
      | Some(x) -> Some(Inclusive(x))
      },
    )) {
      while (
        current.value < this.fixedData.data.size() &&
        this.fixedData.data[current.value].key < key
      ) {
        fixedKey = this.fixedData.data[current.value].key;
        fixedFiles = this.getFixedFiles(current.value);
        while (
          current.value < this.fixedData.data.size() &&
          this.fixedData.data[current.value].key == fixedKey
        ) {
          current.incr();
        };
        yield (fixedKey, fixedFiles);
      };
      while (
        current.value < this.fixedData.data.size() &&
        this.fixedData.data[current.value].key == key
      ) {
        current.incr();
      };
      yield (key, this.getIterRaw(key));
    };
    while (current.value < this.fixedData.data.size()) {
      fixedKey = this.fixedData.data[current.value].key;
      fixedFiles = this.getFixedFiles(current.value);
      while (
        current.value < this.fixedData.data.size() &&
        this.fixedData.data[current.value].key == fixedKey
      ) {
        current.incr();
      };
      yield (fixedKey, fixedFiles);
    };
  }

  fun unsafeGetFileIterWithReducer(): mutable Iterator<
    (Key, mutable Iterator<File>),
  > {
    current = mutable IntRef(0);
    for (key => _ in this.data) {
      while (
        current.value < this.fixedData.data.size() &&
        this.fixedData.data[current.value].key < key
      ) {
        fixedKey = this.fixedData.data[current.value].key;
        fixedFiles = this.getFixedFiles(current.value);
        while (
          current.value < this.fixedData.data.size() &&
          this.fixedData.data[current.value].key == key
        ) {
          current.incr();
        };
        yield (fixedKey, fixedFiles);
      };
      while (
        current.value < this.fixedData.data.size() &&
        this.fixedData.data[current.value].key == key
      ) {
        current.incr();
      };
      yield (key, this.getIterRaw(key));
    };
    while (current.value < this.fixedData.data.size()) {
      fixedKey = this.fixedData.data[current.value].key;
      fixedFiles = this.getFixedFiles(current.value);
      while (
        current.value < this.fixedData.data.size() &&
        this.fixedData.data[current.value].key == fixedKey
      ) {
        current.incr();
      };
      yield (fixedKey, fixedFiles);
    };
  }

  fun onFiles(
    process: mutable Iterator<(Key, mutable Iterator<File>)> -> void,
  ): void {
    process(this.unsafeGetFileIter())
  }

  fun keys(): SortedSet<Key> {
    fixedData = this.fixedData.data;
    current = 0;
    keys = SortedSet[];
    for (newKey => newValues in this.data) {
      while (current < fixedData.size() && fixedData[current].key < newKey) {
        row = fixedData[current];
        if (row.value.size() > 0) {
          !keys = keys.set(row.key);
        };
        !current = current + 1;
      };
      if (!newValues.isEmpty()) {
        !keys = keys.set(newKey);
      };
    };
    while (current < fixedData.size()) {
      row = fixedData[current];
      if (row.value.size() > 0) {
        !keys = keys.set(row.key);
      };
      !current = current + 1;
    };
    keys
  }

  fun getDirName(): DirName {
    this.dirName
  }

  static fun getOld(child: EagerDir, key: Path): MInfo {
    if (child.old.containsKey(key)) {
      child.old[key]
    } else {
      child.fixedOld.maybeGet(key) match {
      | None() -> MInfo::empty()
      | Some(v) -> v
      }
    }
  }

  fun updateNewDirs(
    context: mutable Context,
    source: Path,
    newDirs: SortedSet<DirName>,
  ): this {
    minfo = static::getOld(this, source);
    lastRoundDirs = minfo.getNewDirs();
    removed = mutable Vector[];
    if (context.isWithSharedSubDirs(this.dirName)) {
      toAdd = newDirs;
      toRemove = mutable Vector[];
      for (dirName in lastRoundDirs) {
        if (toAdd.contains(dirName)) {
          !toAdd = toAdd.remove(dirName)
        } else {
          toRemove.push(dirName);
        }
      };

      for (newDir in toAdd) {
        context.incrRefCount(newDir);
      };

      for (dirName in toRemove) {
        if (context.decrRefCount(dirName) && context.removeSubDirs) {
          context.removeDir(dirName);
          removed.push(dirName)
        }
      };
    } else {
      if (minfo.getNewDirs().isEmpty() || !context.removeSubDirs) return this;

      for (dirName in lastRoundDirs) {
        if (newDirs.contains(dirName)) continue;
        context.removeDir(dirName);
        removed.push(dirName)
      }
    };
    !minfo = minfo.setNewDirs(newDirs.toArray());
    !this.old[source] = minfo;

    for (dirName in removed) {
      updateDirtyReaders(context, Path::create(dirName.tag(), DirTag()));
    };
    this
  }

  fun writeArrayReturnDir(
    context: mutable Context,
    key: Key,
    values: Array<File>,
  ): this {
    source = Path::create(this.dirName, key);
    !this = this.writeEntry(context, source, source, key, values);
    context.!toReset = context.toReset.set(this.dirName);
    this
  }

  fun writeArray(
    context: mutable Context,
    key: Key,
    values: Array<File>,
  ): void {
    !this = this.writeArrayReturnDir(context, key, values);
    context.setDir(this.dirName, this);
  }

  fun writeArraySourceManyReturnDir(
    context: mutable Context,
    bindings: mutable Iterator<(Key, (Path, Path, Array<File>))>,
  ): this {
    for (kv in bindings) {
      (key, (origSource, writer, values)) = kv;
      !this = this.writeEntry(context, origSource, writer, key, values);
    };
    context.!toReset = context.toReset.set(this.dirName);
    this
  }

  fun writeArraySourceMany(
    context: mutable Context,
    bindings: mutable Iterator<(Key, (Path, Path, Array<File>))>,
  ): void {
    !this = this.writeArraySourceManyReturnDir(context, bindings);
    context.setDir(this.dirName, this);
  }

  fun writeArrayMany(
    context: mutable Context,
    bindings: mutable Iterator<(Key, Array<File>)>,
  ): void {
    this.writeArraySourceMany(
      context,
      bindings.map(kv -> {
        (key, values) = kv;
        source = Path::create(this.dirName, key);
        (key, (source, source, values))
      }),
    );
  }

  fun size(context: mutable Context): Int {
    context.addDep(Path::create(this.dirName.size(), SizeTag()));
    this.totalSize
  }

  fun getIterator(
    context: mutable Context,
  ): mutable Iterator<(SKStore.Key, mutable Iterator<SKStore.File>)> {
    path = Path::create(this.dirName.files(), FilesTag());
    context.addDep(path);
    this.unsafeGetFileIter()
  }

  fun getAllDataIter(
    context: mutable Context,
    key: Key,
  ): mutable Iterator<(Tick, Path, Path, Array<File>)> {
    path = Path::create(this.dirName, key);
    context.addDep(path);
    this.unsafeGetAllDataIter(key)
  }

  fun getDataIterWithoutTombs(
    context: mutable Context,
    key: Key,
  ): mutable Iterator<(Tick, Path, Array<File>)> {
    path = Path::create(this.dirName, key);
    context.addDep(path);
    this.unsafeGetDataIterWithoutTombs(key)
  }

  fun isEmpty(context: mutable Context): Bool {
    context.addDep(Path::create(this.dirName.size(), IsEmptyTag()));
    this.totalSize == 0
  }

  fun write(context: mutable Context, baseName: Key, value: File): void {
    this.writeArray(context, baseName, Array[value]);
  }

  fun remove(context: mutable Context, baseName: Key): void {
    this.writeArray(context, baseName, Array[]);
  }

  fun isDeleted(): Bool {
    false
  }
}

module end;
