/*****************************************************************************/
/* Module exposing a typed interface to the file system.
 *
 * The code implementing the file system is not statically typed. A first
 * version attempted to do that, but it became clear very quickly that it
 * would require to bend the type-system in ways that were counter-productive.
 *
 * Moreover, remote-directories, because of their nature break the static
 * type-checking.
 *
 * Hence the idea of an implementation where every file in the system has the
 * same type "File" and every key the type "Key".
 *
 * However, type-checking is nice! So how do we get the best of both worlds?
 * By exposing a typed API!
 *
 * This is what the Handle module is for. The idea is to add a layer of type-
 * checking and expose that to the user.
 *
 * Concretely, let's say we want to manipulate a directory where the files are
 * all of type IntFile. The type Handle<IntFile> is there to the rescue! Every
 * operation will be type-checked (statically) against the type IntFile.
 *
 * So if I try to write a StringFile instead of an IntFile I get a static error.
 * The other important part is that all the higher order operations are also
 * typed. So applying a map to a Handle also produces a handle.
 *
 * What's nice about that is that it becomes relatively straightforward to
 * write a program that is fully type-checked. The dynamic nature of the file-
 * system becomes an implementation detail. All you need to do is to stick with
 * Handles. Never try to manipulate "Dir" directly and you will be safe!
 */
/*****************************************************************************/

module SKStore;

/*****************************************************************************/
/* Iterator capable of answering if it produces at least one element. */
/*****************************************************************************/

mutable base class FileIterator<+T> extends Iterator<T> {
  static fun create(iter: mutable Iterator<T>): mutable FileIterator<T> {
    iter.next() match {
    | None() -> mutable EmptyIterator()
    | Some(v) -> mutable NonEmptyIterator(v, iter)
    }
  }

  readonly fun isEmpty(): Bool;
}

mutable class EmptyIterator<T>() extends FileIterator<T> {
  mutable fun next(): ?T {
    None()
  }

  readonly fun isEmpty(): Bool {
    true
  }
}

mutable class NonEmptyIterator<+T>(
  mutable first: T,
  iter: mutable Iterator<T>,
  mutable isPassedFirstValue: Bool = false,
) extends FileIterator<T> {
  mutable fun next(): ?T {
    if (this.isPassedFirstValue) return this.iter.next();
    this.!isPassedFirstValue = true;
    Some(this.first)
  }
  readonly fun isEmpty(): Bool {
    false
  }
  mutable fun nonEmptyMap<U>(f: T -> U): mutable NonEmptyIterator<U> {
    mutable NonEmptyIterator(f(this.first), this.iter.map(f))
  }
}

/*****************************************************************************/
/* The class handed over to the closures mapping over a directory. */
/*****************************************************************************/

mutable class Writer{
  mutable writes: SortedMap<Key, Array<File>> = SortedMap[],
} {
  mutable fun setArray(key: Key, values: Array<File>): void {
    this.!writes[key] = values;
  }

  mutable fun set(key: Key, value: File): void {
    this.!writes[key] = Array[value];
  }

  mutable fun remove(key: Key): void {
    this.!writes[key] = Array[];
  }

  readonly fun getWrites(): Array<(Key, Array<File>)> {
    result = mutable Vector[];
    for (key => values in this.writes) {
      result.push((key, values));
    };
    result.toArray()
  }
}

/*****************************************************************************/
/* Typed version of Writer. */
/*****************************************************************************/

mutable class TWriter<K: Key, V: File>{
  mutable writes: SortedMap<Key, Array<File>> = SortedMap[],
} {
  mutable fun setArray(key: K, values: Array<V>): void {
    this.!writes[key] = values;
  }

  mutable fun set(key: K, value: V): void {
    this.!writes[key] = Array[value];
  }

  mutable fun remove(key: K): void {
    this.!writes[key] = Array[];
  }

  readonly fun getWrites(): Array<(Key, Array<File>)> {
    result = mutable Vector[];
    for (key => values in this.writes) {
      result.push((key, values));
    };
    result.toArray()
  }
}

/*****************************************************************************/
/* Typed version of the Reducer. */
/*****************************************************************************/

class EReducer<T>{
  canReset: Bool,
  init: (mutable Iterator<T> ~> Array<T>),
  update: (Array<T>, Array<T>, Array<T>) ~> ?Array<T>,
}

/*****************************************************************************/
/* The preferred way of accessing the file-system. */
/*****************************************************************************/

base class Handle<+K: Orderable, +V: frozen> {
  macro fun getDirName(): DirName {
    this.dirName
  }

  macro overridable fun getConv(): SKStore.File ~> V {
    this.conv
  }

  fun getArray(context: mutable Context, key: Key): Array<V> {
    dir = context.unsafeGetDir(this.getDirName());
    dir.getArray(context, key).map(this.getConv())
  }

  fun getIter(context: mutable Context, key: Key): mutable Iterator<V> {
    dir = context.unsafeGetDir(this.getDirName());
    dir.getIter(context, key).map(this.getConv())
  }

  fun get(context: mutable Context, key: Key): V {
    values = this.getArray(context, key);
    if (values.size() >= 2) {
      msg = `Error: Duplicate keys '${key}' in '${this.getDirName()}'`;
      print_error(msg);
      invariant_violation(msg);
    };
    if (values.size() == 0) {
      msg = `Error: No value for keys '${key}' in '${this.getDirName()}'`;
      print_error(msg);
      invariant_violation(msg);
    };
    values[0]
  }

  fun containsKey(context: mutable Context, key: Key): Bool {
    this.getArray(context, key).size() > 0
  }

  fun maybeGet(context: mutable Context, key: Key): ?V {
    values = this.getArray(context, key);
    if (values.size() == 0) return None();
    Some(values[0])
  }
}

/*****************************************************************************/
/* A lazy handle is updated "lazily", in other words, an entry is computed
 * only when someone tries to access it.
 */
/*****************************************************************************/

class LHandle<+K: Orderable, +V: frozen>(
  conv: File ~> V,
  dirName: DirName,
) extends Handle<K, V> {
  static fun create<V: File>(
    conv: File ~> V,
    context: mutable Context,
    dirName: DirName,
    f: (mutable Context, LHandle<K, V>, Key) ~> Array<V>,
    collect: Bool = true,
  ): LHandle<K, V> {
    dir = LazyDir::create(
      context,
      dirName,
      (context, dirName, key) ~> {
        Some(f(context, LHandle(conv, dirName), key));
      },
      collect,
    );
    LHandle(conv, dir.getDirName())
  }

  static fun createAsync<T: File>(
    conv: File ~> T,
    context: mutable Context,
    dirName: DirName,
    f: (mutable Context, LHandle<K, T>, Key) ~> ?Array<T>,
    collect: Bool = true,
  ): LHandle<K, T> {
    dir = LazyDir::create(
      context,
      dirName,
      (context, dirName, key) ~> {
        f(context, LHandle(conv, dirName), key);
      },
      collect,
    );
    LHandle(conv, dir.getDirName())
  }

  fun getArrayAsync(context: mutable Context, key: Key): Array<V> {
    dir = context.unsafeGetLazyDir(this.getDirName());
    results = dir.getArrayAsync(context, key).map(this.getConv());
    results
  }

  fun getArrayWithOptions(
    context: mutable Context,
    key: Key,
    isAsync: Bool,
    throwOnCycle: Bool,
  ): Array<V> {
    dir = context.unsafeGetLazyDir(this.getDirName());
    results = dir
      .getArrayWithOptions(context, key, isAsync, throwOnCycle)
      .map(this.getConv());
    results
  }
}

/*****************************************************************************/
/* Eager handles. */
/*****************************************************************************/

class EHandle<K: Key, V: File>(
  convKey: Key ~> K,
  conv: File ~> V,
  dirName: DirName,
) extends Handle<K, V> {
  static fun multiMap<K, V, K2: Key, V2: File>(
    convOutputKey: Key ~> K2,
    convOutput: File ~> V2,
    context: mutable Context,
    parents: Array<
      (
        EHandle<K, V>,
        (
          (
            mutable Context,
            mutable TWriter<K2, V2>,
            K,
            mutable NonEmptyIterator<V>,
          ) ~> void,
          ?Array<KeyRange>,
        ),
      ),
    >,
    dirName: DirName,
    reducerOpt: ?EReducer<V2> = None(),
  ): EHandle<K2, V2> {
    dynParents = mutable Vector[];
    parentSet = mutable Set[];
    for (parent in parents) {
      (parentHandle, parentData) = parent;
      (mapFun, rangeOpt) = parentData;
      convInputKey = parentHandle.convKey;
      convInput = parentHandle.conv;
      parentName = parentHandle.dirName;
      dynamicMapFun = (context, writer, key, fileIter) ~> {
        FileIterator::create(fileIter) match {
        | EmptyIterator _ -> return void
        | iter @ NonEmptyIterator _ ->
          twriter = mutable TWriter<K2, V2>{writes => writer.writes};
          mapFun(
            context,
            twriter,
            convInputKey(key),
            iter.nonEmptyMap(convInput),
          );
          writer.!writes = twriter.writes
        }
      };
      parentSet.add(parentName);
      dynParents.push((parentName, (dynamicMapFun, rangeOpt)))
    };
    fixedParents = FixedSingle::create(dynParents);
    EagerDir::applyMany(
      context,
      fixedParents,
      dirName,
      reducerOpt match {
      | None() -> None()
      | Some(reducer) ->
        Some(
          IReducer{
            init => files ~> reducer.init(files.map(convOutput)),
            update => (state, old, new) ~>
              reducer.update(
                state.map(convOutput),
                old.map(convOutput),
                new.map(convOutput),
              ),
          },
        )
      },
    );
    EHandle(convOutputKey, convOutput, dirName)
  }

  fun map<K2: Key, V2: File>(
    convKey: Key ~> K2,
    conv: File ~> V2,
    context: mutable Context,
    dirName: DirName,
    f: (
      mutable Context,
      mutable TWriter<K2, V2>,
      K,
      mutable NonEmptyIterator<V>,
    ) ~> void,
    reducerOpt: ?EReducer<V2> = None(),
  ): EHandle<K2, V2> {
    static::multiMap(
      convKey,
      conv,
      context,
      Array[
        (SKStore.EHandle(this.convKey, this.conv, this.dirName), (f, None())),
      ],
      dirName,
      reducerOpt,
    )
  }

  fun pre(context: mutable Context): ?EHandle<K, V> {
    if (!context.hasPre.contains(this.dirName)) {
      context.!hasPre = context.hasPre.add(this.dirName);
    };
    context.maybeGetDir(this.dirName.pre()) match {
    | None() -> None()
    | Some(dir) -> Some(EHandle(this.convKey, this.conv, dir.getDirName()))
    }
  }

  fun size(context: mutable Context): Int {
    context.getEagerDir(this.dirName).size(context)
  }

  fun isEmpty(context: mutable Context): Bool {
    context.getEagerDir(this.dirName).isEmpty(context)
  }

  fun writeArray<U: File>[V: U](
    context: mutable Context,
    key: Key,
    values: Array<U>,
  ): void {
    dir = context.unsafeGetEagerDir(this.dirName);
    dir.writeArray(context, key, values);
  }

  fun unsafeGetArray(context: mutable Context, key: Key): Array<V> {
    dir = context.unsafeGetDir(this.getDirName());
    dir.getArrayRaw(key).map(this.getConv())
  }

  fun unsafeGet(context: mutable Context, key: Key): V {
    arr = this.unsafeGetArray(context, key);
    invariant(arr.size() == 1);
    arr[0]
  }
}

module end;
