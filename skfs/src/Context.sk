/*****************************************************************************/
/* File defining the context.
 *
 * The context is almost always mutable (unless it is copied to the shared
 * heap).
 *
 * It keeps track of all the manipulation of the file system. Directories,
 * dependencies etc ...
 */
/*****************************************************************************/

module SKStore;

class ToWrite(DirName, Key, readonly Context ~> Array<File>)

/*****************************************************************************/
/* Sessions. */
/*****************************************************************************/

base class CmdKind {
  children =
  | NUpdates(String)
  | NNotify(String)
  | NTail()
}

value class Sub(
  lock: Mutex,
  cond: Condition,
  cmd: CmdKind,
  destinationSource: ?Int,
  dirSubs: Array<DirSub>,
)

class DirSub(
  dirName: DirName,
  entity: String,
  format: OutputFormat,
  // the watermark is per-dir because tables can be added and removed
  // from the mirror-set: they don't necessarily all move forward in
  // lock-step.
  getDestinationWatermark: (readonly SKStore.Context) ~> ?SKStore.Tick,
  // this is a dir-specific filter
  filter: (SKStore.Context, Bool) ~> (Key -> Bool) = (_, _) ~> (_ -> true),
)

/*****************************************************************************/
/* Unique number generator. */
/*****************************************************************************/

@cpp_extern("SKIP_genSym")
native fun genSym(Int): Int;

/*****************************************************************************/
/* Constants */
/*****************************************************************************/

const debugMode: Bool = false;

/*****************************************************************************/
/* The types used to manage dependencies. */
/*****************************************************************************/

// An Arrow represent an operation from a parent to a child.
// Typically, a map is a tranformation that associates a value from a parent
// to a child. The association between the two is called an Arrow.

value class Arrow(parentName: DirName, childName: DirName) uses Orderable

// An ArrowKey, is an Arrow plus a key (the key is from the parent).
// This type is used to describe the root of a dependency on an EagerMap.
// Let's say we have a directory A mapped to B. So B is the result of a map
// applied to A with a given function.

// If during the transformation from A to B, a key is read in third directory,
// we will need to remember that the read occured while processing a map
// from A to B on the key K. Hence the type: ArrowKey(A, B, K).

value class ArrowKey(
  parentName: DirName,
  childName: DirName,
  key: Key,
) uses Orderable

/*****************************************************************************/
/* The function used to start the system. */
/*****************************************************************************/

fun run(f: (mutable Context) -> void): mutable Context {
  context = mutable Context{};
  f(context);
  context.initPre();
  context
}

/*****************************************************************************/
/* Primitives used to make a file "dirty" (dirty means that it needs to be
 * recomputed.
 *
 * - dirtyReaders are files that are made dirty because of a read access
 * - dirty are files that are made dirty because of a Map.
 */
/*****************************************************************************/

fun updateDirtyReaders(
  context: mutable Context,
  path: Path,
  addToDirtyList: Bool = true,
): void {
  for (reader in context.getDeps(path)) {
    child = context.unsafeMaybeGetDir(reader.childName) match {
    | None() -> continue
    | Some(x) -> x
    };
    parent = context.unsafeMaybeGetDir(reader.parentName) match {
    | None() -> continue
    | Some(x) -> x
    };
    if (addToDirtyList) {
      context.!dirtyReaders = List.Cons(reader, context.dirtyReaders);
    };
    time = if (reader.parentName == reader.childName) {
      (-child.getTime(), -child.getTime())
    } else {
      (child.getTime(), parent.getTime())
    };
    arrow = Arrow(reader.parentName, reader.childName);
    context.addToUpdate(time, arrow);
  };
}

/*****************************************************************************/
/* Dependencies tracking. */
/*****************************************************************************/

value class Deps(
  data: SortedMap<Path, SortedSet<ArrowKey>> = SortedMap[],
  idata: HashMap<DirName, SortedSet<Path>> = HashMap[],
) {
  static fun createFromItems(items: Array<(Path, ArrowKey)>): this {
    deps = Deps();
    for (item in items) {
      (path, arrowKey) = item;
      !deps[path] = arrowKey;
    };
    deps
  }

  fun maybeGet(path: Path): ?SortedSet<ArrowKey> {
    this.data.maybeGet(path)
  }

  fun set(path: Path, arrowKey: ArrowKey): this {
    set = this.data.maybeGet(path) match {
    | None() -> SortedSet[]
    | Some(x) -> x
    };
    !set = set.set(arrowKey);
    !this.data[path] = set;
    !this = this.iset(arrowKey.childName, path);

    this
  }

  fun iset(dirName: DirName, arrow: Path): this {
    iset = this.idata.maybeGet(dirName) match {
    | None() -> SortedSet[]
    | Some(x) -> x
    };
    !iset = iset.set(arrow);
    !this.idata[dirName] = iset;
    this
  }

  fun iremove(dirName: DirName, arrow: Path): this {
    iset = this.idata.maybeGet(dirName) match {
    | None() -> SortedSet[]
    | Some(x) -> x
    };
    !iset = iset.remove(arrow);
    if (iset.isEmpty()) {
      !this.idata = this.idata.remove(dirName);
    } else {
      !this.idata[dirName] = iset;
    };
    this
  }

  fun remove(path: Path, arrowKey: ArrowKey): this {
    set = this.data.maybeGet(path) match {
    | None() -> SortedSet[]
    | Some(x) -> x
    };
    !set = set.remove(arrowKey);
    if (set.isEmpty()) {
      !this.data = this.data.remove(path)
    } else {
      !this.data[path] = set
    };
    !this = this.iremove(arrowKey.childName, path);
    this
  }

  fun removeDir(dirName: DirName): this {
    paths = this.idata.maybeGet(dirName) match {
    | None() -> return this
    | Some(x) -> x
    };
    for (path in paths) {
      this.data.maybeGet(path) match {
      | None() -> continue
      | Some(vset) ->
        !this.data[path] = vset.filter(x ->
          !(x.parentName == dirName || x.childName == dirName)
        )
      }
    };
    !this.idata = this.idata.remove(dirName);
    this
  }
}

/*****************************************************************************/
/* Value classes for tick and time. We use them to make sure we never treat
 * them as integer. */
/*****************************************************************************/

value class Tick(value: Int) uses Orderable, Show {
  fun next(): this {
    !this.value = this.value + 1;
    this
  }

  fun prev(): this {
    !this.value = this.value - 1;
    this
  }

  fun toString(): String {
    this.value.toString()
  }
}

class TickFile(value: Tick) extends File uses Orderable

value class Time(value: Int) uses Orderable, Show {
  fun next(): this {
    !this.value = genSym(this.value + 1);
    this
  }
  fun toString(): String {
    this.value.toString()
  }

  fun negate(): this {
    !this.value = -this.value;
    this
  }
}

/*****************************************************************************/
/* Tells the context if we can reuse directories or not. */
/*****************************************************************************/

base class CanReuse {
  children =
  | CRNever()
  | CRAlways()
  | CRIfMatch()
}

/*****************************************************************************/
/* Checks if a write should be allowed (only useful when using the */
/* database as a specific user). */
/*****************************************************************************/

value class TableIndexes(authorIdx: ?Int, accessIdx: ?Int)

mutable base class WriteChecker private {
  mutable tables: SortedMap<DirName, TableIndexes>,
} {
  mutable fun checkWrite(
    context: readonly SKStore.Context,
    dirName: DirName,
    indexes: TableIndexes,
    key: Key,
    files: Array<File>,
  ): void;

  mutable fun addTable(
    tableName: DirName,
    authorIdxOpt: ?Int,
    accessIdxOpt: ?Int,
  ): void;
  readonly fun clone(): WriteChecker;
  readonly fun mclone(): mutable WriteChecker;
}

/*****************************************************************************/
/* The context */
/*****************************************************************************/

mutable class Context{
  mutable toPurge: SortedSet<DirName> = SortedSet[],
  mutable purgeLimit: ?Tick = None(),
  mutable pwd: String = "/",
  mutable dirs: Dirs = Dirs{},
  mutable reads: SortedSet<Path> = SortedSet[],
  mutable time: Time = Time(0),
  mutable tick: Tick = Tick(1),
  mutable lazyCapacity: Int = 10,
  mutable toUpdate: SortedMap<(Time, Time), Arrow> = SortedMap[],
  mutable deps: Deps = Deps[],
  mutable debugMode: Bool = debugMode,
  mutable failOnExn: Bool = true,
  mutable hasPre: SortedSet<DirName> = SortedSet[],
  mutable newDirs: SortedSet<DirName> = SortedSet[],
  mutable toReset: SortedSet<DirName> = SortedSet[],
  mutable globals: SortedMap<String, File> = SortedMap[],
  mutable asyncList: List<Path> = List[],
  mutable dirty: List<Path> = List[],
  mutable dirtyReaders: List<ArrowKey> = List[],
  mutable canReuse: CanReuse = CRIfMatch(),
  mutable arrowStack: List<ArrowKey> = List[],
  mutable lazyGets: SortedSet<Path> = SortedSet[],
  mutable lazyGetsQueueIn: List<Array<Path>> = List[],
  mutable lazyGetsQueueOut: List<Array<Path>> = List[],
  mutable lazyGetsRefCount: SortedMap<Path, Int> = SortedMap[],
  mutable sessions: SortedMap<Int, Sub> = SortedMap[],
  mutable removeSubDirs: Bool = true,
  mutable postWrites: List<ToWrite> = List[],
  mutable dirsWithSharedSubDirs: SortedSet<DirName> = SortedSet[],
  mutable sharedSubDirsRefCount: SortedMap<DirName, Int> = SortedMap[],
  mutable writeChecker: ?(mutable WriteChecker) = None(),
} {
  readonly fun isWithSharedSubDirs(dirName: DirName): Bool {
    this.dirsWithSharedSubDirs.contains(dirName)
  }

  mutable fun setWithSharedSubDirs(dirName: DirName): void {
    this.!dirsWithSharedSubDirs = this.dirsWithSharedSubDirs.set(dirName)
  }

  mutable fun incrRefCount(dirName: DirName): void {
    this.!sharedSubDirsRefCount = this.sharedSubDirsRefCount.set(
      dirName,
      this.sharedSubDirsRefCount.maybeGet(dirName).default(0) + 1,
    )
  }

  mutable fun decrRefCount(dirName: DirName): Bool {
    ref = this.sharedSubDirsRefCount.maybeGet(dirName).default(1) - 1;
    if (ref == 0) {
      this.!sharedSubDirsRefCount = this.sharedSubDirsRefCount.remove(dirName)
    } else {
      this.!sharedSubDirsRefCount = this.sharedSubDirsRefCount.set(dirName, ref)
    };
    ref == 0
  }

  mutable fun postpone(toWrite: ToWrite): void {
    this.!postWrites = List.Cons(toWrite, this.postWrites);
  }

  mutable fun addToUpdate(time: (Time, Time), arrow: Arrow): void {
    this.!toUpdate = this.toUpdate.set(time, arrow);
  }

  mutable fun subscribe(
    context: mutable Context,
    sessionId: Int,
    init: Bool,
    cmd: CmdKind,
    destinationSource: ?Int,
    dirSubs: Array<DirSub>,
  ): void {
    sub = Sub(mutexCreate(), condCreate(), cmd, destinationSource, dirSubs);

    if (init) {
      this.notifySub(sub, Tick(0))
    };

    context.!sessions[sessionId] = sub;
  }

  mutable fun pushAsync(path: Path): void {
    this.!asyncList = List.Cons(path, this.asyncList);
  }

  mutable fun popAsync(): ?Path {
    this.asyncList match {
    | List.Nil() -> None()
    | List.Cons(x, rl) ->
      this.!asyncList = rl;
      Some(x)
    }
  }

  readonly fun clone(): this {
    static{
      toPurge => this.toPurge,
      purgeLimit => this.purgeLimit,
      pwd => this.pwd,
      dirs => this.dirs,
      reads => this.reads,
      time => this.time,
      tick => this.tick,
      lazyCapacity => this.lazyCapacity,
      toUpdate => this.toUpdate,
      deps => this.deps,
      debugMode => this.debugMode,
      failOnExn => this.failOnExn,
      hasPre => this.hasPre,
      newDirs => this.newDirs,
      toReset => this.toReset,
      globals => this.globals,
      asyncList => this.asyncList,
      dirty => this.dirty,
      dirtyReaders => this.dirtyReaders,
      canReuse => this.canReuse,
      arrowStack => this.arrowStack,
      lazyGets => this.lazyGets,
      lazyGetsQueueIn => this.lazyGetsQueueIn,
      lazyGetsQueueOut => this.lazyGetsQueueOut,
      lazyGetsRefCount => this.lazyGetsRefCount,
      sessions => this.sessions,
      removeSubDirs => this.removeSubDirs,
      postWrites => this.postWrites,
      dirsWithSharedSubDirs => this.dirsWithSharedSubDirs,
      sharedSubDirsRefCount => this.sharedSubDirsRefCount,
      writeChecker => this.writeChecker.map(x -> x.clone()),
    }
  }

  readonly fun mclone(): mutable this {
    mutable static{
      toPurge => this.toPurge,
      purgeLimit => this.purgeLimit,
      pwd => this.pwd,
      dirs => this.dirs,
      reads => this.reads,
      time => this.time,
      tick => this.tick,
      lazyCapacity => this.lazyCapacity,
      toUpdate => this.toUpdate,
      deps => this.deps,
      debugMode => this.debugMode,
      failOnExn => this.failOnExn,
      hasPre => this.hasPre,
      newDirs => this.newDirs,
      toReset => this.toReset,
      globals => this.globals,
      asyncList => this.asyncList,
      dirty => this.dirty,
      dirtyReaders => this.dirtyReaders,
      canReuse => this.canReuse,
      arrowStack => this.arrowStack,
      lazyGets => this.lazyGets,
      lazyGetsQueueIn => this.lazyGetsQueueIn,
      lazyGetsQueueOut => this.lazyGetsQueueOut,
      lazyGetsRefCount => this.lazyGetsRefCount,
      sessions => this.sessions,
      removeSubDirs => this.removeSubDirs,
      postWrites => this.postWrites,
      dirsWithSharedSubDirs => this.dirsWithSharedSubDirs,
      sharedSubDirsRefCount => this.sharedSubDirsRefCount,
      writeChecker => this.writeChecker.map(x -> x.mclone()),
    }
  }

  static fun fromSaved(ctx: Context): mutable this {
    mutable static{
      toPurge => ctx.toPurge,
      purgeLimit => ctx.purgeLimit,
      pwd => ctx.pwd,
      dirs => ctx.dirs,
      reads => ctx.reads,
      time => ctx.time,
      tick => ctx.tick,
      lazyCapacity => ctx.lazyCapacity,
      toUpdate => ctx.toUpdate,
      deps => ctx.deps,
      debugMode => ctx.debugMode,
      failOnExn => ctx.failOnExn,
      hasPre => ctx.hasPre,
      newDirs => ctx.newDirs,
      toReset => ctx.toReset,
      globals => ctx.globals,
      asyncList => ctx.asyncList,
      dirty => ctx.dirty,
      dirtyReaders => ctx.dirtyReaders,
      canReuse => ctx.canReuse,
      arrowStack => ctx.arrowStack,
      lazyGets => ctx.lazyGets,
      lazyGetsQueueIn => ctx.lazyGetsQueueIn,
      lazyGetsQueueOut => ctx.lazyGetsQueueOut,
      lazyGetsRefCount => ctx.lazyGetsRefCount,
      sessions => ctx.sessions,
      removeSubDirs => ctx.removeSubDirs,
      postWrites => ctx.postWrites,
      dirsWithSharedSubDirs => ctx.dirsWithSharedSubDirs,
      sharedSubDirsRefCount => ctx.sharedSubDirsRefCount,
      writeChecker => ctx.writeChecker.map(x -> x.mclone()),
    }
  }

  mutable fun replaceFromSaved(ctx: readonly Context): void {
    this.!toPurge = ctx.toPurge;
    this.!purgeLimit = ctx.purgeLimit;
    this.!pwd = ctx.pwd;
    this.!dirs = ctx.dirs;
    this.!reads = ctx.reads;
    this.!time = ctx.time;
    this.!tick = ctx.tick;
    this.!lazyCapacity = ctx.lazyCapacity;
    this.!toUpdate = ctx.toUpdate;
    this.!deps = ctx.deps;
    this.!debugMode = ctx.debugMode;
    this.!failOnExn = ctx.failOnExn;
    this.!hasPre = ctx.hasPre;
    this.!newDirs = ctx.newDirs;
    this.!toReset = ctx.toReset;
    this.!globals = ctx.globals;
    this.!asyncList = ctx.asyncList;
    this.!dirty = ctx.dirty;
    this.!dirtyReaders = ctx.dirtyReaders;
    this.!canReuse = ctx.canReuse;
    this.!arrowStack = ctx.arrowStack;
    this.!lazyGets = ctx.lazyGets;
    this.!lazyGetsQueueIn = ctx.lazyGetsQueueIn;
    this.!lazyGetsQueueOut = ctx.lazyGetsQueueOut;
    this.!lazyGetsRefCount = ctx.lazyGetsRefCount;
    this.!sessions = ctx.sessions;
    this.!removeSubDirs = ctx.removeSubDirs;
    this.!postWrites = ctx.postWrites;
    this.!dirsWithSharedSubDirs = ctx.dirsWithSharedSubDirs;
    this.!sharedSubDirsRefCount = ctx.sharedSubDirsRefCount;
    this.!writeChecker = ctx.writeChecker.map(x -> x.mclone());
  }

  mutable fun getReads(): SortedSet<Path> {
    this.reads
  }

  mutable fun enter(arrow: ArrowKey): void {
    this.!arrowStack = List.Cons(arrow, this.arrowStack);
  }

  mutable fun leave(arrow: ArrowKey): void {
    this.arrowStack match {
    | List.Nil() -> invariant_violation("Cannot leave empty context")
    | List.Cons(arr, rl) ->
      invariant(arr == arrow);
      this.!arrowStack = rl
    }
  }

  readonly fun currentArrow(): ?ArrowKey {
    this.arrowStack match {
    | List.Nil() -> None()
    | List.Cons(x, _) -> Some(x)
    }
  }

  readonly fun getDeps(path: Path): SortedSet<ArrowKey> {
    this.deps.maybeGet(path) match {
    | None() -> SortedSet[]
    | Some(deps) -> deps
    }
  }

  readonly fun debug(path: Path): void {
    this.dirs.maybeGet(path.dirName) match {
    | None() -> print_string("Directory does not exist")
    | Some(dir) ->
      values = dir.getArrayRaw(path.baseName);
      debug(values)
    }
  }

  readonly fun getValue(path: Path): Array<File> {
    dir = this.dirs[path.dirName];
    values = dir.getArrayRaw(path.baseName);
    values
  }

  mutable fun updateNewDeps(reader: ArrowKey, reads: SortedSet<Path>): void {
    readSet = SortedSet[];
    for (read in reads) {
      !readSet = readSet.set(read);
    };
    for (path in readSet) {
      this.!deps = this.deps.set(path, reader);
    };
  }

  mutable fun initPre(): void {
    _ = this.updatePre();
  }

  mutable fun updatePre(): Bool {
    if (this.debugMode) {
      print_string(`------------ UPDATE PRE ------------`);
    };
    withChange = false;
    this.hasPre.each(dirName -> {
      preDirName = dirName.pre();
      this.unsafeMaybeGetEagerDir(dirName).each(dir -> {
        this.unsafeMaybeGetEagerDir(preDirName) match {
        | None() ->
          this.!newDirs = this.newDirs.add(preDirName);
          time = this.timeStamp();
          preDir = EagerDir{
            time,
            input => false,
            dirName => preDirName,
            totalSize => 0,
            fixedData => FixedDataMap::create(),
            creator => this.currentArrow(),
          };
          dir.unsafeIterKeys((key, _time) -> {
            values = dir.getArrayRaw(key).collect(Array);
            !withChange = true;
            source = Path::create(preDir.dirName, key);
            !preDir = preDir.writeEntry(this, source, source, key, values);
          });
          this.setDir(preDir.dirName, preDir);
          updateDirtyReaders(this, Path::create(preDirName.tag(), DirTag()));
          this.setDir(preDirName, preDir)
        | Some(preDir) ->
          (isReset, changes) = dir.getChangesAfter(this.tick.prev());
          for (key in changes) {
            values = dir.getArrayRaw(key).collect(Array);
            !withChange = true;
            source = Path::create(preDir.dirName, key);
            !preDir = preDir.writeEntry(this, source, source, key, values);
          };
          if (isReset) {
            writerPath = Path(preDir.dirName, IID(genSym(0)));
            !preDir = preDir.reset(this, writerPath, changes);
          };
          this.setDir(preDir.dirName, preDir)
        }
      })
    });
    withChange
  }

  mutable fun checkPostWrites(): Bool {
    withChange = !this.postWrites.isEmpty();
    if (withChange) {
      toWrite = this.postWrites.reversed();
      this.!postWrites = List[];
      this.postWrite(toWrite);
    };
    withChange;
  }

  mutable fun updateLazyGets(): void {
    for (path in this.lazyGets) {
      refCount = this.lazyGetsRefCount.maybeGet(path) match {
      | None() -> 0
      | Some(x) -> x
      };
      this.!lazyGetsRefCount[path] = refCount + 1;
    };
    this.!lazyGetsQueueIn = List.Cons(
      this.lazyGets.toArray(),
      this.lazyGetsQueueIn,
    );
    this.!lazyGets = SortedSet[];
    if (this.tick <= Tick(this.lazyCapacity)) return void;
    queue = this.lazyGetsQueueOut match {
    | List.Nil() ->
      invariant(this.lazyGetsQueueIn is List.Cons _);
      this.!lazyGetsQueueOut = this.lazyGetsQueueIn.reversed();
      this.!lazyGetsQueueIn = List[];
      this.lazyGetsQueueOut
    | l -> l
    };
    queue match {
    | List.Nil() -> invariant_violation("LazyGets reached empty queue")
    | List.Cons(lazyGets, rl) ->
      this.!lazyGetsQueueOut = rl;
      toRemove = mutable Map[];
      for (path in lazyGets) {
        this.lazyGetsRefCount.maybeGet(path) match {
        | None() ->
          // Not found, but since the aim is to remove them, we can do nothing.
          void
        | Some(refCount) ->
          !refCount = refCount - 1;
          if (refCount == 0) {
            this.!lazyGetsRefCount = this.lazyGetsRefCount.remove(path);
            if (!toRemove.containsKey(path.dirName)) {
              toRemove![path.dirName] = SortedSet[];
            };
            toRemove![path.dirName] = toRemove[path.dirName].set(path.baseName);
          } else {
            this.!lazyGetsRefCount[path] = refCount;
          }
        };
      };
      for (dirName => keys in toRemove) {
        dir = this.unsafeGetLazyDir(dirName);
        data = dir.data;
        for (key in keys) {
          data.maybeGet(key) match {
          | Some(LDefined(_, reads)) -> !data[key] = LRemoved(reads)
          | _ -> void
          };
        };
        !dir.data = data;
        this.setDir(dirName, dir)
      }
    };
  }

  mutable fun update(): void {
    hasBackgroundWork = this.updateWithStatus(0);
    if (hasBackgroundWork) {
      invariant_violation(
        "update should not be called when there is background work" +
          "use updateWithStatus instead",
      );
    };
    void
  }

  mutable fun updateWithStatus(backgroundRounds: Int): Bool {
    invariant(
      this.currentArrow().isNone(),
      "updateWithStatus cannot be called during update.",
    );
    if (this.debugMode) {
      print_string(`------------ UPDATE (TICK: ${this.tick}) ------------`);
    };

    _ = this.timeStamp();

    this.updateLazyGets();

    while (backgroundRounds > 0) {
      roundsCopy = backgroundRounds;
      !backgroundRounds = withRegion(this, (obstack, context) ~> {
        rounds = roundsCopy;
        while (rounds > 0) {
          path = context.popAsync() match {
          | None() ->
            !rounds = 0;
            break void
          | Some(x) -> x
          };
          dir = context.unsafeGetLazyDir(path.dirName);
          _ = dir.unsafeGetArray(context, path.baseName);
          updateDirtyReaders(context, path, false);
          !rounds = rounds - 1;
          if (shouldGC(obstack) != 0) {
            break void;
          }
        };
        rounds
      })
    };

    dirty = mutable Map<DirName, SortedSet<Key>>[];
    dirtyReaders = mutable Map<DirName, mutable Map<DirName, SortedSet<Key>>>[];

    loop {
      for (path in this.dirty) {
        dirty.maybeGet(path.dirName) match {
        | None() ->
          set = SortedSet[path.baseName];
          dirty![path.dirName] = set
        | Some(set) -> dirty![path.dirName] = set.set(path.baseName)
        };
      };
      this.!dirty = List[];
      for (reader in this.dirtyReaders) {
        if (!dirtyReaders.containsKey(reader.parentName)) {
          dirtyReaders![reader.parentName] = mutable Map[];
        };

        if (!dirtyReaders[reader.parentName].containsKey(reader.childName)) {
          dirtyReaders[reader.parentName]![reader.childName] = SortedSet[];
        };
        dirtyReaders[reader.parentName]![reader.childName] = dirtyReaders[
          reader.parentName,
        ][reader.childName].set(reader.key);
      };
      this.!dirtyReaders = List[];
      toUpdate = this.toUpdate.minimum();
      toUpdate match {
      | None() ->
        invariant(this.dirty.isEmpty());
        invariant(this.dirtyReaders.isEmpty());
        withPostWrites = this.checkPostWrites();
        withPre = this.updatePre();
        withChanges = withPostWrites || withPre || !this.asyncList.isEmpty();
        this.!toReset = SortedSet[];
        this.!tick = this.tick.next();
        break withChanges
      | Some((time, Arrow(parentName, childName))) ->
        this.!toReset = this.toReset.set(childName);
        this.!toUpdate = this.toUpdate.remove(time);
        this.unsafeMaybeGetDir(childName) match {
        | None()
        | Some(DeletedDir _) ->
          void
        | Some(child @ LazyDir _) ->
          child.update(this, dirtyReaders.maybeGet(child.dirName))
        | Some(child @ EagerDir _) ->
          this.!toReset = this.toReset.set(parentName);
          parentMaps = child.parents.maybeGet(parentName) match {
          | None() -> invariant_violation("Could not find parent")
          | Some(f) -> f
          };
          EagerDir::update(
            this,
            dirty,
            dirtyReaders,
            parentName,
            parentMaps,
            child,
          )
        }
      }
    }
  }

  mutable fun postWrite(list: List<ToWrite>): void {
    list match {
    | List.Nil() -> void
    | List.Cons(ToWrite(dirName, key, values), rl) ->
      this.unsafeMaybeGetEagerDir(dirName) match {
      | Some(dir) ->
        dir.writeArray(this, key, values(this));
        this.postWrite(rl)
      | _ -> void
      }
    }
  }

  readonly fun notifySub(sub: Sub, start: Tick): void {
    lock = unfreezeLock(sub.lock);
    mutexLock(lock);
    sub.cmd match {
    | NUpdates(filename) ->
      file = IO.File::open(
        filename,
        IO.OpenOptions{
          write => true,
          create => true,
          append => true,
          mode => 0o777,
        },
      );
      o = x -> _ = file.write_all(x.bytes());
      writer = mutable Debug.BufferedWriter(o, 4096);

      producedAnyOutput = false;
      for (dirSub in sub.dirSubs) {
        dirName = dirSub.dirName;
        this.unsafeMaybeGetDir(dirName) match {
        | Some(dir @ EagerDir _) ->
          (isReset, changes) = dir.getChangesAfter(start);
          ctx = this.clone();
          producedOutput = dir.writeDiff(
            ctx,
            isReset,
            changes.iterator(),
            writer,
            dirSub.entity,
            dirSub.format,
            dirSub.filter,
            dirSub.getDestinationWatermark(ctx),
          );
          !producedAnyOutput = producedAnyOutput || producedOutput
        | _ -> void
        }
      };
      if (producedAnyOutput) {
        // then we need to produce a checkpoint for flushing and committing
        ourTime = this.tick.value.toString();
        writer.write(`:${ourTime}\n`);
        writer.flush();
        flushStdout();
      };

      file.close()
    | NNotify(file) -> _ = unixNotify(file, Int32::truncate(start.value))
    | NTail() ->
      cond = unfreezeCond(sub.cond);
      _ = condBroadcast(cond)
    };
    mutexUnlock(lock)
  }

  readonly fun notifyAll(start: Tick): void {
    changedDirNames = this.getGlobal("CHANGED_DIRS") match {
    | None() -> this.dirs.state.getChangesAfter(start)
    | Some(x @ ChangedDirs _) -> x.value
    | _ -> invariant_violation("Wrong type for CHANGED_DIRS")
    };
    if (this.tick == start) return void;
    for (_ => sub in this.sessions) {
      affected = for (dirSub in sub.dirSubs) {
        if (changedDirNames.contains(dirSub.dirName)) break true
      } else {
        false
      };
      if (!affected) continue;
      this.notifySub(sub, start)
    }
  }

  mutable fun timeStamp(): Time {
    this.!time = this.time.next();
    this.time
  }

  mutable fun mkdir<K: Key, V: File>(
    convKey: Key ~> K,
    convValue: File ~> V,
    dirName: DirName,
    content: Array<(K, V)> = Array[],
  ): EHandle<K, V> {
    this.mkdirMulti(
      dirName,
      content.map(kv -> {
        (key, value) = kv;
        (key, Array[value])
      }),
    );
    EHandle(convKey, convValue, dirName)
  }

  mutable fun mkdirMulti(
    dirName: DirName,
    content: Array<(Key, Array<File>)> = Array[],
  ): void {
    this.unsafeMaybeGetEagerDir(dirName).each(dir ->
      if (dir.creator != this.currentArrow()) {
        // In eager dir, if several properties are invalidated in same tick
        // the delete could be called several time so the directory could exist
        throw DirAlreadyExists(dirName);
      }
    );
    !content = content.sortedBy(x ~> x.i0);
    vector: mutable Vector<FixedRow<Array<File>>> = mutable Vector[];
    valueAcc = mutable Vector[];
    last: ?Key = None();
    time = this.timeStamp();
    tick = this.tick;

    for (kv in content) {
      (key, values) = kv;
      last match {
      | None() ->
        valueAcc.extend(values);
        !last = Some(key)
      | Some(oldKey) if (oldKey == key) -> valueAcc.extend(values)
      | Some(oldKey) ->
        source = Path::create(dirName, oldKey);
        vector.push(
          FixedRow(oldKey, valueAcc.toArray(), source, TickRange::create(tick)),
        );
        !last = Some(key);
        valueAcc.clear();
        valueAcc.extend(values)
      };
    };
    last match {
    | None() -> void
    | Some(key) ->
      source = Path::create(dirName, key);
      vector.push(
        FixedRow(key, valueAcc.toArray(), source, TickRange::create(tick)),
      )
    };
    fixedData = FixedDataMap::create(vector);

    totalSize = fixedData.data.size();
    creator = this.currentArrow();
    dir = EagerDir{time, input => true, dirName, fixedData, totalSize, creator};
    this.setDir(dirName, dir);
    this.!newDirs = this.newDirs.add(dirName);
  }

  mutable fun setDir(dirName: DirName, dir: Dir): void {
    this.!dirs = this.dirs.set(this.tick, dirName, dir);
  }

  mutable fun getDir(dirName: DirName): Dir {
    this.addDep(Path::create(dirName.tag(), DirTag()));
    this.dirs.get(dirName);
  }

  readonly fun unsafeGetDir(dirName: DirName): Dir {
    this.dirs.get(dirName);
  }

  readonly fun unsafeGetLazyDir(dirName: DirName): LazyDir {
    this.unsafeGetDir(dirName) match {
    | d @ LazyDir _ -> d
    | _ -> invariant_violation("unsafeGetLazyDir: Was expecting LazyDir")
    }
  }

  readonly fun unsafeGetEagerDir(dirName: DirName): EagerDir {
    this.unsafeGetDir(dirName) match {
    | d @ EagerDir _ -> d
    | _ -> invariant_violation("unsafeGetEagerDir: Was expecting EagerDir")
    }
  }

  readonly fun unsafeMaybeGetLazyDir(dirName: DirName): ?LazyDir {
    this.unsafeMaybeGetDir(dirName) match {
    | None()
    | Some(DeletedDir _) ->
      None()
    | Some(d @ LazyDir _) -> Some(d)
    | _ -> invariant_violation("unsafeMaybeGetLazyDir: Was expecting LazyDir")
    }
  }

  readonly fun unsafeMaybeGetEagerDir(dirName: DirName): ?EagerDir {
    this.unsafeMaybeGetDir(dirName) match {
    | None()
    | Some(DeletedDir _) ->
      None()
    | Some(d @ EagerDir _) -> Some(d)
    | _ -> invariant_violation("unsafeMaybeGetEagerDir: Was expecting EagerDir")
    }
  }

  mutable fun getLazyDir(dirName: DirName): LazyDir {
    this.getDir(dirName) match {
    | d @ LazyDir _ -> d
    | _ -> invariant_violation("getLazyDir: Was expecting LazyDir")
    }
  }

  mutable fun getEagerDir(dirName: DirName): EagerDir {
    this.getDir(dirName) match {
    | d @ EagerDir _ -> d
    | _ -> invariant_violation("getEagerDir: Was expecting EagerDir")
    }
  }

  mutable fun maybeGetLazyDir(dirName: DirName): ?LazyDir {
    this.maybeGetDir(dirName) match {
    | None()
    | Some(DeletedDir _) ->
      None()
    | Some(d @ LazyDir _) -> Some(d)
    | _ -> invariant_violation("maybeGetLazyDir: Was expecting LazyDir")
    }
  }

  mutable fun maybeGetEagerDir(dirName: DirName): ?EagerDir {
    this.maybeGetDir(dirName) match {
    | None()
    | Some(DeletedDir _) ->
      None()
    | Some(d @ EagerDir _) -> Some(d)
    | _ -> invariant_violation("maybeGetEagerDir: Was expecting EagerDir")
    }
  }

  mutable fun removeDir(dirName: DirName): void {
    if (this.debugMode) {
      print_string("REMOVED: " + dirName);
    };
    if (this.hasPre.contains(dirName)) {
      this.!hasPre = this.hasPre.remove(dirName);
    };
    this.unsafeMaybeGetEagerDir(dirName) match {
    | None() -> return void
    | Some(dir) ->
      for (parentName => _ in dir.parents) {
        this.unsafeMaybeGetEagerDir(parentName) match {
        | None() -> continue
        | Some(parent) ->
          !parent.childDirs = parent.childDirs.remove(dirName);
          this.setDir(parent.dirName, parent)
        }
      }
    };
    this.!deps = this.deps.removeDir(dirName);
    this.!dirsWithSharedSubDirs = this.dirsWithSharedSubDirs.remove(dirName);
    this.!sharedSubDirsRefCount = this.sharedSubDirsRefCount.remove(dirName);
    this.setDir(dirName, DeletedDir{dirName, time => this.timeStamp()});
  }

  mutable fun maybeGetDir<T: File>(dirName: DirName): ?Dir {
    this.addDep(Path::create(dirName.tag(), DirTag()));
    this.dirs.maybeGet(dirName);
  }

  readonly fun unsafeMaybeGetDir<T: File>(dirName: DirName): ?Dir {
    this.dirs.maybeGet(dirName);
  }

  mutable fun addDep(path: Path): void {
    this.!reads = this.reads.set(path);
  }

  mutable fun setGlobal(name: String, file: File): void {
    this.!globals = this.globals.set(name, file);
  }

  mutable fun removeGlobal(name: String): void {
    this.!globals = this.globals.remove(name);
  }

  readonly fun getGlobal(name: String): ?File {
    this.globals.maybeGet(name)
  }
}

// @cpp_extern("SKIP_print_backtrace")
// native fun printBacktrace(): void;

class Dirs{state: DMap<DirName, Dir> = DMap::empty()} {
  fun set<T: File>(tick: Tick, key: DirName, value: Dir): this {
    !this.state = this.state.set(TickRange::create(tick), key, value);
    this
  }
  fun maybeGet(key: DirName): ?Dir {
    this.state.maybeGet(key)
  }
  fun get(key: DirName): Dir {
    this.maybeGet(key) match {
    | None() ->
      // printBacktrace();
      invariant_violation("Directory not found: " + key)
    | Some(x) -> x
    }
  }
}

fun export(
  targetCtx: mutable Context,
  tick: Tick,
  sourceCtx: readonly Context,
): Bool {
  import(targetCtx, tick, sourceCtx);
  false
}

fun import(
  targetCtx: mutable Context,
  tick: Tick,
  sourceCtx: readonly Context,
): void {
  changedDirNames = sourceCtx.dirs.state.getChangesAfter(tick);
  for (dirName in changedDirNames) {
    sourceCtx.unsafeMaybeGetDir(dirName) match {
    | Some(DeletedDir{}) -> targetCtx.removeDir(dirName)
    | Some(dir @ EagerDir{input => true, creator => None()}) ->
      (isReset, changedKeys) = dir.getChangesAfter(tick);
      targetCtx.unsafeMaybeGetDir(dirName) match {
      | None() -> void
      | Some(EagerDir{input => true}) ->
        entries = mutable Vector[];
        for (key in changedKeys) {
          for (srcValue in dir.unsafeGetAllDataIterAfter(tick, key)) {
            (_, source, writer, values) = srcValue;
            entries.push((key, (source, writer, values)));
          }
        };
        targetCtx.unsafeMaybeGetEagerDir(dir.dirName) match {
        | None() ->
          if (dir.creator is None()) {
            targetCtx.setDir(dir.dirName, dir);
          }
        | Some(inputDir) ->
          !inputDir = inputDir.writeArraySourceManyReturnDir(
            targetCtx,
            entries.iterator(),
          );
          if (isReset) {
            writerPath = SKStore.Path(
              dir.dirName,
              SKStore.IID(SKStore.genSym(0)),
            );
            !inputDir = inputDir.reset(targetCtx, writerPath, changedKeys);
          };
          targetCtx.setDir(inputDir.dirName, inputDir)
        }
      | Some(_) -> invariant_violation("Error import: incompatible dir types")
      }
    | _ -> void
    }
  };
}

class Synchronizer(
  importFromRoot: ((mutable Context, Tick, readonly Context) ~> void),
  exportToRoot: ((mutable Context, Tick, readonly Context) ~> Bool),
  afterUnlock: (mutable Context ~> void),
)

class ChangedDirs(value: SortedSet<DirName>) extends File

fun cloneContextWithError(context: Context, error: .Exception): Context {
  newContext = Context::fromSaved(context);
  newContext.setGlobal("Error", ErrorFile(error));
  newContext.clone()
}

@export("SKIP_resolve_context")
fun resolveContext(
  tick: Tick,
  root: Context,
  delta: mutable Context,
  synchronizer: ?Synchronizer,
  lockF: ?((mutable Context, mutable Context, Context) ~> void),
): readonly Context {
  context = synchronizer match {
  | None() if (tick == root.tick) -> delta
  | None() -> invariant_violation("Concurrent access without synchronizer")
  | Some(sync) ->
    changedDirs = delta.dirs.state.getChangesAfter(tick);
    try {
      sync.importFromRoot(delta, tick, root);
      None()
    } catch {
    | exn -> Some(exn)
    } match {
    | Some(exn) -> return cloneContextWithError(root, exn)
    | _ -> void
    };

    newRoot = Context::fromSaved(root);
    newRoot.!globals = delta.globals;
    hasVersioning = false;

    try {
      !hasVersioning = sync.exportToRoot(newRoot, tick, delta);
      None()
    } catch {
    | exn -> Some(exn)
    } match {
    | Some(exn) -> return cloneContextWithError(root, exn)
    | _ -> void
    };

    lockF match {
    | None() -> void
    | Some(f) ->
      try {
        newRootTick = newRoot.tick;
        f(newRoot, delta, root);
        !changedDirs = changedDirs.union(
          newRoot.dirs.state.getChangesAfter(newRootTick),
        );
        None()
      } catch {
      | exn -> Some(exn)
      } match {
      | Some(exn) -> return cloneContextWithError(root, exn)
      | _ -> void
      }
    };
    if (!hasVersioning) {
      newRoot.setGlobal("CHANGED_DIRS", ChangedDirs(changedDirs));
    };
    newRoot
  };
  for (dirName in context.toPurge) {
    context.unsafeMaybeGetEagerDir(dirName) match {
    | None() -> void
    | Some(dir) ->
      !dir = dir.purge(context, Tick(context.tick.value - 1000));
      context.setDir(dirName, dir)
    }
  };
  context.!toPurge = SortedSet[];
  context
}

@export("SKIP_call_after_unlock")
fun callAfterUnlock(
  synchronizer: ?Synchronizer,
  context: mutable Context,
): void {
  synchronizer match {
  | None() -> void
  | Some(sync) -> sync.afterUnlock(context)
  }
}

/*****************************************************************************/
/* Locks/Conditions. */
/*****************************************************************************/

mutable class Mutex(Int, Int, Int, Int, Int)
mutable class Condition(Int, Int, Int, Int, Int, Int)

@cpp_extern("SKIP_mutex_init")
native fun mutexInit(mutable Mutex): void;

fun mutexCreate(): Mutex {
  lock = mutable Mutex(0, 0, 0, 0, 0);
  mutexInit(lock);
  freezeLock(lock)
}

@debug
@cpp_extern("SKIP_mutex_lock")
native fun mutexLock(mutable Mutex): void;

@debug
@cpp_extern("SKIP_mutex_unlock")
native fun mutexUnlock(mutable Mutex): void;

@cpp_extern("SKIP_cond_init")
native fun condInit(mutable Condition): void;

fun condCreate(): Condition {
  cond = mutable Condition(0, 0, 0, 0, 0, 0);
  condInit(cond);
  freezeCond(cond)
}

@debug
@cpp_extern("SKIP_cond_wait")
native fun condWait(mutable Condition, mutable Mutex): Int32;

@debug
@cpp_extern("SKIP_cond_timedwait")
native fun condTimedWait(mutable Condition, mutable Mutex, UInt32): Int32;

@debug
@cpp_extern("SKIP_cond_broadcast")
native fun condBroadcast(mutable Condition): Int32;

@debug
@cpp_extern("pthread_cond_signal")
native fun condSignal(mutable Condition): Int32;

@cpp_extern("SKIP_freeze_lock")
native fun freezeLock(lock: mutable Mutex): Mutex;

@cpp_extern("SKIP_unfreeze_lock")
native fun unfreezeLock(lock: Mutex): mutable Mutex;

@cpp_extern("SKIP_freeze_cond")
native fun freezeCond(cond: mutable Condition): Condition;

@cpp_extern("SKIP_unfreeze_cond")
native fun unfreezeCond(cond: Condition): mutable Condition;

/*****************************************************************************/
/* Runtime primitives. */
/*****************************************************************************/

@cpp_extern
private native base class Obstack

@debug
@cpp_extern("SKIP_new_Obstack")
private native fun newObstack(): Obstack;

@debug
@cpp_extern("SKIP_destroy_Obstack")
private native fun destroyObstack(Obstack): void;

@debug
@cpp_extern("SKIP_destroy_Obstack_with_value")
private native fun destroyObstackWithValue<T>(Obstack, List<T>): List<T>;

@debug
@cpp_extern("SKIP_context_sync")
private native fun gContextSync(
  Tick,
  Context,
  Context,
  ?Synchronizer,
  UInt32,
  ?((mutable Context, mutable Context, Context) ~> void),
): Context;

@debug
@cpp_extern("SKIP_context_sync_no_lock")
private native fun gContextSyncNoLock(
  Tick,
  Context,
  Context,
  ?Synchronizer,
  UInt32,
  ?((mutable Context, mutable Context, Context) ~> void),
): Context;

@debug
@cpp_extern("SKIP_global_unlock")
private native fun gGlobalUnlock(): void;

@debug
@cpp_extern("SKIP_global_lock")
private native fun gGlobalLock(): void;

@debug
@cpp_extern("SKIP_global_has_lock")
private native fun gGlobalHasLock(): UInt32;

@debug
@cpp_extern("SKIP_context_init")
private native fun gContextInit(Context): void;

@debug
@cpp_extern("SKIP_context_get")
native fun gUnsafeContextGet(): Context;

@debug
@cpp_extern("SKIP_context_get_unsafe")
native fun gContextGetNoLock(): Context;

class InvalidSync() extends Exception {
  fun toString(): String {
    "Internal error: invalid synchronization, getContext called too many times"
  }
}

@debug
@export("SKIP_throwInvalidSynchronization")
fun throwInvalidSynchronization(): void {
  throw InvalidSync()
}

@debug
@cpp_extern("SKIP_has_context")
native fun gHasContext(): UInt32;

@debug
@cpp_extern("SKIP_unsafe_free")
native fun gUnsafeFree(Context): void;

@debug
@cpp_extern("SKIP_unsafe_context_incr_ref_count")
native fun gUnsafeIncrRefCount(Context): void;

@debug
@cpp_extern("SKIP_should_GC")
native fun shouldGC(Obstack): UInt32;

@cpp_extern("SKIP_print_persistent_size")
native fun printPersistentSize(): void;

/*****************************************************************************/
/* Safe way to use a context. */
/*****************************************************************************/

fun withContext<T>(f: Context -> T): T {
  context = gUnsafeContextGet();
  try {
    result = f(context);
    gUnsafeFree(context);
    result
  } catch {
  | exn ->
    gUnsafeFree(context);
    throw exn
  }
}

base class ContextOp {
  children =
  | CContinue(?((mutable Context, mutable Context, Context) ~> void))
  | CStop(?((mutable Context, mutable Context, Context) ~> void))
}

@cpp_noinline
fun runWithGcIntern(
  initCtx: Context,
  f: Context ~> (Context, ContextOp),
  synchronizer: ?Synchronizer,
  isync: Bool = false,
): Context {
  sync = UInt32::truncate(if (isync) 1 else 0);
  if (gHasContext() == 0) {
    gContextInit(initCtx);
  };
  context = synchronizer match {
  | None() ->
    gGlobalLock();
    gContextGetNoLock()
  | Some _ -> gUnsafeContextGet()
  };
  globals = initCtx.globals;
  loop {
    startTick = context.tick;
    pos = newObstack();
    (newContext, newContextOp) = (try {
      Some(f(context with {globals}))
    } catch {
    | exn ->
      print_error(exn.getMessage());
      None()
    }) match {
    | Some(x) -> x
    | None() -> return context
    };
    newContextOp match {
    | CContinue(underLockF) ->
      synchronizer match {
      | None() ->
        !context = gContextSyncNoLock(
          startTick,
          context,
          newContext,
          synchronizer,
          sync,
          underLockF,
        );
        gGlobalUnlock();
        context.notifyAll(startTick);
        destroyObstack(pos)
      | Some _ ->
        !context = gContextSync(
          startTick,
          context,
          newContext,
          synchronizer,
          sync,
          underLockF,
        );
        context.notifyAll(startTick);
        destroyObstack(pos)
      }
    | CStop(underLockF) ->
      synchronizer match {
      | None() ->
        !context = gContextSyncNoLock(
          startTick,
          context,
          newContext,
          synchronizer,
          sync,
          underLockF,
        );
        gGlobalUnlock();
        context.notifyAll(startTick);
        gUnsafeFree(context);
        destroyObstack(pos);
        return context
      | Some _ ->
        !context = gContextSync(
          startTick,
          context,
          newContext,
          synchronizer,
          sync,
          underLockF,
        );
        context.notifyAll(startTick);
        gUnsafeFree(context);
        destroyObstack(pos);
        return context
      }
    };
    !globals = context.globals;
  }
}

@cpp_noinline
fun runLocked(
  initCtx: Context,
  f: mutable Context ~> void,
  sync: Bool = false,
): void {
  if (gHasContext() == 0) {
    gContextInit(initCtx);
  };
  gGlobalLock();
  root = gContextGetNoLock();
  start = root.tick;
  context = Context::fromSaved(root);
  f(context);
  newRoot = gContextSyncNoLock(
    root.tick,
    root,
    context.clone(),
    None(),
    if (sync) UInt32::truncate(1) else UInt32::truncate(0),
    None(),
  );
  gGlobalUnlock();
  newRoot.notifyAll(start);
  gUnsafeFree(newRoot);
}

@cpp_noinline
fun runWithGc(
  initCtx: Context,
  f: mutable Context ~> ContextOp,
  synchronizer: ?Synchronizer = None(),
  sync: Bool = false,
): void {
  _ = runWithGcIntern(
    initCtx,
    icontext ~> {
      context = Context::fromSaved(icontext);
      cop = f(context);
      (context.clone(), cop);
    },
    synchronizer,
    sync,
  )
}

@cpp_noinline
fun runWithGcReturnContext(
  initCtx: Context,
  f: mutable Context ~> ContextOp,
  synchronizer: ?Synchronizer = None(),
): mutable Context {
  result = runWithGcIntern(
    initCtx,
    icontext ~> {
      context = Context::fromSaved(icontext);
      cop = f(context);
      (context.clone(), cop);
    },
    synchronizer,
  );
  Context::fromSaved(result)
}

fun withRegion<T>(
  context: mutable Context,
  f: (Obstack, mutable Context) ~> T,
): T {
  optSaved: ?Obstack = None();
  try {
    !optSaved = Some(newObstack());
    saved = optSaved.fromSome();
    fresult = f(saved, context);
    copied = destroyObstackWithValue(saved, List[(context.clone(), fresult)]);
    (icontext, copiedResult) = copied.getHead();
    context.replaceFromSaved(icontext);
    copiedResult
  } catch {
  | exn ->
    optSaved match {
    | Some(saved) ->
      cexn = destroyObstackWithValue(saved, List[exn]).getHead();
      saveExn(cexn);
      throw cexn
    | _ -> throw exn
    }
  }
}

fun withRegionVoid<T>(f: () ~> void): void {
  optSaved: ?Obstack = None();
  try {
    !optSaved = Some(newObstack());
    f();
    destroyObstack(optSaved.fromSome());
  } catch {
  | exn ->
    optSaved match {
    | Some(saved) ->
      cexn = destroyObstackWithValue(saved, List[exn]).getHead();
      saveExn(cexn);
      throw cexn
    | _ -> throw exn
    }
  }
}

fun withRegionValue<T>(f: () ~> T): T {
  optSaved: ?Obstack = None();
  try {
    !optSaved = Some(newObstack());
    fresult = f();
    copied = destroyObstackWithValue(optSaved.fromSome(), List[fresult]);
    copied.getHead();
  } catch {
  | exn ->
    optSaved match {
    | Some(saved) ->
      cexn = destroyObstackWithValue(saved, List[exn]).getHead();
      saveExn(cexn);
      throw cexn
    | _ -> throw exn
    }
  }
}

fun copyToParentObstack<T>(
  contextOpt: ?mutable Context,
  value: T,
  saved: Obstack,
): T {
  (icontextOpt, !value) = SKStore.destroyObstackWithValue(
    saved,
    List[(contextOpt.map(ctx -> ctx.clone()), value)],
  ).getHead();
  icontextOpt.each(icontext ->
    contextOpt.fromSome().replaceFromSaved(icontext)
  );
  value
}

fun withRegionFold<K, T>(
  contextOpt: ?mutable Context,
  it: mutable Iterator<K>,
  value: T,
  fn: (?mutable Context, K, T) ~> T,
): T {
  optSaved: ?Obstack = None();
  valueInRegion = value;
  try {
    !optSaved = Some(newObstack());
    loop {
      saved = optSaved.fromSome();
      it.next() match {
      | Some(k) ->
        !valueInRegion = fn(contextOpt, k, valueInRegion);
        if (shouldGC(saved) != 0) {
          !valueInRegion = copyToParentObstack(
            contextOpt,
            valueInRegion,
            saved,
          );
          !optSaved = Some(SKStore.newObstack());
        }
      | _ -> break void
      }
    };
    optSaved match {
    | Some(saved) -> copyToParentObstack(contextOpt, valueInRegion, saved)
    | _ -> value
    }
  } catch {
  | exn ->
    optSaved match {
    | Some(saved) ->
      cexn = destroyObstackWithValue(saved, List[exn]).getHead();
      saveExn(cexn);
      throw cexn
    | _ -> throw exn
    }
  }
}

fun withRegionFoldRec<K, T>(
  contextOpt: ?mutable Context,
  it: mutable Iterator<K>,
  value: T,
  fn: (?mutable Context, K, T) ~> T,
): T {
  valueInRegion = value;
  levels = 0;
  loop {
    it.next() match {
    | Some(val) ->
      !valueInRegion = withRegionFoldRecHelp(
        contextOpt,
        val,
        it,
        valueInRegion,
        fn,
        levels,
      )
    | None() -> break valueInRegion
    };
    !levels = levels + 1;
  }
}

fun withRegionFoldRecHelp<K, T>(
  contextOpt: ?mutable Context,
  first: K,
  it: mutable Iterator<K>,
  value: T,
  fn: (?mutable Context, K, T) ~> T,
  level: Int,
): T {
  optSaved: ?Obstack = None();
  try {
    !optSaved = Some(newObstack());
    valueInRegion = fn(contextOpt, first, value);
    i = 0;
    loop {
      it.next() match {
      | Some(k) ->
        if (level < 1) {
          !valueInRegion = fn(contextOpt, k, valueInRegion);
          if (i > 64) {
            break void
          }
        } else {
          !valueInRegion = withRegionFoldRecHelp(
            contextOpt,
            k,
            it,
            valueInRegion,
            fn,
            level - 1,
          );
          if (i > 8) {
            break void
          };
        }
      | _ -> break void
      };
      !i = i + 1;
    };
    optSaved match {
    | Some(saved) -> copyToParentObstack(contextOpt, valueInRegion, saved)
    | _ -> value
    }
  } catch {
  | exn ->
    optSaved match {
    | Some(saved) ->
      cexn = destroyObstackWithValue(saved, List[exn]).getHead();
      saveExn(cexn);
      throw cexn
    | _ -> throw exn
    }
  }
}

module end;
