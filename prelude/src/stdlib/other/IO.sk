module IO;

fun stdin(): mutable File {
  mutable File(0, "/dev/stdin")
}

fun stdout(): mutable File {
  mutable File(1, "/dev/stdout")
}

fun stderr(): mutable File {
  mutable File(2, "/dev/stderr")
}

class OpenOptions{
  read: Bool = false,
  write: Bool = false,
  append: Bool = false,
  truncate: Bool = false,
  create: Bool = false,
  create_new: Bool = false,
  mode: Int = 0o777,
} {
  fun flags(): Int {
    // TODO: Check validity of flags.
    Posix.open_flags(
      if (this.read) 1 else 0,
      if (this.write) 1 else 0,
      if (this.append) 1 else 0,
      if (this.truncate) 1 else 0,
      if (this.create) 1 else 0,
      if (this.create_new) 1 else 0,
    )
  }
}

// TODO: Proper subclasses mapping to error codes.
class Error(code: Int) extends Exception uses Show {
  fun toString(): String {
    `Error ${this.code}`
  }
}

trait Read {
  mutable fun read(buf: mutable MutableSlice<UInt8>): Result<Int, Error>;

  mutable fun read_to_end(buf: mutable Vector<UInt8>): Result<Int, Error> {
    nbytes = 0;
    loop {
      if (buf.size() == buf.capacity()) {
        buf.ensureCapacity(buf.capacity() + 32)
      };
      spare = buf.unsafeSpareCapacitySlice();
      this.read(spare) match {
      | Success(0) -> break void
      | Success(sz) ->
        !nbytes = nbytes + sz;
        buf.unsafeSetSize(buf.size() + sz)
      | Failure(err) -> return Failure(err)
      }
    };

    Success(nbytes)
  }

  mutable fun read_to_string(): Result<String, Error> {
    buf = mutable Vector<UInt8>[];
    this.read_to_end(buf) match {
    | Success _ -> Success(String::fromUtf8(buf.collect(Array)))
    | Failure(err) -> Failure(err)
    }
  }

  mutable fun read_exact(
    buf: mutable MutableSlice<UInt8>,
  ): Result<void, Error> {
    nbytes = 0;
    while (nbytes != buf.size()) {
      this.read(buf.msubslice(nbytes)) match {
      | Success(0) ->
        return Failure(Error(-1)) // TODO: Proper ErrorUnexpectedEOF.
      | Failure(err) -> return Failure(err)
      | Success(sz) -> !nbytes = nbytes + sz
      }
    };

    Success(void)
  }
}

trait Write {
  mutable fun write(buf: readonly Slice<UInt8>): Result<Int, Error>;

  mutable fun write_all(buf: readonly Slice<UInt8>): Result<void, Error> {
    while (buf.size() > 0) {
      this.write(buf) match {
      | Success(sz) -> !buf = buf.subslice(sz)
      | Failure(err) -> return Failure(err)
      }
    };

    Success(void)
  }
}

trait IsTerminal {
  fun isatty(): Bool;
}

mutable class File(
  fileno: Int,
  path: String = "unknown",
) uses Read, Write, IsTerminal {
  static fun open(
    path: String,
    opts: OpenOptions = OpenOptions{},
  ): mutable File {
    mutable File(Posix.open(path, opts.flags(), opts.mode), path)
  }

  readonly fun isatty(): Bool {
    Posix.isatty(this.fileno)
  }

  mutable fun read(buf: mutable MutableSlice<UInt8>): Result<Int, Error> {
    rv = Posix.read(this.fileno, buf.mptr(), buf.size());
    if (rv >= 0) {
      Success(rv)
    } else {
      Failure(Error(-rv))
    }
  }

  mutable fun write(buf: readonly Slice<UInt8>): Result<Int, Error> {
    rv = Posix.write(this.fileno, buf.ptr(), buf.size());
    if (rv >= 0) {
      Success(rv)
    } else {
      Failure(Error(-rv))
    }
  }

  mutable fun close(): void {
    Posix.close(this.fileno)
  }
}

mutable class StringIO(
  private buffer: mutable Vector<UInt8> = mutable Vector[],
  private mutable pos: Int = 0,
) uses Read, Write, IsTerminal {
  fun isatty(): Bool {
    false
  }

  mutable fun read(buf: mutable MutableSlice<UInt8>): Result<Int, Error> {
    readSz = min(buf.size(), this.buffer.size() - this.pos);
    // TODO: Proper copy.
    for (i in Range(0, readSz)) {
      buf![i] = this.buffer[this.pos + i]
    };
    this.!pos = this.pos + readSz;

    Success(readSz)
  }

  mutable fun write(buf: readonly Slice<UInt8>): Result<Int, Error> {
    this.buffer.extend(buf);
    Success(buf.size())
  }
}

trait BufRead extends Read {
  mutable fun fill_buf(): Result<readonly Slice<UInt8>, Error>;
  mutable fun consume(nbytes: Int): void;

  mutable fun has_data_left(): Result<Bool, Error> {
    this.fill_buf() match {
    | Success(buf) -> Success(buf.size() > 0)
    | Failure(err) -> Failure(err)
    }
  }

  mutable fun read(buf: mutable MutableSlice<UInt8>): Result<Int, Error> {
    available = this.fill_buf() match {
    | Failure(err) -> return Failure(err)
    | Success(data) -> data
    };
    sz = min(available.size(), buf.size());
    // TODO: Proper copy.
    for (i in Range(0, sz)) {
      buf![i] = available[i]
    };
    this.consume(sz);

    Success(sz)
  }

  mutable fun read_until(
    delim: UInt8,
    buf: mutable Vector<UInt8>,
  ): Result<Int, Error> {
    nbytes = 0;
    loop {
      available = this.fill_buf() match {
      | Success(data) -> data
      | Failure(err) -> return Failure(err)
      };
      // We have reached EOF.
      if (available.isEmpty()) {
        break void
      };
      (found, count) = available.indexOf(delim) match {
      | Some(index) -> (true, index + 1)
      | None() -> (false, available.size())
      };
      buf.extend(available.subslice(0, count));
      !nbytes = nbytes + count;
      this.consume(count);
      if (found) {
        break void
      }
    };

    Success(nbytes)
  }

  mutable fun read_line(): Result<String, Error> {
    buf = mutable Vector<UInt8>[];
    this.read_until(UInt8::truncate(Chars.lineFeed.code()), buf) match {
    | Success _ -> Success(String::fromUtf8(buf.collect(Array)))
    | Failure(err) -> Failure(err)
    }
  }
}

mutable class BufferedReader<T: mutable Read>(
  private stream: T,
  // TODO: Uninitialized buffer.
  private buffer: mutable Array<UInt8> = Array::mfill(8192, UInt8::truncate(0)),
  private mutable available: Range = Range(0, 0),
) uses BufRead {
  mutable fun fill_buf(): Result<readonly Slice<UInt8>, Error> {
    if (this.available.isEmpty()) {
      this.stream.read(this.buffer.as_mslice()) match {
      | Success(sz) -> this.!available = Range(0, sz)
      | Failure(err) -> return Failure(err)
      }
    };

    Success(
      this.buffer.as_slice().subslice(this.available.start, this.available.end),
    )
  }

  mutable fun consume(nbytes: Int): void {
    this.!available = Range(this.available.start + nbytes, this.available.end)
  }
}
