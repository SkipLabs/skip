/**
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

//
// This module contains the internal optimized implementations of the
// Option type generated by the native back end. It's not intended to
// be used by anything other than the compiler.
//
// The high level idea is that we transform Option from a reference type
// to a value class using one of two strategies:
//
// FlagOption: In the most general case, we can turn Option<T> into
// a value class containing "isSome: Bool" and "value: Unsafe.RawStorage<T>".
// If the isSome flag is true, it corresponds to a Some(x) and x is stored
// inside the value field. Else (isSome is false), it corresponds to a None()
// and the value must not be dereferenced.
//
// SentinelOption: As a special case, when the compiler can determine an
// unused sentinel value for T, it can use SentinelOption instead. Currently
// we use this only for reference types, where a null pointer indicates
// None() and a non-null pointer indicates Some().
//
// Option representation details are of course hidden from the user, so they
// can't actually tell if it's represented as a null pointer.

// TODO: Combine with an "Option" module.
module FastOption;

// This class is a sneaky hack to use covariance to make the Option-derived
// value classes representing "None" and "Some" be subtypes of the same
// value class representing "Option".
//
// For example, the compiler applies this transformation:
//
//   Option<Int> --> FlagOption<Int, OptionTag>
//   Some<Int>   --> FlagOption<Int, SomeTag>
//   None<Int>   --> FlagOption<Int, NoneTag>
//
//   Option<String> --> SentinelOption<String, OptionTag>
//   Some<String>   --> SentinelOption<String, SomeTag>
//   None<String>   --> SentinelOption<String, NoneTag>
//
// Note how Option, Some, None all map to the same value class, but they
// maintain the same subtyping relationship of the original class hierarchy
// via that dummy second covariant type parameter.
private base class OptionTag {
  children =
  | NoneTag()
  | SomeTag()
}

//
// These traits provide common implementation for Option-like classes.
// They have to be split up in order to handle conditional "uses" on
// the value classes.
//

// Basic trait for type testing and accessing the Some value.
private trait FastOptionTrait<+T>(protected valueIfSome: Unsafe.RawStorage<T>) {
  protected readonly fun isSome(): Bool;

  @always_inline
  protected readonly fun unsafeFromSome(): T {
    Unsafe.RawStorage::unsafeGet(this.valueIfSome)
  }
}

// Trait for always-available Option operations.
private trait FastOptionCommonTrait<+T> extends FastOptionTrait<T> {
  fun map<T2>(f: T -> T2): ?T2 {
    if (this.isSome()) {
      Some(f(this.unsafeFromSome()))
    } else {
      None()
    }
  }

  fun flatMap<T2>(f: T -> ?T2): ?T2 {
    if (this.isSome()) {
      f(this.unsafeFromSome())
    } else {
      None()
    }
  }

  fun maybe<T2>(nothing: T2, mjust: T -> T2): T2 {
    if (this.isSome()) {
      mjust(this.unsafeFromSome())
    } else {
      nothing
    }
  }

  fun default<T2>[T: T2](x: T2): T2 {
    if (this.isSome()) {
      this.unsafeFromSome()
    } else {
      x
    }
  }

  fun test(f: T -> Bool): Bool {
    this.maybe(false, f)
  }

  fun fromSome(msg: String = "fromSome called on None"): T {
    if (!this.isSome()) {
      invariant_violation(msg)
    };
    this.unsafeFromSome()
  }

  fun isNone(): Bool {
    !this.isSome()
  }

  fun each(f: T -> void): void {
    if (this.isSome()) {
      f(this.unsafeFromSome())
    }
  }

  untracked fun eachUntracked(f: untracked T -> void): void {
    if (this.isSome()) {
      f(this.unsafeFromSome())
    }
  }

  // async frozen fun gen<U>[T: ^U](): ^?U
  // | None() -> None()
  // | Some(x) -> Some(await x)

  async frozen fun genMap<U>(f: T ~> ^U): ^?U {
    if (this.isSome()) {
      Some(await f(this.unsafeFromSome()))
    } else {
      None()
    }
  }

  async frozen fun genFilter(p: T ~> ^Bool): ^?T {
    if (this.isSome()) {
      x = this.unsafeFromSome();
      if (await (p(x))) {
        return Some(x)
      }
    };

    None()
  }

  fun inspect(): Inspect {
    if (this.isSome()) {
      InspectCall("Some", Array[inspect(this.unsafeFromSome())])
    } else {
      InspectCall("None", Array[])
    }
  }

  // TODO T26257322: remove and use the version from Option
  static fun generator<T2>(
    generator: QuickCheck.Generator<T2>,
  ): QuickCheck.Generator<?T2> {
    QuickCheck.OptionGenerator(generator)
  }

  // TODO T26257322: remove and use the version from Option
  fun perturb[T: QuickCheck.Perturb](rng: mutable Random): void {
    if (this.isSome()) {
      rng.perturb(1);
      this.unsafeFromSome().perturb(rng);
    } else {
      rng.perturb(0)
    }
  }

  // TODO T26257322: remove and use the version from Option
  fun shrink[T: QuickCheck.Shrinkable](
    firstShrink: Bool = true,
  ): mutable Iterator<?T> {
    if (this.isSome()) {
      yield None();
      for (s in this.unsafeFromSome().shrink(firstShrink)) {
        yield Some(s)
      }
    }
  }
}

private trait FastOptionHashableTrait<+T: Hashable> extends
  FastOptionTrait<T>,
  Hashable,
{
  readonly fun hash(): Int {
    if (this.isSome()) {
      this.unsafeFromSome().hash() + 1
    } else {
      // Arbitrary hash value for None(), copied from Option.sk.
      1027410261
    }
  }
}

private trait FastOptionShowTrait<+T: readonly Show> extends
  FastOptionTrait<T>,
  Show,
{
  readonly fun toString(): String {
    if (this.isSome()) {
      `Some(${this.unsafeFromSome().toString()})`
    } else {
      "None()"
    }
  }
}

// An Option implemented as a flag indicating whether the value is "Some",
// and the value if it is.
private value class FlagOption<+T, +Tag: OptionTag>(
  isSomeFlag: Bool,
) uses
  FastOptionCommonTrait<T>,
  Equality[T: Equality],
  FastOptionHashableTrait<T>[T: Hashable],
  Orderable[T: Orderable],
  FastOptionShowTrait<T>[T: readonly Show],
{
  @always_inline
  protected fun isSome(): Bool {
    this.isSomeFlag
  }

  static fun meta<U, C: MetaClass<U>>(itemClass: C): OptionMetaClass<U, C> {
    OptionMetaClass(itemClass)
  }

  fun ==<U: Equality>[T: U](other: FlagOption<U, OptionTag>): Bool {
    (this.isSome(), other.isSome()) match {
    | (true, true) -> (this.unsafeFromSome() : U) == other.unsafeFromSome()
    | (false, false) -> true
    | _ -> false
    }
  }

  fun !=<U: Equality>[T: U](other: FlagOption<U, OptionTag>): Bool {
    (this.isSome(), other.isSome()) match {
    | (true, true) -> (this.unsafeFromSome() : U) != other.unsafeFromSome()
    | (false, false) -> false
    | _ -> true
    }
  }

  fun <<U: Orderable>[T: U](other: FlagOption<U, OptionTag>): Bool {
    (this.isSome(), other.isSome()) match {
    | (true, true) -> this.unsafeFromSome() < other.unsafeFromSome()
    | (false, true) -> true
    | (_, false) -> false
    }
  }

  fun ><U: Orderable>[T: U](other: FlagOption<U, OptionTag>): Bool {
    (this.isSome(), other.isSome()) match {
    | (true, true) -> this.unsafeFromSome() > other.unsafeFromSome()
    | (true, false) -> true
    | (false, _) -> false
    }
  }

  fun <=<U: Orderable>[T: U](other: FlagOption<U, OptionTag>): Bool {
    (this.isSome(), other.isSome()) match {
    | (true, true) -> this.unsafeFromSome() <= other.unsafeFromSome()
    | (true, false) -> false
    | (false, _) -> true
    }
  }

  fun >=<U: Orderable>[T: U](other: FlagOption<U, OptionTag>): Bool {
    (this.isSome(), other.isSome()) match {
    | (true, true) -> this.unsafeFromSome() >= other.unsafeFromSome()
    | (false, true) -> false
    | (_, false) -> true
    }
  }

  // None() is less than Some().
  fun compare<U: Orderable>[T: U](other: FlagOption<U, OptionTag>): Order {
    (this.isSome(), other.isSome()) match {
    | (true, true) -> compare(this.unsafeFromSome(), other.unsafeFromSome())
    | (true, false) -> GT()
    | (false, true) -> LT()
    | (false, false) -> EQ()
    }
  }
}

// An Option implemented using a special sentinel value for "None()", else
// the value. For example a null pointer may be used as the None() value
// for a reference type.
private value class SentinelOption<+T, +Tag: OptionTag>() uses
  FastOptionCommonTrait<T>,
  Equality[T: Equality],
  FastOptionHashableTrait<T>[T: Hashable],
  Orderable[T: Orderable],
  FastOptionShowTrait<T>[T: readonly Show],
{
  @cpp_runtime
  protected native fun isSome(): Bool;

  static fun meta<U, C: MetaClass<U>>(itemClass: C): OptionMetaClass<U, C> {
    OptionMetaClass(itemClass)
  }

  fun ==<U: Equality>[T: U](other: SentinelOption<U, OptionTag>): Bool {
    (this.isSome(), other.isSome()) match {
    | (true, true) -> (this.unsafeFromSome() : U) == other.unsafeFromSome()
    | (false, false) -> true
    | _ -> false
    }
  }

  fun !=<U: Equality>[T: U](other: SentinelOption<U, OptionTag>): Bool {
    (this.isSome(), other.isSome()) match {
    | (true, true) -> (this.unsafeFromSome() : U) != other.unsafeFromSome()
    | (false, false) -> false
    | _ -> true
    }
  }

  fun <<U: Orderable>[T: U](other: SentinelOption<U, OptionTag>): Bool {
    (this.isSome(), other.isSome()) match {
    | (true, true) -> this.unsafeFromSome() < other.unsafeFromSome()
    | (false, true) -> true
    | (_, false) -> false
    }
  }

  fun ><U: Orderable>[T: U](other: SentinelOption<U, OptionTag>): Bool {
    (this.isSome(), other.isSome()) match {
    | (true, true) -> this.unsafeFromSome() > other.unsafeFromSome()
    | (true, false) -> true
    | (false, _) -> false
    }
  }

  fun <=<U: Orderable>[T: U](other: SentinelOption<U, OptionTag>): Bool {
    (this.isSome(), other.isSome()) match {
    | (true, true) -> this.unsafeFromSome() <= other.unsafeFromSome()
    | (true, false) -> false
    | (false, _) -> true
    }
  }

  fun >=<U: Orderable>[T: U](other: SentinelOption<U, OptionTag>): Bool {
    (this.isSome(), other.isSome()) match {
    | (true, true) -> this.unsafeFromSome() >= other.unsafeFromSome()
    | (false, true) -> false
    | (_, false) -> true
    }
  }

  // None() is less than Some().
  fun compare<U: Orderable>[T: U](other: SentinelOption<U, OptionTag>): Order {
    (this.isSome(), other.isSome()) match {
    | (true, true) -> compare(this.unsafeFromSome(), other.unsafeFromSome())
    | (true, false) -> GT()
    | (false, true) -> LT()
    | (false, false) -> EQ()
    }
  }
}
