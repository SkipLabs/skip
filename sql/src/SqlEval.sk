module SKDB;

/*****************************************************************************/
/* Helper functions to evaluate SQL. */
/*****************************************************************************/

// Decode a string to a JSON Object, expected to be a map from key
// strings (parameter names) to values.
fun decodeParams(encoded_params: String): Map<String, Value> {
  try {
    JSON.decode(encoded_params) match {
    | map @ JSON.Object _ ->
      map.value.mapItems((key, val) -> {
        !key = key.stripPrefix("@");
        lit = val match {
        | JSON.Null() -> SKDB.VNull()
        | JSON.IntNumber(v) -> SKDB.VInt(v)
        | JSON.Bool(v) -> if (v) SKDB.VInt(1) else SKDB.VInt(0)
        | JSON.FloatNumber(v) -> SKDB.VFloat(v)
        | JSON.String(v) -> SKDB.VString(v)
        | JSON.Array _
        | JSON.Object _ ->
          print_error(
            "Value " +
              val +
              " of statement parameter" +
              key +
              " expected to be a literal value",
          );
          skipExit(2)
        };
        (key, lit)
      })
    | _ ->
      print_error("Expected an encoded JSON Object, got: " + encoded_params);
      skipExit(2)
    }
  } catch {
  | exn ->
    print_error(
      "Decoding JSON failed: \"" + encoded_params + "\"\n" + exn.getMessage(),
    );
    skipExit(2)
  }
}

fun decodeDiffSpec(input: String): Map<Name, SKStore.Tick> {
  try {
    JSON.decode(input) match {
    | map @ JSON.Object _ ->
      map.value.mapItems((key, val) -> {
        val match {
        | obj @ JSON.Object _ ->
          (Name::create(key), SKStore.Tick(obj.getInt("since")))
        | _ ->
          print_error("Expected an object");
          skipExit(2)
        };
      })
    | _ ->
      print_error("Expected an encoded JSON Object, got: " + input);
      skipExit(2)
    }
  } catch {
  | exn ->
    print_error("Decoding JSON failed: \"" + input + "\"\n" + exn.getMessage());
    skipExit(2)
  }
}

fun computeTableDescr(name: Name, schema: Array<ColumnDefinition>): DirDescr {
  dirNameStr = "/" + name + "/";
  dirName = SKStore.DirName::create(dirNameStr);
  colVec = mutable Vector[];
  for (i in Range(0, schema.size())) {
    colVec.push((schema[i].name, i));
  };
  DirDescr::create{name, schema, dirName, alias => None(), isInput => true}
}

fun computeInsert(
  context: mutable SKStore.Context,
  params: Map<String, Value>,
  inTransaction: Bool,
  pos: Int,
  columnParamsOpt: ?Array<Name>,
  valuesArray: Array<Array<Expr>>,
  table: DirDescr,
  repeat: Int = 1,
): Array<RowValues> {
  valuesArray.map(vals -> {
    values = vals.mapWithIndex((idx, expr) -> {
      val = expr match {
      | x @ Value _ -> x
      | _ -> error(pos, "Arbitrary expressions not supported for INSERT")
      };
      schemaIdx = columnParamsOpt match {
      | None() -> idx
      | Some(columnParams) ->
        colName = columnParams.maybeGet(idx) match {
        | None() -> error(pos, "Value size mismatch with specified columns")
        | Some(param) -> param
        };
        table.cols.maybeGet(colName) match {
        | None() -> error(pos, "Column not found: " + colName)
        | Some(colIdx) -> colIdx
        }
      };
      valueToCValue(
        context,
        params,
        inTransaction,
        pos,
        table.schema,
        schemaIdx,
        val,
      )
    });
    schema = table.schema;
    schemaSize = schema.size();
    valueSize = values.size();
    cvalues = columnParamsOpt match {
    | None() ->
      if (valueSize != schemaSize) {
        error(pos, "Value size mismatch with table schema");
      };
      values
    | Some(columnParams) ->
      missingCols = mutable Map[];
      for (col in schema) {
        missingCols![col.name] = col;
      };
      for (userDefinedCol in columnParams) {
        if (!missingCols.containsKey(userDefinedCol)) {
          error(pos, "Column not found: " + userDefinedCol);
        };
        missingCols.remove(userDefinedCol);
      };

      result = Array<?CValue>::mfill(schema.size(), None());

      for (i => colName in columnParams) {
        result![table.cols[colName]] = values[i];
      };

      for (tyDescr in missingCols) {
        value = tyDescr.default match {
        | None() ->
          if (tyDescr.primary is Some _) {
            if (tyDescr.ty is TEXT()) {
              Some(CString(Ksuid::create().toString()))
            } else {
              Some(CInt(SKStore.genSym(0)))
            };
          } else {
            error(pos, "Missing value for column: " + tyDescr.name);
          }
        | Some(CCDefault{expr}) ->
          expr match {
          | VNull() -> None()
          | VInt(n) -> Some(CInt(n))
          | VFloat(f) -> Some(CFloat(f))
          | VString(x) -> Some(CString(x))
          | _ -> error(pos, "Invalid expression for default value")
          }
        };
        result![table.cols[tyDescr.name]] = value;
      };

      unsafe_chill_trust_me(result)
    };
    result = RowValues::create(cvalues);
    if (repeat != 1) {
      !result = result.setRepeat(repeat);
    };
    result
  })
}

fun valueToCValue(
  context: mutable SKStore.Context,
  params: Map<String, Value>,
  inTransaction: Bool,
  pos: Int,
  schema: Array<ColumnDefinition>,
  idx: Int,
  val: Value,
): ?CValue {
  if (idx >= schema.size()) {
    error(pos, "Too many columns defined");
  };
  !val = val match {
  | VParam(handle) ->
    params.maybeGet(handle) match {
    | Some(v) -> v
    | None() -> error(pos, "Unbound parameter: " + handle)
    }
  | VPermission(arg) ->
    perm_str = arg match {
    | VParam(handle) ->
      params.maybeGet(handle) match {
      | Some(VString(str)) -> str
      | Some(_) -> error(pos, "Argument to skdb_permission must be a string")
      | None() -> error(pos, "Unbound parameter: " + handle)
      }
    | VString(str) -> str
    | _ -> error(pos, "Argument to skdb_permission must be a string")
    };
    VInt(compilePermissionLiteral(perm_str))
  | _ -> val
  };
  if (val is VNull _) {
    if (schema[idx].notNull is Some _) {
      error(pos, "cannot insert NULL in column declared as NOT NULL")
    } else {
      return (None() : ?CValue)
    }
  };
  schema[idx].ty match {
  | INTEGER() ->
    val match {
    | VSeqNum(isPositive, Some(varName)) ->
      if (!inTransaction) {
        error(pos, "named id can only be used in a transaction");
      };
      globals = context.getGlobal(GLOBALS) match {
      | None() -> Globals()
      | Some(file) -> Globals::type(file)
      };
      globals.maybeGet(varName) match {
      | None() ->
        id = SKStore.genSym(0);
        if (!isPositive) !id = -id;
        !globals = globals.set(varName, id);
        context.setGlobal(GLOBALS, globals);
        Some(CInt(id))
      | Some(id) -> Some(CInt(id))
      }
    | VSeqNum(isPositive, None()) ->
      if (isPositive) {
        Some(CInt(SKStore.genSym(0)))
      } else {
        Some(CInt(-SKStore.genSym(0)))
      }
    | VTime() ->
      if (inTransaction) {
        error(pos, "time can not be used in a transaction");
      };
      time = getUnixTime();
      Some(CInt(time))
    | VInt(n) ->
      if (schema[idx].primary is Some _) {
        _ = SKStore.genSym(Math.abs(n));
      };
      Some(CInt(n))
    | v ->
      error(
        pos,
        "Type mismatch on column " +
          (idx + 1) +
          " expected type INTEGER (found " +
          inspect(v).toString() +
          ")",
      )
    }
  | FLOAT() ->
    val match {
    | VFloat(f) -> Some(CFloat(f))
    | VInt(i) -> Some(CFloat(i.toFloat()))
    | v ->
      error(
        pos,
        "Type mismatch on column " +
          (idx + 1) +
          " expected type FLOAT (found " +
          inspect(v).toString() +
          ")",
      )
    }
  | TEXT() ->
    val match {
    | VId(Some(varName)) ->
      if (!inTransaction) {
        error(pos, "named id can only be used in a transaction");
      };
      namedIDs = context.getGlobal(NAMEDIDS) match {
      | None() -> NamedIDs()
      | Some(file) -> NamedIDs::type(file)
      };
      namedIDs.maybeGet(varName) match {
      | None() ->
        id = Ksuid::create().toString();
        !namedIDs = namedIDs.set(varName, id);
        context.setGlobal(NAMEDIDS, namedIDs);
        Some(CString(id))
      | Some(id) -> Some(CString(id))
      }
    | VId(None()) -> Some(CString(Ksuid::create().toString()))
    | VString(str) -> Some(CString(str))
    | v ->
      error(
        pos,
        "Type mismatch on column " +
          (idx + 1) +
          " expected type STRING (found " +
          inspect(v).toString() +
          ")",
      )
    }
  }
}

fun computeKinds(
  params: Array<CGExpr>,
  ekinds: Array<(Int, IKind)>,
): Array<(Int, IKind, Type)> {
  size = params.size();
  paramTypes = params.map(x -> x.getType());
  colSet = mutable Set[];
  ikinds = ekinds.map(eik -> {
    (colNumber, kind) = eik;
    !colNumber = colNumber - 1;
    if (colNumber < 0 || colNumber >= size) {
      errorEval("ORDER BY out of bounds");
    };
    if (colSet.contains(colNumber)) {
      errorEval("invalid ORDER by");
    };
    colSet.add(colNumber);
    (colNumber, kind)
  });
  computeOrder(paramTypes, ikinds)
}

fun computeOrder(
  paramTypes: Array<Type>,
  ikinds: Array<(Int, IKind)>,
): Array<(Int, IKind, Type)> {
  size = paramTypes.size();
  defaultKinds = Array<?(Int, SKDB.IKind, SKDB.Type)>::mfillBy(size, i ->
    Some((i, (INONE() : IKind), paramTypes[i]))
  );
  kinds = mutable Vector[];
  for (ik in ikinds) {
    (colNumber, kind) = ik;
    defaultKinds![colNumber] = None();
    kinds.push((colNumber, kind, paramTypes[colNumber]))
  };
  for (defaultKind in defaultKinds) {
    defaultKind match {
    | None() -> void
    | Some(k) -> kinds.push(k)
    }
  };
  kinds.toArray()
}

class SelectFile(
  tick: Int,
  name: Name,
  virtual: Bool,
  text: String,
  sparams: Array<SelectResult>,
  cselect: CSelect,
) extends SKStore.File

class Evaluator{options: Options, user: ?UserFile} {
  fun write(
    context: mutable SKStore.Context,
    dirName: SKStore.DirName,
    key: SKStore.Key,
    value: SKStore.File,
  ): void {
    context.getEagerDir(dirName).write(context, key, value);
  }

  fun writeArray(
    context: mutable SKStore.Context,
    dirName: SKStore.DirName,
    key: SKStore.Key,
    values: Array<SKStore.File>,
  ): void {
    context.getEagerDir(dirName).writeArray(context, key, values);
  }

  fun stmt(
    context: mutable SKStore.Context,
    params: Map<String, Value>,
    stmt: Stmt,
    inTransaction: Bool,
  ): ?((
    mutable SKStore.Context,
    mutable SKStore.Context,
    SKStore.Context,
  ) ~> void) {
    stmt match {
    | Pragma _ -> invariant_violation("PRAGMA should be handled at top level")
    | BeginTransaction _
    | EndTransaction _ ->
      invariant_violation(
        "BEGIN/END TRANSACTION should be handled at top level",
      )
    | CreateTableSchema{pos, name, schema, ifNotExists} ->
      if (inTransaction) {
        error(pos, "Cannot create a table in a transaction");
      };
      Some((context, _, _) ~> {
        dirDescr = computeTableDescr(name, schema.columns);
        this.createTable(context, pos, name, dirDescr, ifNotExists);
      })
    | CreateTableAs _ ->
      invariant_violation("CREATE TABLE AS SELECT not implemented")
    | Insert{pos, onConflict, name, alias, paramsOpt, values} ->
      if (alias is Some _) {
        error(pos, "INSERT INTO table AS not implemented")
      };
      baseName = SKStore.SID::create(name.lower);
      getTableDir(context).maybeGet(context, baseName) match {
      | None() -> error(pos, "Table not found: " + name)
      | Some(dirDescr) if (dirDescr.view) ->
        error(pos, "Cannot write in view: " + name)
      | _ -> void
      };
      if (!(getViewsDir(context).maybeGet(context, baseName) is None())) {
        error(pos, "Cannot write in view: " + name);
      };
      values match {
      | IDefault() -> error(pos, "DEFAULT VALUES not implemented")
      | IQuery(selectAst @ Select _) ->
        if (onConflict is Some _) {
          error(pos, "Can only use OR IGNORE/REPLACE with values");
        };
        compiler = SKDB.Compiler::create(
          false,
          this.options,
          selectAst.pos,
          params,
        );
        select = compiler.compileSelect(
          context,
          selectAst,
          Name::create(
            genSelectId(selectAst).origName + "_" + SKStore.genSym(0),
          ),
          true,
        );
        selectDir = evalSelect(context, select, None());
        updateTableMap(context);
        table = getTable(context, pos, name);
        dir = getDir(table);
        sinkName = "/sinks/sink" + SKStore.genSym(0) + "/";
        sinkDirName = SKStore.DirName::create(sinkName);
        kinds = table.schema.mapWithIndex((idx, x) -> (idx, IASC(), x.ty));
        if (select.params.size() != kinds.size()) {
          error(pos, "Incompatible select size")
        };
        for (i => param in select.params) {
          (kinds[i].i2, param.getType()) match {
          | (INTEGER(), INTEGER())
          | (FLOAT(), FLOAT())
          | (TEXT(), TEXT()) ->
            void
          | _ -> error(pos, "Incompatible select type")
          }
        };
        _ = SKStore.EagerDir::apply(
          context,
          selectDir.dirName,
          sinkDirName,
          (context, _writer, key, valueIter) ~> {
            src = SKStore.Path::create(selectDir.dirName, key);
            entries = Vector[(key, (src, src, valueIter.collect(Array)))];
            inputDir = context.unsafeGetEagerDir(dir.dirName);
            inputDir.writeArraySourceMany(context, entries.iterator());
          },
        );
        None()

      | IValues(vals) ->
        table = getTable(context, pos, name);
        this.insert(
          context,
          params,
          pos,
          onConflict,
          inTransaction,
          table,
          paramsOpt,
          vals,
        )
      }
    | selectAst @ Select{} ->
      compiler = SKDB.Compiler::create(
        !inTransaction,
        this.options,
        selectAst.pos,
        params,
      );
      select = compiler.compileSelect(
        context,
        selectAst,
        genSelectId(selectAst),
        true,
      );
      selectDir = evalSelect(context, select, None());
      stdout = context.getGlobal("Stdout") match {
      | Some(StdoutFile(_, l)) -> l
      | Some(_) -> invariant_violation("Wrong type for global stdout")
      | None() -> List[]
      };
      !stdout = List.Cons(selectDir, stdout);
      context.setGlobal("Stdout", StdoutFile(select.format, stdout));
      None()

    | index @ CreateIndex{pos, where} ->
      if (where is Some _) {
        error(pos, "INDEX ... WHERE not implemented")
      };
      Some((context, _, _) ~> {
        this.makeIndex(context, index);
        context.update()
      })
    | CreateView{
      pos,
      name => viewName,
      ifNotExists,
      query => selectAst @ Select _,
      virtual,
      text,
    } ->
      if (inTransaction) {
        error(pos, "Cannot create a view in a transaction");
      };
      views = getViewsDir(context);
      viewsDir = context.unsafeGetEagerDir(views.dirName);
      key = SKStore.SID(viewName.lower);
      if (viewsDir.getArrayRaw(key).size() != 0) {
        if (ifNotExists) return None();
        error(pos, "VIEW " + viewName + " already exists");
      } else {
        tables = getTableDir(context);
        tablesDir = context.unsafeGetEagerDir(tables.dirName);
        if (tablesDir.getArrayRaw(key).size() != 0) {
          error(pos, "Table " + viewName + " exists");
        };
      };
      cselect1 = SKDB.Compiler::create(
        false,
        this.options with {virtual => true},
        selectAst.pos,
        params,
      ).compileSelect(context, selectAst, viewName, true);
      viewsDir.write(
        context,
        key,
        SelectFile(
          context.tick.value,
          viewName,
          virtual,
          text,
          selectAst.params,
          cselect1,
        ),
      );
      if (virtual) {
        if (inTransaction) {
          error(pos, "Cannot create a virtual view in a transaction");
        };
        startTick = context.tick;
        // This phase just populates the data.
        _ = SKDB.evalSelect(context, cselect1, None());
        Some((context, delta, _) ~> {
          sameDeps = unsafeCompareSets(context.deps.data, delta.deps.data);
          // If the deps haven't changed, that means we can reuse
          // the pre-computed data.
          if (sameDeps != 0) {
            changedDirNames = delta.dirs.state.getChangesAfter(startTick);
            for (changedDirName in changedDirNames) {
              if (!context.dirs.state.containsKey(changedDirName)) {
                context.setGlobal(
                  "PRE_COMPUTED_" + changedDirName,
                  delta.unsafeGetDir(changedDirName),
                );
              }
            }
          };
          compiler = SKDB.Compiler::create(
            false,
            this.options with {virtual => true},
            selectAst.pos,
            params,
          );
          cselect = compiler.compileSelect(context, selectAst, viewName, true);
          dirName = SKStore.DirName::create("/" + viewName + "/");
          dirDescr = SKDB.Compiler::getDirDescr(
            selectAst.params,
            cselect.from,
            cselect.params,
            cselect.id,
            dirName,
            true,
          );
          _selectDir = SKDB.evalSelect(context, cselect, None());
          tableDir = getTableDir(context);
          fileName = SKStore.SID::create(viewName.lower);
          tableDir.writeArray(context, fileName, Array[dirDescr]);
        })
      } else {
        None()
      }
    | DropView{pos, name => viewName, ifExists} ->
      if (ifExists) {
        error(pos, "DROP VIEW IF EXISTS not implemented")
      };
      if (inTransaction) {
        error(pos, "Cannot drop a view in a transaction");
      };
      Some((context, _, _) ~> {
        views = getViewsDir(context);
        viewsDir = context.unsafeGetEagerDir(views.dirName);
        key = SKStore.SID(viewName.lower);
        files = viewsDir.getArrayRaw(key);
        if (files.size() == 0) {
          error(pos, "VIEW " + viewName + " does not exist");
        };
        selectFile = SelectFile::type(files[0]);
        if (selectFile.virtual) {
          error(pos, "Cannot drop a virtual view");
        } else {
          viewsDir.writeArray(context, key, Array[]);
        }
      })

    | DropIndex{pos} -> error(pos, "Drop index not supported")
    | DropTable{pos, name, ifExists} ->
      if (ifExists) {
        error(pos, "DROP TABLE IF EXISTS not implemented")
      };
      Some((context, _, _) ~> {
        dirNameStr = "/" + name + "/";
        dirName = SKStore.DirName::create(dirNameStr);
        context.removeDir(dirName);
        context.setDir(
          dirName,
          SKStore.DeletedDir{dirName, time => context.timeStamp()},
        );
        errorAllExistingSubs(context, dirName)
      })
    | Delete{pos, name, where, alias, indexed} ->
      if (alias is Some _) {
        error(pos, "DELETE FROM table AS not implemented")
      };
      if (indexed is Some _) {
        error(pos, "DELETE FROM table INDEXED BY not implemented")
      };
      _ = this.delete(context, params, pos, name, where, Array[]);
      None()

    | Update{pos, name, alias, indexed, sets, where, onConflict} ->
      if (alias is Some _) {
        error(pos, "UPDATE table AS alias not implemented")
      };
      if (indexed is Some _) {
        error(pos, "UPDATE table INDEXED BY not implemented")
      };
      if (onConflict is Some _) {
        error(pos, "UPDATE OR not implemented")
      };
      baseName = SKStore.SID::create(name.lower);
      if (getTableDir(context).maybeGet(context, baseName) is None()) {
        error(pos, "Table not found: " + name.origName);
      };
      deleteDir = this.delete(context, params, pos, name, where, sets);
      updateTableMap(context);
      table = getTable(context, pos, name);
      dir = getDir(table);
      sinkName = "/sinks/sink" + SKStore.genSym(0) + "/";
      sinkDirName = SKStore.DirName::create(sinkName);
      _ = SKStore.EagerDir::apply(
        context,
        deleteDir,
        sinkDirName,
        (context, _writer, key, valueIter) ~> {
          src = SKStore.Path::create(deleteDir, key);
          entries = Vector[(key, (src, src, valueIter.collect(Array)))];
          inputDir = context.unsafeGetEagerDir(dir.dirName);
          inputDir.writeArraySourceMany(context, entries.iterator());
        },
      );
      None()
    };
  }

  fun makeIndex(context: mutable SKStore.Context, index: CreateIndex): void {
    input = getIndexInputDir(context);
    key = SKStore.SID::create(index.name.lower);
    size = (context.unsafeGetEagerDir(input.dirName)).getArrayRaw(key).size();
    if (size != 0) {
      if (index.ifNotExists) {
        return void;
      };
      error(index.pos, "INDEX " + index.name.origName + " already exists");
    };
    this.write(context, input.dirName, key, index);
    _ = getIndexOutputDir(context);
  }

  fun delete(
    context: mutable SKStore.Context,
    params: Map<String, Value>,
    pos: Int,
    name: Name,
    where: ?Expr,
    sets: Array<UpdateSet>,
  ): SKStore.DirName {
    sinkName = "/sinks/sink" + SKStore.genSym(0) + "/";
    sinkDirName = SKStore.DirName::create(sinkName);
    from = Some(Array[TableName(FName(name), None(), false)]);
    selectAst = Select{
      pos => pos,
      params => Array[SelectStar(None())],
      from,
      where,
      groupBy => None(),
      having => None(),
      join => None(),
      distinct => false,
      limit => None(),
      orderBy => None(),
      rest => Array[],
    };
    compiler = SKDB.Compiler::create(
      false,
      this.options,
      selectAst.pos,
      params,
    );
    select = compiler.compileSelect(
      context,
      selectAst,
      Name::create("SELECT_" + SKStore.genSym(pos)),
      true,
      sets,
    );
    selectHandle = evalSelect(context, select, None());
    selectDir = context.unsafeGetEagerDir(selectHandle.dirName);
    updateTableMap(context);
    table = getTable(context, pos, name);
    inputDir = getDir(table);
    SKStore.EagerDir::apply(
      context,
      selectDir.dirName,
      sinkDirName,
      (context, writer, key, rowIter) ~> {
        entries = mutable Vector[];
        dir = context.unsafeGetEagerDir(inputDir.dirName);
        writerPath = SKStore.Path(
          selectDir.dirName,
          SKStore.IID(SKStore.genSym(0)),
        );
        for ((_, source, _) in dir.getDataIterWithoutTombs(context, key)) {
          entries.push(
            (key, (source.path(), writerPath, Array<SKStore.File>[])),
          );
        };
        dir.writeArraySourceMany(context, entries.iterator());
        if (select.sets.isEmpty()) return void;

        row = rowIter.next() match {
        | None() -> return void
        | Some(x @ RowValues _) -> x
        | Some(_) -> invariant_violation("Unexpected row type")
        };

        repeat = row.repeat;

        for (ir in rowIter) {
          ir match {
          | RowValues(_, r) -> !repeat = repeat + r
          | _ -> invariant_violation("Unexpected Row type")
          }
        };

        if (repeat != row.repeat) {
          !row = row.setRepeat(repeat);
        };

        evaluator = ExprEvaluator(Array[row], Array[], None());

        values = Array::mcreateFromItems(row.values);

        for (set in select.sets) {
          (idx, e) = set;
          values![idx] = evaluator.evalCGExpr(context, e) match {
          | ADef(x) -> Some(x)
          | ANull() -> None()
          | AUndef _ -> invariant_violation("Undefined set value")
          };
        };
        !row = RowValues::create(values.chill(), row.repeat);
        kinds = key match {
        | RowKey(_, kinds) -> kinds
        | _ -> invariant_violation("Unexpected row kind")
        };

        writer.set(RowKey(row, kinds), row);
      },
    );
    sinkDir = context.unsafeGetEagerDir(sinkDirName);
    !sinkDir.time.value = Int::max - sinkDir.time.value;
    context.setDir(sinkDir.dirName, sinkDir);
    updateTableMap(context);
    sinkDirName
  }

  fun insert(
    context: mutable SKStore.Context,
    params: Map<String, Value>,
    pos: Int,
    onConflict: ?OnConflict,
    inTransaction: Bool,
    table: DirDescr,
    paramsOpt: ?Array<Name>,
    values: Array<Array<Expr>>,
  ): ?((
    mutable SKStore.Context,
    mutable SKStore.Context,
    SKStore.Context,
  ) ~> void) {
    rows = computeInsert(
      context,
      params,
      inTransaction,
      pos,
      paramsOpt,
      values,
      table,
    );
    if (inTransaction && onConflict is Some(OCIgnore())) {
      error(pos, "OR IGNORE not supported in transactions")
    } else if (inTransaction && onConflict is Some(OCReplace())) {
      error(pos, "OR REPLACE not supported in transactions")
    } else if (inTransaction) {
      this.insertTable(context, table, rows);
      None()
    } else if (onConflict is Some(OCUpdate(_))) {
      onConflict match {
      | Some(OCUpdate(update)) ->
        copy = context.clone();
        hasConflict = try {
          this.insertTable(context, table, rows);
          context.update();
          false
        } catch {
        | Conflict _ ->
          context.replaceFromSaved(copy);
          true
        | exn -> throw exn
        };
        if (hasConflict) {
          this.stmt(context, params, update, false)
        } else {
          None()
        }
      | _ -> None()
      }
    } else {
      Some((context, _, _) ~> {
        if (onConflict is Some(OCIgnore())) {
          copy = context.clone();
          try {
            this.insertTable(context, table, rows);
            context.update();
          } catch {
          | Conflict _ -> context.replaceFromSaved(copy)
          | exn -> throw exn
          }
        } else if (onConflict is Some(OCReplace())) {
          loop {
            copy = context.clone();
            shouldContinue = try {
              this.insertTable(context, table, rows);
              context.update();
              false
            } catch {
            | Conflict(_pos, _msg, conflictingValues) ->
              context.replaceFromSaved(copy);
              where: ?Expr = None();
              for (idxValue in conflictingValues) {
                (idx, conValue) = idxValue;
                tyDescr = table.schema[idx];
                clause = BinOp(
                  OEq(),
                  Identifier(tyDescr.name),
                  conValue match {
                  | None() -> VNull()
                  | Some(CInt(n)) -> VInt(n)
                  | Some(CString(s)) -> VString(s)
                  | _ -> error(pos, "Unsupported type for OR IGNORE/REPLACE")
                  },
                );
                !where = where match {
                | None() -> Some(clause)
                | Some(w) -> Some(BinOp(OAnd(), w, clause))
                }
              };
              tick = context.tick;
              _ = this.delete(context, params, pos, table.name, where, Array[]);
              _ = importNext(context, tick, context);
              true
            | exn -> throw exn
            };
            if (!shouldContinue) break void
          }
        } else {
          this.insertTable(context, table, rows);
          context.update();
        }
      })
    }
  }

  fun insertTable(
    context: mutable SKStore.Context,
    table: DirDescr,
    rows: Array<RowValues>,
  ): void {
    dir = getDir(table);
    newDir = context.unsafeGetEagerDir(dir.dirName);
    kinds = table.schema.mapWithIndex((idx, x) -> (idx, IASC(), x.ty));
    for (row in rows) {
      key = RowKey(row, kinds);
      source = SKStore.Path(dir.dirName, SKStore.IID(SKStore.genSym(0)));
      !newDir = newDir.writeEntry(context, source, source, key, Array[row]);
    };
    context.setDir(newDir.dirName, newDir);
  }

  fun createTable(
    context: mutable SKStore.Context,
    pos: Int,
    name: Name,
    dirDescr: DirDescr,
    ifNotExists: Bool,
  ): void {
    dirName = dirDescr.dirName;
    if (context.unsafeMaybeGetEagerDir(dirName) is Some _ && ifNotExists) {
      return void;
    };

    _ = context.mkdir(x ~> x, RowValues::type, dirName);

    getTableDir(context).writeArray(
      context,
      SKStore.SID::create(name.lower),
      Array[dirDescr],
    );

    hasPrimary = false;

    for (tyDescr in dirDescr.schema) {
      if (tyDescr.primary is Some _) {
        if (hasPrimary) {
          error(pos, "multiple primary keys detected");
        };
        if (!(tyDescr.ty is INTEGER()) && !(tyDescr.ty is TEXT())) {
          error(pos, "primary keys are expected to be integers or strings");
        };
        !hasPrimary = true;
      };
      if (tyDescr.unique is Some _ || tyDescr.primary is Some _) {
        this.makeIndex(
          context,
          CreateIndex{
            pos => pos,
            ifNotExists => false,
            name => Name::create(name.origName + "_" + tyDescr.name.origName),
            on => name,
            columns => Array[
              IndexedColumn{
                expr => Identifier(tyDescr.name),
                order => IASC(),
                collate => None(),
              },
            ],
            unique => true,
            where => None(),
            text => None(),
          },
        );
      }
    };

    if (context.debugMode) {
      print_string("CREATED: " + name.origName);
    };
  }
}

@cpp_extern("SKIP_String_concatN")
native fun concatArray(Array<String>): String;

@cpp_extern("SKIP_isatty")
native fun isATTY(): UInt32;

@cpp_extern("SKIP_unsafe_compare_sets")
native fun unsafeCompareSets(
  SortedMap<SKStore.Path, SortedSet<SKStore.ArrowKey>>,
  SortedMap<SKStore.Path, SortedSet<SKStore.ArrowKey>>,
): Int32;

fun read(line: Int): (Int, String) {
  i = 0;
  chars = mutable Vector[];
  try {
    loop {
      c = getChar();
      !i = i + 1;

      if (c == '\'') {
        chars.push(c);
        loop {
          c2 = getChar();
          chars.push(c2);
          if (c2 == '\'') break void;
        };
        continue;
      };

      if (c == '-') {
        c2 = getChar();
        !i = i + 1;
        if (c2 == '-') {
          while (getChar() != '\n') {
            !i = i + 1;
          };
          continue
        } else {
          chars.push(c);
          chars.push(c2);
        }
      } else if (c == '/') {
        c2 = getChar();
        !i = i + 1;
        if (c2 == '*') {
          last = getChar();
          !i = i + 1;
          loop {
            c3 = getChar();
            !i = i + 1;
            if (last == '*' && c3 == '/') break void;
            !last = c3;
          };
          continue
        } else {
          chars.push(c);
          chars.push(c2);
        }
      } else {
        chars.push(c);
      };

      if (c == '\n') !line = line + 1;
      if (c == ';') break (line, String::fromChars(chars.toArray()));
    }
  } catch {
  | _endOfFile -> (line, String::fromChars(chars.toArray()))
  }
}

fun getLine(buffer: Buffer, pos: Int): Int {
  line = 1;
  for (i in Range(0, pos)) {
    if (buffer[i] == '\n') {
      !line = line + 1;
    }
  };
  line
}

fun printErrorAndExit(
  lineOffset: Int,
  buffer: Buffer,
  pos: Int,
  msg: String,
): void {
  leftSpaces = 0;
  cursor = 0;
  line = 0;
  !pos = min(buffer.size() - 1, pos);
  while (pos - cursor > 0) {
    if (buffer[pos - cursor] == '\n') {
      !line = line + 1;
      if (line == 1) {
        !leftSpaces = cursor;
      };
      if (line == 5) break void;
    };
    !cursor = cursor + 1
  };
  if (pos - leftSpaces < 0) {
    !leftSpaces = pos;
  };
  right = 0;
  while (pos + right < buffer.size() && buffer[pos + right] != '\n') {
    !right = right + 1
  };
  txtBegin = max(0, pos - cursor);
  txtEnd = min(buffer.size(), pos + right);
  print_error(buffer.slice(txtBegin, txtEnd));
  spaceBuffer = mutable Vector[];
  for (_ in Range(0, leftSpaces - 1)) spaceBuffer.push(' ');
  margin = String::fromChars(spaceBuffer.toArray());
  print_error(margin + "^");
  print_error(margin + "|");
  print_error(margin + " ----- ERROR");
  errLine = lineOffset + getLine(buffer, pos);
  charPos = `characters ${leftSpaces}-${leftSpaces}`;
  print_error(`Error: line ${errLine}, ${charPos}:`);
  print_error(msg);
  skipExit(2)
}

fun evalWithContext(
  options: Options,
  context: mutable SKStore.Context,
  params: Map<String, Value>,
  stmt: Stmt,
  inTransaction: Bool,
): ?((
  mutable SKStore.Context,
  mutable SKStore.Context,
  SKStore.Context,
) ~> void) {
  user = context.getGlobal("USER").map(UserFile::type);
  evaluator = Evaluator{options, user};
  evaluator.stmt(context, params, stmt, inTransaction);
}

fun makeSqlContext(): mutable SKStore.Context {
  gcontext = mutable SKStore.Context{
    canReuse => SKStore.CRAlways(),
    failOnExn => true,
    removeSubDirs => true,
  };
  gcontext.setGlobal("Line", SKStore.IntFile(0));
  gcontext
}

fun doOnError(options: Options, f: () -> void, error: Exception -> void): void {
  if (options.backtrace) f() else {
    try {
      f()
    } catch {
    | exn -> error(exn)
    }
  }
}

class StmtFile(stmt: Stmt) extends SKStore.File
class TickFile(tick: SKStore.Tick) extends SKStore.File

base class OutputFormatKind {
  children =
  | OFK_CSV()
  | OFK_JSON()
  | OFK_SQL()
  | OFK_JS()
  | OFK_Table()
}

class Options{
  alwaysAllowJoins: Bool,
  backtrace: Bool,
  sync: Bool,
  virtual: Bool = false,
  showUsedIndexes: Bool,
  format: OutputFormatKind = OFK_SQL(),
  expectQueryParams: Bool = false,
} extends SKStore.File

fun eval(options: Options, params: Map<String, Value>, userOpt: ?String): void {
  isTTY = isATTY() != 0;
  runSql(options, context ~> {
    if (isTTY) {
      print_raw("skdb> ");
    };
    lineFile = SKStore.IntFile::type(context.getGlobal("Line").fromSome());
    context.!globals = SortedMap[];
    userOpt.each(_ -> {
      print_error("Cannot execute queries as user, use --connect instead");
      skipExit(88);
    });
    context.setGlobal("Line", lineFile);
    context.removeGlobal("TableMap");

    gline = lineFile.value;

    line = 0;
    lineStr = "";
    buffer = Buffer(lineStr);
    lex = Lexer(0, buffer);
    pos = 0;
    shouldContinue = false;
    underLockF: ?((
      mutable SKStore.Context,
      mutable SKStore.Context,
      SKStore.Context,
    ) ~> void) = None();

    doOnError(
      options,
      () -> {
        !shouldContinue = true;
        isTransaction = false;

        loop {
          !underLockF = None();
          (!line, !lineStr) = read(gline);
          !buffer = Buffer(lineStr);
          !lex = Lexer(0, buffer);
          !pos = 0;

          if (isEOF(lex, pos)) {
            !shouldContinue = false;
            if (isTransaction) {
              printErrorAndExit(line, buffer, pos, "Unfinished transaction");
            };
            return void;
          };

          if (lex.isEqUpper(pos, "BEGIN")) {
            !pos = lex.expectUpper(pos, "BEGIN");
            !pos = lex.expectUpper(pos, "TRANSACTION");
            !pos = lex.expect(pos, ";");

            if (isTransaction) {
              printErrorAndExit(line, buffer, pos, "Nested transaction");
            };
            !isTransaction = true;
            continue;
          };

          if (lex.isEqUpper(pos, "COMMIT")) {
            !pos = lex.expectUpper(pos, "COMMIT");
            !pos = lex.expect(pos, ";");
            context.getGlobal(GLOBALS) match {
            | None() -> void
            | Some(_) -> context.removeGlobal(GLOBALS)
            };
            context.getGlobal(NAMEDIDS) match {
            | None() -> void
            | Some(_) -> context.removeGlobal(NAMEDIDS)
            };
            break void;
          };

          (!pos, stmtOpt) = parseStmt(lex, pos);
          stmt = stmtOpt match {
          | None() -> break void
          | Some(x) -> x
          };
          markIfRead(context, stmt);

          !underLockF = evalWithContext(
            options,
            context,
            params,
            stmt,
            isTransaction,
          );

          if (!isTransaction) break void;
        };
      },
      err -> {
        err match {
        | IgnoreAndContinue() -> void
        | Error(posError, str) ->
          printErrorAndExit(gline, buffer, posError, str)
        | exn ->
          print_error(exn.getMessage());
          skipExit(44)
        }
      },
    );

    !gline = line;
    context.setGlobal("Line", SKStore.IntFile(gline));

    if (shouldContinue) {
      SKStore.CContinue(underLockF)
    } else {
      SKStore.CStop(underLockF)
    }
  })
}

fun slurpStmts(options: Options): Array<Stmt> {
  line = 0;
  lineStr = "";
  buffer = Buffer(lineStr);
  lex = Lexer(0, buffer);
  pos = 0;
  stmts = mutable Vector[];

  doOnError(
    options,
    () -> {
      loop {
        (!line, !lineStr) = read(line);
        !buffer = Buffer(lineStr);
        !lex = Lexer(0, buffer);
        !pos = 0;

        if (isEOF(lex, pos)) {
          return void;
        };

        (!pos, stmtOpt) = parseStmt(lex, pos);
        stmt = stmtOpt match {
        | None() -> continue
        | Some(x) -> x
        };
        stmts.push(stmt);
      };
    },
    err -> {
      err match {
      | IgnoreAndContinue() -> void
      | Error(posError, str) -> printErrorAndExit(line, buffer, posError, str)
      | exn ->
        print_error(exn.getMessage());
        skipExit(44)
      }
    },
  );

  stmts.collect(Array)
}

fun runSql(
  options: Options,
  f: mutable SKStore.Context ~> SKStore.ContextOp,
): void {
  SKStore.runWithGc(
    SKDB.makeSqlContext().clone(),
    f,
    Some(SKStore.Synchronizer(importFromRoot, exportToRoot, printContext)),
    options.sync,
  )
}

fun runLockedSql(options: Options, f: mutable SKStore.Context ~> void): void {
  SKStore.runLocked(SKDB.makeSqlContext().clone(), f, options.sync)
}

fun importFromRoot(
  delta: mutable SKStore.Context,
  tick: SKStore.Tick,
  root: readonly SKStore.Context,
): void {
  try {
    shouldImport = delta.getGlobal("TableMap") match {
    | None() ->
      delta.getGlobal("IsRead") match {
      | None() -> false
      | Some(_) -> true
      }
    | Some(_tableMapFile) -> true
    };
    if (shouldImport) {
      SKStore.import(delta, tick, root);
      delta.update();
    }
  } catch {
  | err ->
    line = delta.getGlobal("Line") match {
    | None() -> -1
    | Some(x) -> SKStore.IntFile::type(x).value
    };
    print_error("Error, line " + line + ": " + err.getMessage());
    skipExit(2)
  }
}

fun makeInputDirName(dirName: SKStore.DirName): (SKStore.DirName, Int) {
  dirNameStr = dirName.toString();
  if (dirNameStr.startsWith("/next/")) {
    !dirNameStr = dirNameStr.stripPrefix("/next/");
    iter = dirNameStr.getIter();
    i = 0;
    for (c in iter) {
      if (c == '/') break void;
      !i = i + 1;
    };
    nbr = mutable Vector[];
    for (c in iter) {
      if (c == '/') break void;
      nbr.push(c);
    };
    !dirNameStr = "/" + dirNameStr.sub(dirNameStr.getIter(), i) + "/";
    (
      SKStore.DirName::create(dirNameStr),
      String::fromChars(nbr.toArray()).toInt(),
    )
  } else {
    (dirName, 0)
  }
}

fun importNext(
  targetCtx: mutable SKStore.Context,
  tick: SKStore.Tick,
  sourceCtx: readonly SKStore.Context,
): Bool {
  changedDirNames = sourceCtx.dirs.state.getChangesAfter(tick);
  updates = mutable Map[];
  hasMultipleVersions = false;
  for (dirName in changedDirNames) {
    sourceCtx.unsafeMaybeGetDir(dirName) match {
    | Some(SKStore.DeletedDir{}) -> targetCtx.removeDir(dirName)
    | Some(dir @ SKStore.EagerDir{input => true}) ->
      (targetDirName, version) = makeInputDirName(dirName);
      !hasMultipleVersions = hasMultipleVersions || version != 0;
      updates.maybeGet(targetDirName) match {
      | Some((_, _, _, iversion, _)) if (iversion > version) -> void
      | _ ->
        (isReset, changedKeys) = dir.getChangesAfter(tick);
        targetCtx.unsafeMaybeGetDir(targetDirName) match {
        | None() ->
          time = targetCtx.timeStamp();
          targetDir = SKStore.EagerDir{
            time,
            input => true,
            dirName => targetDirName,
            fixedData => SKStore.FixedDataMap::create(),
            totalSize => 0,
            creator => None(),
          };
          targetCtx.setDir(targetDir.dirName, targetDir)
        | Some(_) -> void
        };
        entries = mutable Vector[];
        for (key in changedKeys) {
          for (srcValue in dir.unsafeGetAllDataIterAfter(tick, key)) {
            (_, source, writer, values) = srcValue;
            entries.push((key, (source.path(), writer.path(), values)));
          }
        };
        updates![targetDirName] = (isReset, changedKeys, dir, version, entries)
      }
    | _ -> void
    }
  };
  for (targetDirName => src in updates) {
    (isReset, changedKeys, dir, _, entries) = src;
    targetCtx.unsafeMaybeGetEagerDir(targetDirName) match {
    | None() -> invariant_violation("Directory should have been created")
    | Some(inputDir) ->
      !inputDir = inputDir.writeArraySourceManyReturnDir(
        targetCtx,
        entries.iterator(),
      );
      if (isReset) {
        writerPath = SKStore.Path(dir.dirName, SKStore.IID(SKStore.genSym(0)));
        !inputDir = inputDir.reset(targetCtx, writerPath, changedKeys);
      };
      targetCtx.setDir(inputDir.dirName, inputDir)
    }
  };
  hasMultipleVersions
}

fun exportToRoot(
  root: mutable SKStore.Context,
  tick: SKStore.Tick,
  delta: readonly SKStore.Context,
): Bool {
  rootCopy = root.clone();
  try {
    hasVersioning = importNext(root, tick, delta);
    root.update();
    hasVersioning
  } catch {
  | err ->
    line = delta.getGlobal("Line") match {
    | None() -> -1
    | Some(x) -> SKStore.IntFile::type(x).value
    };
    root.replaceFromSaved(rootCopy);
    print_error("Error, line " + line + ": " + err.getMessage());
    skipExit(2)
  }
}

fun updateTableMap(context: mutable SKStore.Context): void {
  tableMap = context.getGlobal("TableMap") match {
  | None() ->
    TableMap{
      version => Version(SKStore.genSym(0)),
      startTick => context.tick,
      map => SortedMap[],
    }
  | Some(file) -> TableMap::type(file)
  };
  !tableMap.version.value = SKStore.genSym(tableMap.version.value);
  context.setGlobal("TableMap", tableMap)
}

class StdoutFile(
  format: SKStore.OutputFormat,
  value: List<SelectDir>,
) extends SKStore.File

class StdoutDiff(
  diffSpec: Array<(SKStore.DirSub, SKStore.Tick)>,
) extends SKStore.File

class StdoutCheckpointAck(
  table: String,
  time: SKStore.Tick,
  acks: ?StdoutCheckpointAck,
) extends SKStore.File

const kMaxOutputRowsTable: Int = 1024;

fun showSelect(
  context: mutable SKStore.Context,
  format: SKStore.OutputFormat,
  sdir: SelectDir,
): void {
  dirName = sdir.dirName;
  dir = context.unsafeGetEagerDir(dirName);
  // TODO: Unify handling of the various output formats.
  format match {
  | SKStore.OTable(fieldNames) ->
    data = mutable Vector[];
    trailing = false;
    dir.onFiles(files -> {
      for (kv in files) {
        (_key, rows) = kv;
        rowArray = rows.collect(Array);
        for (row in rowArray) {
          row match {
          | RowValues(values, r) ->
            for (_ in Range(0, r)) {
              if (data.size() > kMaxOutputRowsTable) {
                !trailing = true;
                return void
              };
              data.push(values)
            }
          | _ -> invariant_violation("Invalid row kind")
          };
        };
      }
    });

    printTable(fieldNames, data.toArray(), trailing)

  | _ ->
    RowValues::printHeader(format);
    dir.onFiles(files ~> {
      for (kv in files) {
        (_key, rows) = kv;
        rowArray = rows.collect(Array);
        for (row in rowArray) {
          row match {
          | rvalues @ RowValues(_, r) ->
            for (_ in Range(0, r)) {
              RowValues::printItem(format, rvalues)
            }
          | _ -> invariant_violation("Invalid row kind")
          }
        }
      }
    })
  }
}

fun printConsumeDiffResponse(acks: ?StdoutCheckpointAck): void {
  acks match {
  | None() -> void
  | Some(StdoutCheckpointAck(table, tick, rest)) ->
    print_raw("^" + feedbackTable(table) + "\n");
    print_raw(":" + tick.value.toString() + "\n");
    printConsumeDiffResponse(rest)
  }
}

fun printContext(context: mutable SKStore.Context): void {
  context.globals.maybeGet("Stdout") match {
  | None() -> void
  | Some(StdoutFile(format, stdout)) ->
    for (selectDir in stdout.toArray().reversed()) {
      showSelect(context, format, selectDir)
    }
  | Some(StdoutDiff(spec)) ->
    writer = mutable Debug.BufferedWriter(print_raw, 4096);
    producedAnyOutput = false;
    for ((dirsub, tick) in spec) {
      edir = context.unsafeGetEagerDir(dirsub.dirName);
      (isReset, changes) = edir.getChangesAfter(tick);
      producedOutput = edir.writeDiff(
        context,
        isReset,
        changes,
        writer,
        dirsub.entity,
        dirsub.format,
        dirsub.filter,
        dirsub.getDestinationWatermark(context),
      );
      !producedAnyOutput = producedAnyOutput || producedOutput
    };
    if (producedAnyOutput) {
      writer.write(`:${context.tick.value.toString()}\n`);
      writer.flush()
    }
  | Some _ -> invariant_violation("Unexpected Stdout type")
  };
  context.globals.maybeGet("Ack") match {
  | None() -> void
  | Some(acks @ StdoutCheckpointAck _) -> printConsumeDiffResponse(Some(acks))
  | Some _ -> invariant_violation("Unexpected Ack type")
  };
  flushStdout();
}

fun markIfRead(context: mutable SKStore.Context, stmt: Stmt): void {
  stmt match {
  | Insert{values => IQuery _}
  | Update _
  | Select _ ->
    context.setGlobal("IsRead", SKStore.BoolFile(true))
  | BeginTransaction _
  | EndTransaction _
  | Pragma _
  | CreateTable _
  | CreateView _
  | CreateIndex _
  | DropTable _
  | DropView _
  | DropIndex _
  | Delete _
  | Insert _ ->
    void
  }
}

/*****************************************************************************/
/* Support for reactive queries. */
/*****************************************************************************/

// The directory where we keep track of what directories were created
// for each reactive query. Useful to then later cleanup after ourselves.

class QueryDeps(dirNames: Array<SKStore.DirName>) extends SKStore.File
const queryDepsDirName: SKStore.DirName = SKStore.DirName::create(
  "/queries/deps/",
);

fun getQueryDepsHandle(
  context: mutable SKStore.Context,
): SKStore.EHandle<SKStore.IID, QueryDeps> {
  context.maybeGetDir(queryDepsDirName) match {
  | None() ->
    context.mkdir(
      SKStore.IID::keyType,
      QueryDeps::type,
      queryDepsDirName,
      Array[],
    )
  | Some(dir) ->
    SKStore.EHandle(SKStore.IID::keyType, QueryDeps::type, dir.getDirName())
  };
}

fun printReactiveQueryResult(
  context: mutable SKStore.Context,
  _queryID: Int,
  dirName: SKStore.DirName,
  fieldNames: Array<String>,
): void {
  format = SKStore.OJS(fieldNames);
  RowValues::printHeader(format);
  for (kv in context.unsafeGetEagerDir(dirName).unsafeGetFileIter()) {
    (_, files) = kv;
    for (file in files) {
      row = RowValues::type(file);
      for (_ in Range(0, row.repeat)) {
        RowValues::printItem(format, row);
      }
    }
  }
}

fun printReactiveQueryChanges(
  context: mutable SKStore.Context,
  queryID: Int,
  dirName: SKStore.DirName,
  fieldNames: Array<String>,
): void {
  lastTick = lastTick(UInt32::truncate(queryID));
  tick = SKStore.Tick(lastTick.toInt());
  edir = context.unsafeGetEagerDir(dirName);
  (_, changes) = edir.getChangesAfter(tick);
  if (!changes.isEmpty()) {
    format = SKStore.OJS(fieldNames);
    RowValues::printHeader(format);
    for (key in changes) {
      values = edir.getArrayRaw(key);
      if (values.size() == 0) {
        switchTo(UInt32::truncate(1));
        row = (key as RowKey _).row;
        for (_ in Range(0, row.repeat)) {
          RowValues::printItem(format, row);
        }
      } else {
        switchTo(UInt32::truncate(0));
        for (file in values) {
          row = RowValues::type(file);
          for (_ in Range(0, row.repeat)) {
            RowValues::printItem(format, row);
          }
        }
      }
    };
  };
  printTick(context.tick.next());
}

private fun printTick(tick: SKStore.Tick): void {
  switchTo(UInt32::truncate(2));
  jsClearFieldNames();
  jsPushFieldName("tick");
  jsClearObject();
  jsPushObjectFieldInt32(Int32::truncate(tick.value));
  jsPushObject()
}

@cpp_extern("SKIP_js_user_fun")
native fun jsCallUserFun(queryID32: Int32): void;

@cpp_extern("SKIP_js_mark_query")
native fun jsMarkQuery(
  queryID32: Int32,
  notify: (mutable SKStore.Context) ~> void,
): void;

@wasm_export("SKIP_js_notify_user")
fun notifyUser(notify: (mutable SKStore.Context) ~> void): void {
  saved = SKStore.newObstack();
  try {
    SKStore.runWithGc(SKDB.makeSqlContext().clone(), context ~> {
      notify(context);
      SKStore.CStop(None())
    })
  } catch {
  | exn -> print_error(exn.getMessage())
  };
  SKStore.destroyObstack(saved);
}

@wasm_export("SKIP_reactive_query")
fun reactiveQuery(
  queryID32: Int32,
  query: String,
  encoded_params: String,
): void {
  manageReactiveQuery(
    queryID32,
    query,
    encoded_params,
    printReactiveQueryResult,
  )
}

@wasm_export("SKIP_reactive_query_changes")
fun reactiveQueryChanges(
  queryID32: Int32,
  query: String,
  encoded_params: String,
): void {
  manageReactiveQuery(
    queryID32,
    query,
    encoded_params,
    printReactiveQueryChanges,
  )
}

fun manageReactiveQuery(
  queryID32: Int32,
  query: String,
  encoded_params: String,
  printResult: (
    context: mutable SKStore.Context,
    queryID: Int,
    dirName: SKStore.DirName,
    fieldNames: Array<String>,
  ) ~> void,
): void {
  try {
    SKStore.runWithGc(SKDB.makeSqlContext().clone(), context ~> {
      context.!globals = SortedMap[];
      context.!newDirs = SortedSet[];
      tick = context.tick;
      // We want canReuse set to CRNever, because we want a guarantee
      // that no one will try to reuse our directories for something
      // else. Otherwise we would not be able to remove them safely.
      context.!canReuse = SKStore.CRNever();
      queryID = queryID32.toInt();
      lexer = SKDB.Lexer(0, SKDB.Buffer(query));
      selectAst = SKDB.parseQuery(lexer, 0).i1 match {
      | x @ Select _ -> x
      };
      skOptions = SKDB.Options{
        alwaysAllowJoins => false,
        backtrace => false,
        sync => false,
        virtual => false,
        showUsedIndexes => false,
      };
      params = decodeParams(encoded_params);
      compiler = SKDB.Compiler::create(false, skOptions, 0, params);
      cselect = compiler.compileSelect(
        context,
        selectAst,
        genSelectId(selectAst),
        true,
      );
      selectDir = SKDB.evalSelect(context, cselect, None());
      schema = SKDB.Compiler::getSchema(
        selectAst.params,
        cselect.from,
        cselect.params,
      );
      fieldNames = schema.map(x -> x.name.origName);
      printResult(context, queryID, selectDir.dirName, fieldNames);

      SKStore.EagerDir::apply(
        context,
        selectDir.dirName,
        SKStore.DirName::create(selectDir.dirName.toString() + "sink/"),
        (_context, _writer, _key, _valueIter) ~> {
          jsMarkQuery(queryID32, context ~> {
            printResult(context, queryID, selectDir.dirName, fieldNames);
            jsCallUserFun(queryID32);
          })
        },
        None(),
        None(),
        None(),
        true,
      );
      prefix = selectDir.dirName.toString();
      deps = context.dirs.state
        .getChangesAfter(tick)
        .filter(x -> x.toString().startsWith(prefix))
        .collect(Array);

      invariant(deps.size() > 0);

      getQueryDepsHandle(context).writeArray(
        context,
        SKStore.IID(queryID),
        Array[QueryDeps(deps)],
      );

      context.!newDirs = SortedSet[];
      context.update();
      SKStore.CStop(None())
    })
  } catch {
  | exn -> print_error(exn.getMessage())
  };
}

@wasm_export("SKIP_delete_reactive_query")
fun deleteReactiveQuery(queryID32: Int32): void {
  saved = SKStore.newObstack();
  try {
    SKStore.runWithGc(SKDB.makeSqlContext().clone(), context ~> {
      queryID = SKStore.IID(queryID32.toInt());
      depsDir = getQueryDepsHandle(context);
      arr = depsDir.unsafeGetArray(context, queryID);
      invariant(arr.size() == 1);
      for (dirName in arr[0].dirNames) {
        context.removeDir(dirName);
        // Normally we would use a place-holder when removing a
        // directory, because we typically want to be able to know what
        // changed. But in this case we really want to pretend the
        // directory never existed, so that we don't leak memory.  This
        // is because reactive queries are not supposed to be used for
        // anything else (other than serving the JS). If the JS doesn't
        // need it anymore, we can pretend the directory never existed.
        context.!dirs.state = context.dirs.state.remove(dirName);
      };
      depsDir.writeArray(context, queryID, Array[]);
      SKStore.CStop(None())
    })
  } catch {
  | exn -> print_error(exn.getMessage())
  };
  SKStore.destroyObstack(saved);
}

fun printTable(
  fieldNames: Array<String>,
  values: Sequence<Array<?CValue>>,
  trailing: Bool,
): void {
  colWidth = Array::mcreateFromItems(fieldNames.map(n -> n.length()));
  stringAndColor = values.map(row ->
    row.map(v ->
      v match {
      | None() -> ("null", TermColor.Default())
      | Some(val) ->
        (
          val.toStringWithFormat(SKStore.OTable(fieldNames)),
          val match {
          | CString _ -> TermColor.Blue()
          | CInt _
          | CFloat _ ->
            TermColor.Green()
          },
        )
      }
    )
  );

  for (row in stringAndColor) {
    for ((i, v) in row.map(x -> x.i0).items()) {
      colWidth![i] = max(colWidth[i], v.length())
    }
  };

  // Add spacing
  for (i in Range(0, colWidth.size())) {
    colWidth![i] = colWidth[i] + 2;
  };

  topLeftCorner = "";
  topRightCorner = "";
  bottomLeftCorner = "";
  bottomRightCorner = "";
  topSeparator = "";
  midSeparator = "";
  bottomSeparator = "";
  leftSeparator = "";
  rightSeparator = "";
  lineSeparator = "";
  colSeparator = "";

  printLine = (
    left: String,
    right: String,
    elements: Sequence<String>,
    separator: String,
  ) ~> {
    print_raw(left);
    print_raw(elements.join(separator));
    print_string(right)
  };

  justify = (str, width) ~> {
    totalPadding = width - str.length();
    paddingLeft = totalPadding / 2;
    paddingRight = totalPadding - paddingLeft;
    Range(0, paddingLeft).map(_ -> " ").join("") +
      str +
      Range(0, paddingRight).map(_ -> " ").join("")
  };

  lineSeparatorElements = colWidth.map(w ->
    Range(0, w).map(_ -> lineSeparator).join("")
  );

  // Header
  printLine(topLeftCorner, topRightCorner, lineSeparatorElements, topSeparator);
  printLine(
    colSeparator,
    colSeparator,
    fieldNames.mapWithIndex((i, name) -> justify(name, colWidth[i])),
    colSeparator,
  );
  printLine(leftSeparator, rightSeparator, lineSeparatorElements, midSeparator);

  for (row in stringAndColor) {
    printLine(
      colSeparator,
      colSeparator,
      row.mapWithIndex((i, v) -> {
        (str, color) = v;
        TermColor.colored(justify(str, colWidth[i]), color)
      }),
      colSeparator,
    )
  };

  if (trailing) {
    printLine(
      colSeparator,
      colSeparator,
      colWidth.map(w -> justify("...", w)),
      colSeparator,
    )
  };

  // Footer
  printLine(
    bottomLeftCorner,
    bottomRightCorner,
    lineSeparatorElements,
    bottomSeparator,
  )
}
