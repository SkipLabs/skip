module SKDB;

/*****************************************************************************/
/* Helper functions to evaluate SQL. */
/*****************************************************************************/

fun computeTableDescr(name: Name, schema: Array<TypeDescr>): DirDescr {
  dirNameStr = "/" + name + "/";
  dirName = SKStore.DirName::create(dirNameStr);
  colVec = mutable Vector[];
  for (i in Range(0, schema.size())) {
    colVec.push((schema[i].name, i));
  };
  DirDescr::create{name, schema, dirName, alias => None(), isInput => true}
}

fun computeInsert(
  context: mutable SKStore.Context,
  params: Map<String, Value>,
  inTransaction: Bool,
  pos: Int,
  columnParamsOpt: ?Array<Name>,
  valuesArray: Array<Array<Value>>,
  table: DirDescr,
  repeat: Int = 1,
): Array<RowValues> {
  valuesArray.map(vals -> {
    values = vals.mapWithIndex((idx, val) -> {
      schemaIdx = columnParamsOpt match {
      | None() -> idx
      | Some(columnParams) ->
        colName = columnParams.maybeGet(idx) match {
        | None() -> error(pos, "Value size mismatch with specified columns")
        | Some(param) -> param
        };
        table.cols.maybeGet(colName) match {
        | None() -> error(pos, "Column not found: " + colName)
        | Some(colIdx) -> colIdx
        }
      };
      valueToCValue(
        context,
        params,
        inTransaction,
        pos,
        table.schema,
        schemaIdx,
        val,
      )
    });
    schema = table.schema;
    schemaSize = schema.size();
    valueSize = values.size();
    cvalues = columnParamsOpt match {
    | None() ->
      if (valueSize != schemaSize) {
        error(pos, "Value size mismatch with table schema");
      };
      values
    | Some(columnParams) ->
      missingCols = mutable Map[];
      for (col in schema) {
        missingCols![col.name] = col;
      };
      for (userDefinedCol in columnParams) {
        if (!missingCols.containsKey(userDefinedCol)) {
          error(pos, "Column not found: " + userDefinedCol);
        };
        missingCols.remove(userDefinedCol);
      };

      result = Array<?CValue>::mfill(schema.size(), None());

      for (i => colName in columnParams) {
        result![table.cols[colName]] = values[i];
      };

      for (tyDescr in missingCols) {
        value = tyDescr.default match {
        | None() ->
          if (tyDescr.primary) {
            if (tyDescr.ty is TEXT()) {
              error(pos, "Cannot generate a string primary key");
            };
            Some(CInt(SKStore.genSym(0)))
          } else {
            error(pos, "Missing value for column: " + tyDescr.name);
          }
        | Some(v) ->
          v match {
          | VNull() -> None()
          | VInt(n) -> Some(CInt(n))
          | VFloat(f) -> Some(CFloat(f))
          | VString(x) -> Some(CString(x))
          | _ -> error(pos, "Invalid expression for default value")
          }
        };
        result![table.cols[tyDescr.name]] = value;
      };

      unsafe_chill_trust_me(result)
    };
    result = RowValues::create(cvalues);
    if (repeat != 1) {
      !result = result.setRepeat(repeat);
    };
    result
  })
}

fun valueToCValue(
  context: mutable SKStore.Context,
  params: Map<String, Value>,
  inTransaction: Bool,
  pos: Int,
  schema: Array<TypeDescr>,
  idx: Int,
  val: Value,
): ?CValue {
  if (idx >= schema.size()) {
    error(pos, "Too many columns defined");
  };
  !val = val match {
  | VParam(handle) ->
    params.maybeGet(handle) match {
    | Some(v) -> v
    | None() -> error(pos, "Unbound parameter: " + handle)
    }
  | _ -> val
  };
  if (val is VNull _) {
    if (schema[idx].notNull) {
      error(pos, "cannot insert NULL in column declared as NOT NULL")
    } else {
      return (None() : ?CValue)
    }
  };
  schema[idx].ty match {
  | INTEGER() ->
    val match {
    | VId(isPositive, Some(varName)) ->
      if (!inTransaction) {
        error(pos, "named id can only be used in a transaction");
      };
      globals = context.getGlobal(GLOBALS) match {
      | None() -> Globals()
      | Some(file) -> Globals::type(file)
      };
      globals.maybeGet(varName) match {
      | None() ->
        id = SKStore.genSym(0);
        if (!isPositive) !id = -id;
        !globals = globals.set(varName, id);
        context.setGlobal(GLOBALS, globals);
        Some(CInt(id))
      | Some(id) -> Some(CInt(id))
      }
    | VId(isPositive, None()) ->
      if (isPositive) {
        Some(CInt(SKStore.genSym(0)))
      } else {
        Some(CInt(-SKStore.genSym(0)))
      }
    | VTime() ->
      if (inTransaction) {
        error(pos, "time can not be used in a transaction");
      };
      time = getUnixTime();
      Some(CInt(time))
    | VInt(n) ->
      if (schema[idx].primary) {
        _ = SKStore.genSym(Math.abs(n));
      };
      Some(CInt(n))
    | v ->
      error(
        pos,
        "Type mismatch on column " +
          (idx + 1) +
          " expected type INTEGER (found " +
          inspect(v).toString() +
          ")",
      )
    }
  | FLOAT() ->
    val match {
    | VFloat(f) -> Some(CFloat(f))
    | VInt(i) -> Some(CFloat(i.toFloat()))
    | v ->
      error(
        pos,
        "Type mismatch on column " +
          (idx + 1) +
          " expected type FLOAT (found " +
          inspect(v).toString() +
          ")",
      )
    }
  | TEXT() ->
    val match {
    | VString(str) -> Some(CString(str))
    | v ->
      error(
        pos,
        "Type mismatch on column " +
          (idx + 1) +
          " expected type STRING (found " +
          inspect(v).toString() +
          ")",
      )
    }
  }
}

fun computeKinds(
  params: Array<CGExpr>,
  ekinds: Array<(Int, IKind)>,
): Array<(Int, IKind, Type)> {
  size = params.size();
  paramTypes = params.map(x -> x.getType());
  colSet = mutable Set[];
  ikinds = ekinds.map(eik -> {
    (colNumber, kind) = eik;
    !colNumber = colNumber - 1;
    if (colNumber < 0 || colNumber >= size) {
      errorEval("ORDER BY out of bounds");
    };
    if (colSet.contains(colNumber)) {
      errorEval("invalid ORDER by");
    };
    colSet.add(colNumber);
    (colNumber, kind)
  });
  computeOrder(paramTypes, ikinds)
}

fun computeOrder(
  paramTypes: Array<Type>,
  ikinds: Array<(Int, IKind)>,
): Array<(Int, IKind, Type)> {
  size = paramTypes.size();
  defaultKinds = Array<?(Int, SKDB.IKind, SKDB.Type)>::mfillBy(size, i ->
    Some((i, (INONE() : IKind), paramTypes[i]))
  );
  kinds = mutable Vector[];
  for (ik in ikinds) {
    (colNumber, kind) = ik;
    defaultKinds![colNumber] = None();
    kinds.push((colNumber, kind, paramTypes[colNumber]))
  };
  for (defaultKind in defaultKinds) {
    defaultKind match {
    | None() -> void
    | Some(k) -> kinds.push(k)
    }
  };
  kinds.toArray()
}

class SelectFile(
  tick: Int,
  name: Name,
  virtual: Bool,
  text: String,
  sparams: SelectParams,
  cselect: CSelect,
) extends SKStore.File

class Evaluator{options: Options, user: ?UserFile} {
  fun write(
    context: mutable SKStore.Context,
    dirName: SKStore.DirName,
    key: SKStore.Key,
    value: SKStore.File,
  ): void {
    context.getEagerDir(dirName).write(context, key, value);
  }

  fun writeArray(
    context: mutable SKStore.Context,
    dirName: SKStore.DirName,
    key: SKStore.Key,
    values: Array<SKStore.File>,
  ): void {
    context.getEagerDir(dirName).writeArray(context, key, values);
  }

  fun stmt(
    context: mutable SKStore.Context,
    params: Map<String, Value>,
    stmt: Stmt,
    inTransaction: Bool,
  ): ?((
    mutable SKStore.Context,
    mutable SKStore.Context,
    SKStore.Context,
  ) ~> void) {
    stmt match {
    | Table{pos, name, schema, ifNotExists} ->
      if (inTransaction) {
        error(pos, "Cannot create a table in a transaction");
      };
      Some((context, _, _) ~> {
        dirDescr = computeTableDescr(name, schema);
        this.createTable(context, pos, name, dirDescr, ifNotExists);
      })
    | Insert{pos, onConflict, name, paramsOpt, values} ->
      baseName = SKStore.SID::create(name.lower);
      getTableDir(context).maybeGet(context, baseName) match {
      | None() -> error(pos, "Table not found: " + name)
      | Some(dirDescr) if (dirDescr.view) ->
        error(pos, "Cannot write in view: " + name)
      | _ -> void
      };
      if (!(getViewsDir(context).maybeGet(context, baseName) is None())) {
        error(pos, "Cannot write in view: " + name);
      };
      values match {
      | IQuery(selectAst @ Select _) ->
        if (onConflict is Some _) {
          error(pos, "Can only use OR IGNORE/REPLACE with values");
        };
        !selectAst.id = Name::create(
          selectAst.id.origName + "_" + SKStore.genSym(0),
        );
        compiler = SKDB.Compiler::create(
          false,
          this.options,
          selectAst.pos,
          params,
        );
        select = compiler.compileSelect(context, selectAst, true);
        selectDir = evalSelect(context, select, None());
        updateTableMap(context);
        table = getTable(context, pos, name);
        dir = getDir(table);
        sinkName = "/sinks/sink" + SKStore.genSym(0) + "/";
        sinkDirName = SKStore.DirName::create(sinkName);
        kinds = table.schema.mapWithIndex((idx, x) -> (idx, IASC(), x.ty));
        if (select.params.size() != kinds.size()) {
          error(pos, "Incompatible select size")
        };
        for (i => param in select.params) {
          (kinds[i].i2, param.getType()) match {
          | (INTEGER(), INTEGER())
          | (FLOAT(), FLOAT())
          | (TEXT(), TEXT()) ->
            void
          | _ -> error(pos, "Incompatible select type")
          }
        };
        _ = SKStore.EagerDir::apply(
          context,
          selectDir.dirName,
          sinkDirName,
          (context, _writer, key, valueIter) ~> {
            src = SKStore.Path::create(selectDir.dirName, key);
            entries = Vector[(key, (src, src, valueIter.collect(Array)))];
            inputDir = context.unsafeGetEagerDir(dir.dirName);
            inputDir.writeArraySourceMany(context, entries.iterator());
          },
        );
        None()

      | IValues(vals) ->
        table = getTable(context, pos, name);
        this.insert(
          context,
          params,
          pos,
          onConflict,
          inTransaction,
          table,
          paramsOpt,
          vals,
        )
      }
    | selectAst @ Select{} ->
      compiler = SKDB.Compiler::create(
        !inTransaction,
        this.options,
        selectAst.pos,
        params,
      );
      select = compiler.compileSelect(context, selectAst, true);
      selectDir = evalSelect(context, select, None());
      stdout = context.getGlobal("Stdout") match {
      | Some(StdoutFile(_, l)) -> l
      | Some(_) -> invariant_violation("Wrong type for global stdout")
      | None() -> List[]
      };
      !stdout = List.Cons(selectDir, stdout);
      context.setGlobal("Stdout", StdoutFile(select.format, stdout));
      None()

    | index @ Index _ ->
      Some((context, _, _) ~> {
        this.makeIndex(context, index);
        context.update()
      })
    | View{
      pos,
      name => viewName,
      ifNotExists,
      query => origSelectAst @ Select _,
      virtual,
      text,
    } ->
      if (inTransaction) {
        error(pos, "Cannot create a view in a transaction");
      };
      selectAst = origSelectAst with {id => viewName};
      views = getViewsDir(context);
      viewsDir = context.unsafeGetEagerDir(views.dirName);
      key = SKStore.SID(viewName.lower);
      if (viewsDir.getArrayRaw(key).size() != 0) {
        if (ifNotExists) return None();
        error(pos, "VIEW " + viewName + " already exists");
      } else {
        tables = getTableDir(context);
        tablesDir = context.unsafeGetEagerDir(tables.dirName);
        if (tablesDir.getArrayRaw(key).size() != 0) {
          error(pos, "Table " + viewName + " exists");
        };
      };
      cselect1 = SKDB.Compiler::create(
        false,
        this.options with {virtual => true},
        selectAst.pos,
        params,
      ).compileSelect(context, selectAst, true);
      viewsDir.write(
        context,
        key,
        SelectFile(
          context.tick.value,
          viewName,
          virtual,
          text,
          selectAst.params,
          cselect1,
        ),
      );
      if (virtual) {
        if (inTransaction) {
          error(pos, "Cannot create a virtual view in a transaction");
        };
        startTick = context.tick;
        // This phase just populates the data.
        _ = SKDB.evalSelect(context, cselect1, None());
        Some((context, delta, _) ~> {
          sameDeps = unsafeCompareSets(context.deps.data, delta.deps.data);
          // If the deps haven't changed, that means we can reuse
          // the pre-computed data.
          if (sameDeps != 0) {
            changedDirNames = delta.dirs.state.getChangesAfter(startTick);
            for (changedDirName in changedDirNames) {
              if (!context.dirs.state.containsKey(changedDirName)) {
                context.setGlobal(
                  "PRE_COMPUTED_" + changedDirName,
                  delta.unsafeGetDir(changedDirName),
                );
              }
            }
          };
          compiler = SKDB.Compiler::create(
            false,
            this.options with {virtual => true},
            selectAst.pos,
            params,
          );
          cselect = compiler.compileSelect(context, selectAst, true);
          dirName = SKStore.DirName::create("/" + selectAst.id + "/");
          dirDescr = SKDB.Compiler::getDirDescr(
            selectAst.params,
            cselect.from,
            cselect.params,
            cselect.id,
            dirName,
            true,
          );
          _selectDir = SKDB.evalSelect(context, cselect, None());
          tableDir = getTableDir(context);
          fileName = SKStore.SID::create(viewName.lower);
          tableDir.writeArray(context, fileName, Array[dirDescr]);
        })
      } else {
        None()
      }
    | Drop{pos, kind => TView(), name => viewName} ->
      if (inTransaction) {
        error(pos, "Cannot drop a view in a transaction");
      };
      Some((context, _, _) ~> {
        views = getViewsDir(context);
        viewsDir = context.unsafeGetEagerDir(views.dirName);
        key = SKStore.SID(viewName.lower);
        files = viewsDir.getArrayRaw(key);
        if (files.size() == 0) {
          error(pos, "VIEW " + viewName + " does not exist");
        };
        selectFile = SelectFile::type(files[0]);
        if (selectFile.virtual) {
          error(pos, "Cannot drop a virtual view");
        } else {
          viewsDir.writeArray(context, key, Array[]);
        }
      })

    | Drop{pos, kind => TIndex(), name => _} ->
      error(pos, "Drop index not supported")
    | Drop{kind => TTable(), name} ->
      Some((context, _, _) ~> {
        dirNameStr = "/" + name + "/";
        dirName = SKStore.DirName::create(dirNameStr);
        context.removeDir(dirName);
        context.setDir(
          dirName,
          SKStore.DeletedDir{dirName, time => context.timeStamp()},
        );
        errorAllExistingSubs(context, dirName)
      })
    | Delete{pos, colName => None(), name, where} ->
      _ = this.delete(context, params, pos, name, where, Array[]);
      None()
    | Delete{pos, colName => Some _} ->
      error(pos, "DELETE colName not supported")

    | Update{pos, name, sets, where} ->
      baseName = SKStore.SID::create(name.lower);
      if (getTableDir(context).maybeGet(context, baseName) is None()) {
        error(pos, "Table not found: " + name.origName);
      };
      deleteDir = this.delete(context, params, pos, name, where, sets);
      updateTableMap(context);
      table = getTable(context, pos, name);
      dir = getDir(table);
      sinkName = "/sinks/sink" + SKStore.genSym(0) + "/";
      sinkDirName = SKStore.DirName::create(sinkName);
      _ = SKStore.EagerDir::apply(
        context,
        deleteDir,
        sinkDirName,
        (context, _writer, key, valueIter) ~> {
          src = SKStore.Path::create(deleteDir, key);
          entries = Vector[(key, (src, src, valueIter.collect(Array)))];
          inputDir = context.unsafeGetEagerDir(dir.dirName);
          inputDir.writeArraySourceMany(context, entries.iterator());
        },
      );
      None()
    };
  }

  fun makeIndex(context: mutable SKStore.Context, index: Index): void {
    input = getIndexInputDir(context);
    key = SKStore.SID::create(index.name.lower);
    size = (context.unsafeGetEagerDir(input.dirName)).getArrayRaw(key).size();
    if (size != 0) {
      if (index.ifNotExists) {
        return void;
      };
      error(index.pos, "INDEX " + index.name.origName + " already exists");
    };
    this.write(context, input.dirName, key, index);
    _ = getIndexOutputDir(context);
  }

  fun delete(
    context: mutable SKStore.Context,
    params: Map<String, Value>,
    pos: Int,
    name: Name,
    where: ?Expr,
    sets: Array<(Name, Pos, Expr)>,
  ): SKStore.DirName {
    sinkName = "/sinks/sink" + SKStore.genSym(0) + "/";
    sinkDirName = SKStore.DirName::create(sinkName);
    from = Some(Array[TableName(FName(name), None(), false)]);
    selectAst = Select{
      id => Name::create("SELECT_" + SKStore.genSym(pos)),
      pos => pos,
      params => SelectParams(true, Array[]),
      from,
      where,
      groupBy => None(),
      having => None(),
      join => None(),
      kind => SAll(),
      limit => None(),
      orderBy => None(),
      rest => None(),
    };
    compiler = SKDB.Compiler::create(
      false,
      this.options,
      selectAst.pos,
      params,
    );
    select = compiler.compileSelect(context, selectAst, true, sets);
    selectHandle = evalSelect(context, select, None());
    selectDir = context.unsafeGetEagerDir(selectHandle.dirName);
    updateTableMap(context);
    table = getTable(context, pos, name);
    inputDir = getDir(table);
    SKStore.EagerDir::apply(
      context,
      selectDir.dirName,
      sinkDirName,
      (context, writer, key, rowIter) ~> {
        entries = mutable Vector[];
        dir = context.unsafeGetEagerDir(inputDir.dirName);
        writerPath = SKStore.Path(
          selectDir.dirName,
          SKStore.IID(SKStore.genSym(0)),
        );
        for ((_, source, _) in dir.getDataIterWithoutTombs(context, key)) {
          entries.push(
            (key, (source.path(), writerPath, Array<SKStore.File>[])),
          );
        };
        dir.writeArraySourceMany(context, entries.iterator());
        if (select.sets.isEmpty()) return void;

        row = rowIter.next() match {
        | None() -> return void
        | Some(x @ RowValues _) -> x
        | Some(_) -> invariant_violation("Unexpected row type")
        };

        repeat = row.repeat;

        for (ir in rowIter) {
          ir match {
          | RowValues(_, r) -> !repeat = repeat + r
          | _ -> invariant_violation("Unexpected Row type")
          }
        };

        if (repeat != row.repeat) {
          !row = row.setRepeat(repeat);
        };

        evaluator = ExprEvaluator(Array[row], Array[], None());

        values = Array::mcreateFromItems(row.values);

        for (set in select.sets) {
          (idx, e) = set;
          values![idx] = evaluator.evalCGExpr(context, e) match {
          | ADef(x) -> Some(x)
          | ANull() -> None()
          | AUndef _ -> invariant_violation("Undefined set value")
          };
        };
        !row = RowValues::create(values.chill(), row.repeat);
        kinds = key match {
        | RowKey(_, kinds) -> kinds
        | _ -> invariant_violation("Unexpected row kind")
        };

        writer.set(RowKey(row, kinds), row);
      },
    );
    sinkDir = context.unsafeGetEagerDir(sinkDirName);
    !sinkDir.time.value = Int::max - sinkDir.time.value;
    context.setDir(sinkDir.dirName, sinkDir);
    updateTableMap(context);
    sinkDirName
  }

  fun insert(
    context: mutable SKStore.Context,
    params: Map<String, Value>,
    pos: Int,
    onConflict: ?OnConflict,
    inTransaction: Bool,
    table: DirDescr,
    paramsOpt: ?Array<Name>,
    values: Array<Array<Value>>,
  ): ?((
    mutable SKStore.Context,
    mutable SKStore.Context,
    SKStore.Context,
  ) ~> void) {
    rows = computeInsert(
      context,
      params,
      inTransaction,
      pos,
      paramsOpt,
      values,
      table,
    );
    if (inTransaction && onConflict is Some(OCIgnore())) {
      error(pos, "OR IGNORE not supported in transactions")
    } else if (inTransaction && onConflict is Some(OCReplace())) {
      error(pos, "OR REPLACE not supported in transactions")
    } else if (inTransaction) {
      this.insertTable(context, table, rows);
      None()
    } else if (onConflict is Some(OCUpdate(_))) {
      onConflict match {
      | Some(OCUpdate(update)) ->
        copy = context.clone();
        hasConflict = try {
          this.insertTable(context, table, rows);
          context.update();
          false
        } catch {
        | Conflict _ ->
          context.replaceFromSaved(copy);
          true
        | exn -> throw exn
        };
        if (hasConflict) {
          this.stmt(context, params, update, false)
        } else {
          None()
        }
      | _ -> None()
      }
    } else {
      Some((context, _, _) ~> {
        if (onConflict is Some(OCIgnore())) {
          copy = context.clone();
          try {
            this.insertTable(context, table, rows);
            context.update();
          } catch {
          | Conflict _ -> context.replaceFromSaved(copy)
          | exn -> throw exn
          }
        } else if (onConflict is Some(OCReplace())) {
          loop {
            copy = context.clone();
            shouldContinue = try {
              this.insertTable(context, table, rows);
              context.update();
              false
            } catch {
            | Conflict(_pos, _msg, conflictingValues) ->
              context.replaceFromSaved(copy);
              where: ?Expr = None();
              for (idxValue in conflictingValues) {
                (idx, conValue) = idxValue;
                tyDescr = table.schema[idx];
                clause = Binop(
                  "=",
                  Literal(tyDescr.name.lower),
                  conValue match {
                  | None() -> VNull()
                  | Some(CInt(n)) -> VInt(n)
                  | Some(CString(s)) -> VString(s)
                  | _ -> error(pos, "Unsupported type for OR IGNORE/REPLACE")
                  },
                );
                !where = where match {
                | None() -> Some(clause)
                | Some(w) -> Some(Binop("AND", w, clause))
                }
              };
              tick = context.tick;
              _ = this.delete(context, params, pos, table.name, where, Array[]);
              _ = importNext(context, tick, context);
              true
            | exn -> throw exn
            };
            if (!shouldContinue) break void
          }
        } else {
          this.insertTable(context, table, rows);
          context.update();
        }
      })
    }
  }

  fun insertTable(
    context: mutable SKStore.Context,
    table: DirDescr,
    rows: Array<RowValues>,
  ): void {
    dir = getDir(table);
    newDir = context.unsafeGetEagerDir(dir.dirName);
    kinds = table.schema.mapWithIndex((idx, x) -> (idx, IASC(), x.ty));
    for (row in rows) {
      key = RowKey(row, kinds);
      source = SKStore.Path(dir.dirName, SKStore.IID(SKStore.genSym(0)));
      !newDir = newDir.writeEntry(context, source, source, key, Array[row]);
    };
    context.setDir(newDir.dirName, newDir);
  }

  fun createTable(
    context: mutable SKStore.Context,
    pos: Int,
    name: Name,
    dirDescr: DirDescr,
    ifNotExists: Bool,
  ): void {
    dirName = dirDescr.dirName;
    if (context.unsafeMaybeGetEagerDir(dirName) is Some _ && ifNotExists) {
      return void;
    };

    _ = context.mkdir(x ~> x, RowValues::type, dirName);

    getTableDir(context).writeArray(
      context,
      SKStore.SID::create(name.lower),
      Array[dirDescr],
    );

    hasPrimary = false;

    for (tyDescr in dirDescr.schema) {
      if (tyDescr.primary) {
        if (hasPrimary) {
          error(pos, "multiple primary keys detected");
        };
        if (!(tyDescr.ty is INTEGER()) && !(tyDescr.ty is TEXT())) {
          error(pos, "primary keys are expected to be integers or strings");
        };
        !hasPrimary = true;
      };
      if (tyDescr.unique || tyDescr.primary) {
        this.makeIndex(
          context,
          Index{
            pos => pos,
            ifNotExists => false,
            name => Name::create(name.origName + "_" + tyDescr.name.origName),
            fields => (name, Array[(tyDescr.name, IASC())]),
            unique => true,
            primary => tyDescr.primary,
            text => None(),
          },
        );
      }
    };

    if (context.debugMode) {
      print_string("CREATED: " + name.origName);
    };
  }
}

@cpp_extern("SKIP_String_concatN")
native fun concatArray(Array<String>): String;

@cpp_extern("SKIP_isatty")
native fun isATTY(): UInt32;

@cpp_extern("SKIP_unsafe_compare_sets")
native fun unsafeCompareSets(
  SortedMap<SKStore.Path, SortedSet<SKStore.ArrowKey>>,
  SortedMap<SKStore.Path, SortedSet<SKStore.ArrowKey>>,
): Int32;

fun read(line: Int): (Int, String) {
  i = 0;
  chars = mutable Vector[];
  try {
    loop {
      c = getChar();
      !i = i + 1;

      if (c == '\'') {
        chars.push(c);
        loop {
          c2 = getChar();
          chars.push(c2);
          if (c2 == '\'') break void;
        };
        continue;
      };

      if (c == '-') {
        c2 = getChar();
        !i = i + 1;
        if (c2 == '-') {
          while (getChar() != '\n') {
            !i = i + 1;
          };
          continue
        } else {
          chars.push(c);
          chars.push(c2);
        }
      } else if (c == '/') {
        c2 = getChar();
        !i = i + 1;
        if (c2 == '*') {
          last = getChar();
          !i = i + 1;
          loop {
            c3 = getChar();
            !i = i + 1;
            if (last == '*' && c3 == '/') break void;
            !last = c3;
          };
          continue
        } else {
          chars.push(c);
          chars.push(c2);
        }
      } else {
        chars.push(c);
      };

      if (c == '\n') !line = line + 1;
      if (c == ';') break (line, String::fromChars(chars.toArray()));
    }
  } catch {
  | _endOfFile -> (line, String::fromChars(chars.toArray()))
  }
}

fun getLine(buffer: Buffer, pos: Int): Int {
  line = 1;
  for (i in Range(0, pos)) {
    if (buffer[i] == '\n') {
      !line = line + 1;
    }
  };
  line
}

fun printErrorAndExit(
  lineOffset: Int,
  buffer: Buffer,
  pos: Int,
  msg: String,
): void {
  leftSpaces = 0;
  cursor = 0;
  line = 0;
  !pos = min(buffer.size() - 1, pos);
  while (pos - cursor > 0) {
    if (buffer[pos - cursor] == '\n') {
      !line = line + 1;
      if (line == 1) {
        !leftSpaces = cursor;
      };
      if (line == 5) break void;
    };
    !cursor = cursor + 1
  };
  if (pos - leftSpaces < 0) {
    !leftSpaces = pos;
  };
  right = 0;
  while (pos + right < buffer.size() && buffer[pos + right] != '\n') {
    !right = right + 1
  };
  txtBegin = max(0, pos - cursor);
  txtEnd = min(buffer.size(), pos + right);
  print_error(buffer.slice(txtBegin, txtEnd));
  spaceBuffer = mutable Vector[];
  for (_ in Range(0, leftSpaces - 1)) spaceBuffer.push(' ');
  margin = String::fromChars(spaceBuffer.toArray());
  print_error(margin + "^");
  print_error(margin + "|");
  print_error(margin + " ----- ERROR");
  errLine = lineOffset + getLine(buffer, pos);
  charPos = `characters ${leftSpaces}-${leftSpaces}`;
  print_error(`Error: line ${errLine}, ${charPos}:`);
  print_error(msg);
  skipExit(2)
}

fun evalWithContext(
  options: Options,
  context: mutable SKStore.Context,
  params: Map<String, Value>,
  stmt: Stmt,
  inTransaction: Bool,
): ?((
  mutable SKStore.Context,
  mutable SKStore.Context,
  SKStore.Context,
) ~> void) {
  user = context.getGlobal("USER").map(UserFile::type);
  evaluator = Evaluator{options, user};
  evaluator.stmt(context, params, stmt, inTransaction);
}

fun makeSqlContext(): mutable SKStore.Context {
  gcontext = mutable SKStore.Context{
    unsafeReuse => true,
    failOnExn => true,
    removeSubDirs => true,
  };
  gcontext.setGlobal("Line", SKStore.IntFile(0));
  gcontext
}

fun doOnError(options: Options, f: () -> void, error: Exception -> void): void {
  if (options.backtrace) f() else {
    try {
      f()
    } catch {
    | exn -> error(exn)
    }
  }
}

class StmtFile(stmt: Stmt) extends SKStore.File
class TickFile(tick: SKStore.Tick) extends SKStore.File

base class OutputFormatKind {
  children =
  | OFK_CSV()
  | OFK_JSON()
  | OFK_SQL()
  | OFK_JS()
}

class Options{
  alwaysAllowJoins: Bool,
  backtrace: Bool,
  sync: Bool,
  virtual: Bool = false,
  showUsedIndexes: Bool,
  format: OutputFormatKind = OFK_SQL(),
  expectQueryParams: Bool = false,
} extends SKStore.File

fun evalQuery(
  context: mutable SKStore.Context,
  params: Map<String, Value>,
  query: String,
): Array<RowValues> {
  lexer = SKDB.Lexer(0, SKDB.Buffer(query));
  selectAst = SKDB.parseQuery(lexer, 0).i1 match {
  | x @ Select _ -> x
  };
  skOptions = SKDB.Options{
    alwaysAllowJoins => false,
    backtrace => false,
    sync => false,
    virtual => false,
    showUsedIndexes => false,
  };
  compiler = SKDB.Compiler::create(false, skOptions, 0, params);
  cselect = compiler.compileSelect(context, selectAst, true);
  selectDir = SKDB.evalSelect(context, cselect, None());
  dirName = selectDir.dirName;
  dir = context.unsafeGetEagerDir(dirName);
  result = mutable Vector[];
  dir.onFiles(files -> {
    for (kv in files) {
      (_key, rows) = kv;
      for (row in rows) {
        result.push(RowValues::type(row))
      }
    }
  });
  result.toArray()
}

fun eval(options: Options, params: Map<String, Value>, userOpt: ?String): void {
  isTTY = isATTY() != 0;
  runSql(options, context ~> {
    if (isTTY) {
      print_raw("skdb> ");
    };
    lineFile = SKStore.IntFile::type(context.getGlobal("Line").fromSome());
    context.!globals = SortedMap[];
    userOpt.each(_ -> {
      print_error("Cannot execute queries as user, use --connect instead");
      skipExit(88);
    });
    context.setGlobal("Line", lineFile);
    context.removeGlobal("TableMap");

    gline = lineFile.value;

    line = 0;
    lineStr = "";
    buffer = Buffer(lineStr);
    lex = Lexer(0, buffer);
    pos = 0;
    shouldContinue = false;
    underLockF: ?((
      mutable SKStore.Context,
      mutable SKStore.Context,
      SKStore.Context,
    ) ~> void) = None();

    doOnError(
      options,
      () -> {
        !shouldContinue = true;
        isTransaction = false;

        loop {
          !underLockF = None();
          (!line, !lineStr) = read(gline);
          !buffer = Buffer(lineStr);
          !lex = Lexer(0, buffer);
          !pos = 0;

          if (isEOF(lex, pos)) {
            !shouldContinue = false;
            if (isTransaction) {
              printErrorAndExit(line, buffer, pos, "Unfinished transaction");
            };
            return void;
          };

          if (lex.isEqUpper(pos, "BEGIN")) {
            !pos = lex.expectUpper(pos, "BEGIN");
            !pos = lex.expectUpper(pos, "TRANSACTION");
            !pos = lex.expect(pos, ";");

            if (isTransaction) {
              printErrorAndExit(line, buffer, pos, "Nested transaction");
            };
            !isTransaction = true;
            continue;
          };

          if (lex.isEqUpper(pos, "COMMIT")) {
            !pos = lex.expectUpper(pos, "COMMIT");
            !pos = lex.expect(pos, ";");
            context.getGlobal("GLOBALS") match {
            | None() -> void
            | Some(_) -> context.removeGlobal(GLOBALS)
            };
            break void;
          };

          (!pos, stmtOpt) = parseStmt(lex, pos);
          stmt = stmtOpt match {
          | None() -> break void
          | Some(x) -> x
          };
          markIfRead(context, stmt);

          lastStmtOpt = context.getGlobal("LastStmtOpt").map(file ->
            StmtFile::type(file).stmt
          );

          (lastStmtOpt, stmt) match {
          | (Some(Select _), Drop _)
          | (Some(Select _), Delete _)
          | (Some(Select _), Insert _)
          | (Some(View _), Drop _)
          | (Some(View _), Delete _)
          | (Some(View _), Insert _) ->
            updateTableMap(context)

          | _ -> void
          };

          !underLockF = evalWithContext(
            options,
            context,
            params,
            stmt,
            isTransaction,
          );

          context.setGlobal("LastStmt", StmtFile(stmt));

          if (!isTransaction) break void;
        };
      },
      err -> {
        err match {
        | IgnoreAndContinue() -> void
        | Error(posError, str) ->
          printErrorAndExit(gline, buffer, posError, str)
        | exn ->
          print_error(exn.getMessage());
          skipExit(44)
        }
      },
    );

    !gline = line;
    context.setGlobal("Line", SKStore.IntFile(gline));

    if (shouldContinue) {
      SKStore.CContinue(underLockF)
    } else {
      SKStore.CStop(underLockF)
    }
  })
}

fun runSql(
  options: Options,
  f: mutable SKStore.Context ~> SKStore.ContextOp,
): void {
  SKStore.runWithGc(
    SKDB.makeSqlContext().clone(),
    f,
    Some(SKStore.Synchronizer(importFromRoot, exportToRoot, printContext)),
    options.sync,
  )
}

fun runLockedSql(options: Options, f: mutable SKStore.Context ~> void): void {
  SKStore.runLocked(SKDB.makeSqlContext().clone(), f, options.sync)
}

fun importFromRoot(
  delta: mutable SKStore.Context,
  tick: SKStore.Tick,
  root: readonly SKStore.Context,
): void {
  try {
    shouldImport = delta.getGlobal("TableMap") match {
    | None() ->
      delta.getGlobal("IsRead") match {
      | None() -> false
      | Some(_) -> true
      }
    | Some(_tableMapFile) -> true
    };
    if (shouldImport) {
      SKStore.import(delta, tick, root);
      delta.update();
    }
  } catch {
  | err ->
    line = delta.getGlobal("Line") match {
    | None() -> -1
    | Some(x) -> SKStore.IntFile::type(x).value
    };
    print_error("Error, line " + line + ": " + err.getMessage());
    skipExit(2)
  }
}

fun makeInputDirName(dirName: SKStore.DirName): (SKStore.DirName, Int) {
  dirNameStr = dirName.toString();
  if (dirNameStr.startsWith("/next/")) {
    !dirNameStr = dirNameStr.stripPrefix("/next/");
    iter = dirNameStr.getIter();
    i = 0;
    for (c in iter) {
      if (c == '/') break void;
      !i = i + 1;
    };
    nbr = mutable Vector[];
    for (c in iter) {
      if (c == '/') break void;
      nbr.push(c);
    };
    !dirNameStr = "/" + dirNameStr.sub(dirNameStr.getIter(), i) + "/";
    (
      SKStore.DirName::create(dirNameStr),
      String::fromChars(nbr.toArray()).toInt(),
    )
  } else {
    (dirName, 0)
  }
}

fun importNext(
  targetCtx: mutable SKStore.Context,
  tick: SKStore.Tick,
  sourceCtx: readonly SKStore.Context,
): Bool {
  changedDirNames = sourceCtx.dirs.state.getChangesAfter(tick);
  updates = mutable Map[];
  hasMultipleVersions = false;
  for (dirName in changedDirNames) {
    sourceCtx.unsafeMaybeGetDir(dirName) match {
    | Some(SKStore.DeletedDir{}) -> targetCtx.removeDir(dirName)
    | Some(dir @ SKStore.EagerDir{input => true}) ->
      (targetDirName, version) = makeInputDirName(dirName);
      !hasMultipleVersions = hasMultipleVersions || version != 0;
      updates.maybeGet(targetDirName) match {
      | Some((_, _, _, iversion, _)) if (iversion > version) -> void
      | _ ->
        (isReset, changedKeys) = dir.getChangesAfter(tick);
        targetCtx.unsafeMaybeGetDir(targetDirName) match {
        | None() ->
          time = targetCtx.timeStamp();
          targetDir = SKStore.EagerDir{
            time,
            input => true,
            dirName => targetDirName,
            fixedData => SKStore.FixedDataMap::create(),
            totalSize => 0,
            creator => None(),
          };
          targetCtx.setDir(targetDir.dirName, targetDir)
        | Some(_) -> void
        };
        entries = mutable Vector[];
        for (key in changedKeys) {
          for (srcValue in dir.unsafeGetAllDataIterAfter(tick, key)) {
            (_, source, writer, values) = srcValue;
            entries.push((key, (source.path(), writer.path(), values)));
          }
        };
        updates![targetDirName] = (isReset, changedKeys, dir, version, entries)
      }
    | _ -> void
    }
  };
  for (targetDirName => src in updates) {
    (isReset, changedKeys, dir, _, entries) = src;
    targetCtx.unsafeMaybeGetEagerDir(targetDirName) match {
    | None() -> invariant_violation("Directory should have been created")
    | Some(inputDir) ->
      !inputDir = inputDir.writeArraySourceManyReturnDir(
        targetCtx,
        entries.iterator(),
      );
      if (isReset) {
        writerPath = SKStore.Path(dir.dirName, SKStore.IID(SKStore.genSym(0)));
        !inputDir = inputDir.reset(targetCtx, writerPath, changedKeys);
      };
      targetCtx.setDir(inputDir.dirName, inputDir)
    }
  };
  hasMultipleVersions
}

fun exportToRoot(
  root: mutable SKStore.Context,
  tick: SKStore.Tick,
  delta: readonly SKStore.Context,
): Bool {
  rootCopy = root.clone();
  try {
    hasVersioning = importNext(root, tick, delta);
    root.update();
    hasVersioning
  } catch {
  | err ->
    line = delta.getGlobal("Line") match {
    | None() -> -1
    | Some(x) -> SKStore.IntFile::type(x).value
    };
    root.replaceFromSaved(rootCopy);
    print_error("Error, line " + line + ": " + err.getMessage());
    skipExit(2)
  }
}

fun updateTableMap(context: mutable SKStore.Context): void {
  tableMap = context.getGlobal("TableMap") match {
  | None() ->
    TableMap{
      version => Version(SKStore.genSym(0)),
      startTick => context.tick,
      map => SortedMap[],
    }
  | Some(file) -> TableMap::type(file)
  };
  !tableMap.version.value = SKStore.genSym(tableMap.version.value);
  context.setGlobal("TableMap", tableMap)
}

class StdoutFile(
  format: SKStore.OutputFormat,
  value: List<SelectDir>,
) extends SKStore.File

class StdoutDiff(
  format: SKStore.OutputFormat,
  dirName: SKStore.DirName,
  time: SKStore.Tick,
  filter: (SKStore.Context, Bool) ~> (SKStore.Key -> Bool),
  getDestinationWatermark: (readonly SKStore.Context) ~> ?SKStore.Tick,
) extends SKStore.File

class StdoutCheckpointAck(time: SKStore.Tick) extends SKStore.File

fun showSelect(
  context: mutable SKStore.Context,
  format: SKStore.OutputFormat,
  sdir: SelectDir,
): void {
  dirName = sdir.dirName;
  dir = context.unsafeGetEagerDir(dirName);
  RowValues::printHeader(format);
  dir.onFiles(files ~> {
    for (kv in files) {
      (_key, rows) = kv;
      rowArray = rows.collect(Array);
      for (row in rowArray) {
        row match {
        | rvalues @ RowValues(_, r) ->
          for (_ in Range(0, r)) {
            RowValues::printItem(format, rvalues)
          }
        | _ -> invariant_violation("Invalid row kind")
        }
      }
    }
  })
}

fun printContext(context: mutable SKStore.Context): void {
  context.globals.maybeGet("Stdout") match {
  | None() -> void
  | Some(StdoutFile(format, stdout)) ->
    for (selectDir in stdout.toArray().reversed()) {
      showSelect(context, format, selectDir)
    }
  | Some(StdoutDiff(format, dirName, time, filter, getWatermark)) ->
    edir = context.unsafeGetEagerDir(dirName);
    (isReset, changes) = edir.getChangesAfter(time);
    _ = edir.writeDiffStdout(
      context,
      isReset,
      changes,
      print_raw,
      format,
      filter,
      getWatermark(context),
    )

  | Some _ -> invariant_violation("Unexpected Stdout type")
  };
  context.globals.maybeGet("Ack") match {
  | None() -> void
  | Some(StdoutCheckpointAck(tick)) ->
    print_raw(":" + tick.value.toString() + "\n")
  | Some _ -> invariant_violation("Unexpected Ack type")
  };
  flushStdout();
}

fun markIfRead(context: mutable SKStore.Context, stmt: Stmt): void {
  stmt match {
  | Insert{values => IQuery _}
  | Update _
  | Select _ ->
    context.setGlobal("IsRead", SKStore.BoolFile(true))
  | Table _
  | View _
  | Drop _
  | Delete _
  | Index _
  | Insert _ ->
    void
  }
}

/*****************************************************************************/
/* Primitives storing external functions to be computed in a lazy directory. */
/*****************************************************************************/

@cpp_extern("SKIP_has_local_context")
native fun hasLocalContext(): Int32;

@cpp_extern("SKIP_set_local_context")
native fun setLocalContext(mutable SKStore.Context): void;

@cpp_extern("SKIP_remove_local_context")
native fun removeLocalContext(): void;

@cpp_extern("SKIP_get_local_context")
native fun getLocalContext(): mutable SKStore.Context;

@cpp_extern("SKIP_call_external_fun")
native fun callExternalFun(Int32, String): String;

fun withLocalContext<T>(context: mutable SKStore.Context, f: () -> T): T {
  if (hasLocalContext() == 0) {
    setLocalContext(context);
    result = try {
      f()
    } catch {
    | exn ->
      removeLocalContext();
      print_error(exn.getMessage());
      throw exn
    };
    removeLocalContext();
    result
  } else {
    oldContext = getLocalContext();
    result = try {
      f()
    } catch {
    | exn ->
      setLocalContext(oldContext);
      print_error(exn.getMessage());
      throw exn
    };
    setLocalContext(oldContext);
    result
  }
}

class AlreadyDefiningRoot() extends Exception {
  fun getMessage(): String {
    "Cannot define a root while already defining a root"
  }
}

class JSCall(funId: Int32, funArg: String) extends SKStore.File
const jsRootsInputDirName: SKStore.DirName = SKStore.DirName::create(
  "/jsRootsInput/",
);
const jsRootsValuesDirName: SKStore.DirName = SKStore.DirName::create(
  "/jsroots/",
);
const jsRootsName: Name = Name::create("jsroots");

@export("SKIP_init_jsroots")
fun initJSRoots(): void {
  saved = SKStore.newObstack();
  try {
    SKStore.runWithGc(SKDB.makeSqlContext().clone(), context ~> {
      context.unsafeMaybeGetEagerDir(jsRootsInputDirName) match {
      | None() -> void
      | Some(dir) ->
        dir.onFiles(iter -> {
          for (kv in iter) {
            (key, _fileIter) = kv;
            !dir = dir.writeArrayReturnDir(context, key, Array[]);
          };
        });
        context.setDir(dir.dirName, dir);
        return SKStore.CStop(None())
      };
      context.!globals = SortedMap[];
      dirDescr = DirDescr::create{
        name => jsRootsName,
        schema => Array[
          TypeDescr{
            name => Name::create("name"),
            ty => TEXT(),
            primary => false,
            unique => false,
            default => None(),
            notNull => true,
          },
          TypeDescr{
            name => Name::create("value"),
            ty => TEXT(),
            primary => false,
            unique => false,
            default => None(),
            notNull => true,
          },
        ],
        dirName => jsRootsValuesDirName,
        alias => None(),
        isInput => false,
      };
      tableDir = getTableDir(context);
      fileName = SKStore.SID::create("jsroots");
      tableDir.writeArray(context, fileName, Array[dirDescr]);
      kinds = dirDescr.schema.mapWithIndex((idx, ty) -> (idx, IASC(), ty.ty));
      _ = context
        .mkdir(x ~> x, JSCall::type, jsRootsInputDirName, Array[])
        .map(
          x ~> x,
          RowValues::type,
          context,
          jsRootsValuesDirName,
          (context, writer, baseName, values) ~>
            withLocalContext(context, () -> {
              name = baseName match {
              | SKStore.SID(x) -> x
              | _ -> invariant_violation("Unexpected key type")
              };
              value = values.first;
              result = callExternalFun(value.funId, value.funArg);
              row = RowValues::create(
                Array[Some(CString(name)), Some(CString(result))],
              );
              writer.set(RowKey(row, kinds), row);
            })
          ,
        );
      SKStore.CStop(None());
    })
  } catch {
  | exn ->
    SKStore.destroyObstack(saved);
    throw (exn)
  };
  SKStore.destroyObstack(saved);
}

@export("SKIP_add_root")
fun addRoot(rootName: String, funId: Int32, funArg: String): void {
  if (hasLocalContext() != 0) throw AlreadyDefiningRoot();
  saved = SKStore.newObstack();
  try {
    SKStore.runWithGc(SKDB.makeSqlContext().clone(), context ~> {
      context.!globals = SortedMap[];
      (context.unsafeGetEagerDir(jsRootsInputDirName)).writeArray(
        context,
        SKStore.SID(rootName),
        Array[JSCall(funId, funArg)],
      );
      context.update();
      SKStore.CStop(None())
    })
  } catch {
  | exn ->
    SKStore.destroyObstack(saved);
    throw (exn)
  };
  SKStore.destroyObstack(saved);
}

@export("SKIP_remove_root")
fun removeRoot(rootName: String): void {
  if (hasLocalContext() != 0) throw AlreadyDefiningRoot();
  saved = SKStore.newObstack();
  try {
    SKStore.runWithGc(SKDB.makeSqlContext().clone(), context ~> {
      context.!globals = SortedMap[];
      if (context.unsafeMaybeGetEagerDir(jsRootsInputDirName) is None()) {
        return SKStore.CStop(None());
      };
      (context.unsafeGetEagerDir(jsRootsInputDirName)).writeArray(
        context,
        SKStore.SID(rootName),
        Array[],
      );
      context.update();
      SKStore.CStop(None());
    })
  } catch {
  | exn ->
    SKStore.destroyObstack(saved);
    throw (exn)
  };
  SKStore.destroyObstack(saved);
}

const trackedJSCallsDirName: SKStore.DirName = SKStore.DirName::create(
  "/jsTrackedCalls/",
);

class InvalidTrackedCall() extends Exception {
  fun getMessage(): String {
    "Tracked calls can only be made while defining a root."
  }
}

fun initTrackedJSCalls(context: mutable SKStore.Context): void {
  _ = SKStore.LHandle::create(
    SKStore.SID::keyType,
    SKStore.StringFile::type,
    context,
    trackedJSCallsDirName,
    (context, _self, key) ~>
      withLocalContext(context, () -> {
        setLocalContext(context);
        (funIdStr, funArg) = key match {
        | SKStore.SID(v) -> v.splitFirst("#")
        };
        funId = Int32::truncate(funIdStr.toInt());
        result = callExternalFun(funId, funArg);
        Array[SKStore.StringFile(result)]
      })
    ,
  );
}

@export("SKIP_tracked_call")
fun trackedCall(funId: Int32, funArg: String): String {
  if (hasLocalContext() == 0) throw InvalidTrackedCall();
  context = getLocalContext();
  ldir = context.unsafeMaybeGetLazyDir(trackedJSCallsDirName) match {
  | None() ->
    initTrackedJSCalls(context);
    context.unsafeGetLazyDir(trackedJSCallsDirName)
  | Some(l) -> l
  };
  arr = ldir.getArray(context, SKStore.SID("" + funId + "#" + funArg));
  invariant(arr.size() == 1);
  SKStore.StringFile::type(arr[0]).value
}

/*****************************************************************************/
/* Support for tracked queries. */
/*****************************************************************************/

const trackedJSQueriesDirName: SKStore.DirName = SKStore.DirName::create(
  "/jsTrackedQueries/",
);

class InvalidTrackedQuery() extends Exception {
  fun getMessage(): String {
    "Tracked queries can only be made while defining a root."
  }
}

class TrackedQuery(
  query: String,
  encoded_params: String,
  start: Int,
  end: ?Int,
) extends SKStore.Key {
  fun toString(): String {
    inspect(this).toString()
  }
}

// Decode a string to a JSON Object, expected to be a map from key
// strings (parameter names) to values.
fun decodeParams(encoded_params: String): Map<String, Value> {
  try {
    JSON.decode(encoded_params) match {
    | map @ JSON.Object _ ->
      map.value.mapItems((key, val) -> {
        !key = key.stripPrefix("@");
        lit = val match {
        | JSON.Null() -> SKDB.VNull()
        | JSON.IntNumber(v) -> SKDB.VInt(v)
        | JSON.Bool(v) -> if (v) SKDB.VInt(1) else SKDB.VInt(0)
        | JSON.FloatNumber(v) -> SKDB.VFloat(v)
        | JSON.String(v) -> SKDB.VString(v)
        | JSON.Array _
        | JSON.Object _ ->
          print_error(
            "Value " +
              val +
              " of statement parameter" +
              key +
              " expected to be a literal value",
          );
          skipExit(2)
        };
        (key, lit)
      })
    | _ ->
      print_error("Expected an encoded JSON Object, got: " + encoded_params);
      skipExit(2)
    }
  } catch {
  | exn ->
    print_error(
      "Decoding JSON failed: \"" + encoded_params + "\"\n" + exn.getMessage(),
    );
    skipExit(2)
  }
}

fun initTrackedJSQueries(context: mutable SKStore.Context): void {
  _ = SKStore.LHandle::create(
    TrackedQuery::keyType,
    SKStore.StringFile::type,
    context,
    trackedJSQueriesDirName,
    (context, _self, key) ~> {
      SKStore.withRegion(context, (_, context) ~> {
        query = key match {
        | q @ TrackedQuery _ -> q
        };
        lexer = SKDB.Lexer(0, SKDB.Buffer(query.query));
        selectAst = SKDB.parseQuery(lexer, 0).i1 match {
        | x @ Select _ -> x
        };
        skOptions = SKDB.Options{
          alwaysAllowJoins => false,
          backtrace => false,
          sync => false,
          virtual => false,
          showUsedIndexes => false,
        };
        params = decodeParams(query.encoded_params);
        compiler = SKDB.Compiler::create(false, skOptions, 0, params);
        tableMapCopy = context.getGlobal("TableMap");
        context.removeGlobal("TableMap");
        select = compiler.compileSelect(context, selectAst, true);
        tableMapCopy match {
        | None() -> void
        | Some(x) -> context.setGlobal("TableMap", x)
        };
        selectDir = SKDB.evalSelect(context, select, None());
        selectDirName = selectDir.dirName;
        selectProjDirName = SKStore.DirName::create(
          selectDirName.toString() + "proj/",
        );

        dirDescr = Compiler::getDirDescr(
          selectAst.params,
          select.from,
          select.params,
          Name::create(selectDirName.toString()),
          selectDirName,
        );
        fieldNames = dirDescr.schema.map(x -> x.name.origName);
        format = SKStore.OJSON(fieldNames);

        selectProj = SKStore.EHandle(
          x ~> x,
          RowValues::type,
          selectDirName,
        ).map(
          x ~> x,
          RowValues::type,
          context,
          selectProjDirName,
          (_context, writer, _key, values) ~> {
            writer.setArray(SKStore.IID(0), values.collect(Array))
          },
        );
        proj = selectProj.getIter(context, SKStore.IID(0));
        acc = mutable Vector[];
        i = 0;
        for (rvalues in proj) {
          if (i < query.start) {
            !i = i + 1;
            continue
          };
          query.end match {
          | Some(end) -> if (i >= end) break void
          | _ -> void
          };
          for (_ in Range(0, rvalues.getRepeat())) {
            acc.push(rvalues.toStringSingle(format))
          };
          !i = i + 1;
        };
        Array[SKStore.StringFile(acc.join("\n"))]
      })
    },
  );
}

@export("SKIP_tracked_query")
fun trackedQuery(
  query: String,
  encoded_params: String,
  start: Int32,
  end: Int32,
): String {
  if (hasLocalContext() == 0) throw InvalidTrackedQuery();
  context = getLocalContext();
  ldir = context.unsafeMaybeGetLazyDir(trackedJSQueriesDirName) match {
  | None() ->
    initTrackedJSQueries(context);
    context.unsafeGetLazyDir(trackedJSQueriesDirName)
  | Some(l) -> l
  };
  arr = ldir.getArray(
    context,
    TrackedQuery(
      query,
      encoded_params,
      start.toInt(),
      if (end == -1) None() else Some(end.toInt()),
    ),
  );
  invariant(arr.size() == 1);
  SKStore.StringFile::type(arr[0]).value
}
