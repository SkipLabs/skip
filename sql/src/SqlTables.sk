/*****************************************************************************/
/* SQL tables.*/
/*****************************************************************************/

module SKDB;

const tableInfo: SKStore.DirName = SKStore.DirName::create("/tablesInfo/");
const views: SKStore.DirName = SKStore.DirName::create("/views/");
const subsInput: SKStore.DirName = SKStore.DirName::create("/subsInput/");
const subsOutput: SKStore.DirName = SKStore.DirName::create("/subsOutput/");
const indexInput: SKStore.DirName = SKStore.DirName::create("/indexInput/");
const indexOutput: SKStore.DirName = SKStore.DirName::create("/indexOutput/");
const indexByCol: SKStore.DirName = SKStore.DirName::create("/indexByCol/");
const watermarks: SKStore.DirName = SKStore.DirName::create("/watermarks/");

fun getWatermark(
  context: readonly SKStore.Context,
  tableName: String,
  replicationSource: ?Int,
): ?SKStore.Tick {
  replicationSource match {
  | None() -> None()
  | Some(source) ->
    context.unsafeMaybeGetDir(watermarks) match {
    | None() -> None()
    | Some(d) ->
      key = SKStore.SID::create(`${tableName}_${source}`);
      arr = d.getArrayRaw(key);
      if (arr.size() > 0) Some(SKStore.TickFile::fromFile(arr[0]).value) else {
        None()
      }
    }
  }
}

fun setWatermark(
  context: mutable SKStore.Context,
  tableName: String,
  replicationSource: Int,
  checkpointTick: SKStore.Tick,
): void {
  watermarkDir = context.maybeGetDir(watermarks) match {
  | None() -> context.mkdir(SKStore.TickFile::fromFile, watermarks)
  | Some(d) -> SKStore.EHandle(SKStore.TickFile::fromFile, d.getDirName())
  };
  key = SKStore.SID::create(`${tableName}_${replicationSource}`);
  mark = watermarkDir
    .unsafeGetArray(context, key)
    .reduce(max, SKStore.TickFile(checkpointTick));
  watermarkDir.writeArray(context, key, Array[mark]);
}

extension class TypeDescr extends SKStore.File

class DirDescr{
  colNames: Array<Name>,
  schema: Array<TypeDescr>,
  kinds: Array<(Int, IKind, Type)>,
  cols: Map<Name, Int>,
  alias: ?Name,
  isInput: Bool,
} extends SKStore.File, Descr uses Orderable {
  fun compare(y: DirDescr): Order {
    this.name.compare(y.name)
  }

  static fun create{
    name: Name,
    schema: Array<TypeDescr>,
    dirName: SKStore.DirName,
    alias: ?Name,
    isInput: Bool,
  }: this {
    cols = mutable Map[];
    colNames = schema.map(x -> x.name);
    for (i => ty in schema) {
      cols![ty.name] = i;
    };
    static{
      name,
      colNames,
      schema,
      kinds => schema.mapWithIndex((idx, ty) -> (idx, IASC(), ty.ty)),
      cols => cols.chill(),
      dirName,
      alias,
      isInput,
    }
  }
}

fun makeSelectName(id: String): SKStore.DirName {
  SKStore.DirName::create("/" + id + "/");
}

fun getDir(dirDescr: DirDescr): SKStore.EHandle<Row> {
  SKStore.EHandle(RowValues::fromFile, dirDescr.dirName)
}

fun makeDir<T: frozen>(
  fromFile: SKStore.File ~> T,
  context: mutable SKStore.Context,
  dirName: SKStore.DirName,
  make: () -> SKStore.EHandle<T>,
): SKStore.EHandle<T> {
  context.maybeGetDir(dirName) match {
  | None() -> make()
  | Some(dir) -> SKStore.EHandle(fromFile, dir.getDirName())
  };
}

fun getTableDir(context: mutable SKStore.Context): SKStore.EHandle<DirDescr> {
  makeDir(DirDescr::fromFile, context, tableInfo, () -> {
    context.mkdir(DirDescr::fromFile, tableInfo, Array[])
  })
}

/*****************************************************************************/
/* Getting the latest directory descriptor.
 *
 * Sometimes, we have to do physical copies of SQL tables or directories.
 * This will happen when we are dealing with a transaction that is both
 * reading and writing to the same table.
 *
 * For example:
 * begin transaction;
 *   delete from t1;
 *   insert into t1 ...
 * commit;
 *
 * You can guess what the problem here is. Because t1 is reactive, that means
 * that the delete statement will delete anything added to t1. The solution
 * is simple, the version that t1 inserts into is not the same than the one
 * we delete from. To keep track of the different version of table we have
 * a global called TableMap.
 *
 * At commit time, under the global lock, the different versions are thrown
 * away, and only the result is copied into the real time.
 */
/*****************************************************************************/

value class Version(value: Int) uses Orderable

class TableMap{
  startTick: SKStore.Tick,
  version: Version,
  map: SortedMap<SKStore.Key, (Version, Descr)>,
} extends SKStore.File

fun dirDescrCopy(
  context: mutable SKStore.Context,
  dirName: SKStore.DirName,
  tableName: String,
  version: Version,
): SKStore.DirName {
  oldDir = context.unsafeGetEagerDir(dirName);
  nextName = SKStore.DirName::create(
    "/next/" + tableName + "/" + version.value + "/",
  );
  sinkName = SKStore.DirName::create(
    "/sink/" + tableName + "/" + version.value + "/",
  );
  dir = SKStore.EagerDir{
    time => context.timeStamp(),
    dirName => nextName,
    input => true,
    fixedData => oldDir.fixedData,
    data => oldDir.data,
    totalSize => oldDir.totalSize,
    creator => context.currentArrow(),
  };
  context.setDir(dir.dirName, dir);
  limit = context.tick;
  _ = SKStore.EagerDir::apply(
    context,
    dirName,
    sinkName,
    (context, _writer, key, _valueIter) ~> {
      entries = mutable Vector[];
      for (srcValue in (context.unsafeGetEagerDir(
        dirName,
      )).unsafeGetAllDataIterAfter(limit, key)) {
        (_, source, writer, values) = srcValue;
        entries.push((key, (source.path(), writer.path(), values)));
      };
      inputDir = context.unsafeGetEagerDir(nextName);
      inputDir.writeArraySourceMany(context, entries.iterator());
    },
    None(),
    None(),
    true,
  );
  nextName
}

base class Descr{name: Name, dirName: SKStore.DirName} {}

fun getLatestDescr(context: mutable SKStore.Context, descr: Descr): Descr {
  baseName = SKStore.SID(descr.name.lower);
  context.getGlobal("TableMap") match {
  | None() -> descr
  | Some(tableMapFile) ->
    tableMap = TableMap::fromFile(tableMapFile);
    oldDescr = tableMap.map.maybeGet(baseName) match {
    | None() -> descr
    | Some((version, oldDescr)) if (version == tableMap.version) ->
      return oldDescr
    | Some((_, x)) -> x
    };
    nextName = dirDescrCopy(
      context,
      oldDescr.dirName,
      descr.name.origName,
      tableMap.version,
    );
    result = descr with {dirName => nextName};
    !tableMap.map[baseName] = (tableMap.version, result);
    context.setGlobal("TableMap", tableMap);
    result
  }
}

fun getLatestDirDescr(
  context: mutable SKStore.Context,
  dirDescr: DirDescr,
): DirDescr {
  getLatestDescr(context, dirDescr) match {
  | IndexDescr _ -> invariant_violation("Was not expecting an index")
  | x @ DirDescr _ -> x
  }
}

fun getLatestIndexDescr(
  context: mutable SKStore.Context,
  indexDescr: IndexDescr,
): IndexDescr {
  getLatestDescr(context, indexDescr) match {
  | DirDescr _ -> invariant_violation("Was not expecting a table")
  | x @ IndexDescr _ -> x
  }
}

/*****************************************************************************/
/* Sharding stats for joins. */
/*****************************************************************************/

class ShardStats(
  tick: SKStore.Tick,
  left: Int,
  right: Int,
) extends SKStore.File

/*****************************************************************************/
/* Views. */
/*****************************************************************************/

fun getViewsDir(context: mutable SKStore.Context): SKStore.EHandle<SelectFile> {
  makeDir(SelectFile::fromFile, context, views, () ->
    context.mkdir(SelectFile::fromFile, views, Array[])
  )
}

/*****************************************************************************/
/* Subscriptions. */
/*****************************************************************************/

class SubRequestFile(
  viewName: String,
  viewDirName: SKStore.DirName,
  init: Bool,
  cmd: SKStore.CmdKind,
  sessionID: Int,
  ignoreSource: ?Int,
) extends SKStore.File

fun getSubsDirs(
  context: mutable SKStore.Context,
): (SKStore.EHandle<SubRequestFile>, SKStore.EHandle<SKStore.IntFile>) {
  if (context.unsafeMaybeGetEagerDir(subsInput) is Some _) {
    input = SKStore.EHandle(SubRequestFile::fromFile, subsInput);
    output = SKStore.EHandle(SKStore.IntFile::fromFile, subsOutput);
    return (input, output)
  };
  input = context.mkdir(SubRequestFile::fromFile, subsInput, Array[]);
  output = input.contextWriterKeyValues(
    SKStore.IntFile::fromFile,
    context,
    subsOutput,
    (context, writer, key, values) ~> {
      request = SubRequestFile::fromFile(values[0]);
      viewName = request.viewName;
      cmd = request.cmd;
      init = request.init;
      sessionID = request.sessionID;
      tableDir = getTableDir(context);
      (edir, dirDescr) = tableDir.maybeGet(
        context,
        SKStore.SID(request.viewName),
      ) match {
      | None() ->
        views = SKDB.getViewsDir(context);
        viewsDir = context.unsafeGetEagerDir(views.dirName);
        selectFiles = viewsDir.getArrayRaw(SKStore.SID(viewName.toString()));
        invariant(selectFiles.size() <= 1);
        if (selectFiles.size() == 0) {
          print_error(`Error: view ${viewName.toString()} doesn't exists`);
          skipExit(3)
        };
        selectFile = SKDB.SelectFile::fromFile(selectFiles[0]);
        if (!selectFile.virtual) {
          print_error("Error: can only connect to virtual views");
          skipExit(23);
        };
        cselect = selectFile.cselect;
        selectDir = SKDB.evalSelect(context, cselect, None());
        edir = context.unsafeGetEagerDir(selectDir.dirName);
        dirDescr = Compiler::getDirDescr(
          selectFile.sparams,
          cselect.from,
          cselect.params,
          Name::create(selectDir.dirName.toString()),
          selectDir.dirName,
        );
        (edir, dirDescr)
      | Some(dirDescr) ->
        edir = context.unsafeGetEagerDir(dirDescr.dirName);
        (edir, dirDescr)
      };
      reset = (_, _) ~> false;
      alwaysTrue = (_baseName ~> true);
      filter = request.ignoreSource match {
      | None() -> (_context, _isReset) ~> alwaysTrue
      | Some(inputSrc) ->
        (context, isReset) ~> {
          if (isReset) return alwaysTrue;
          tdir = context.unsafeGetEagerDir(dirDescr.dirName);
          ignoredSrc = SKStore.Source::create(
            SKStore.Path(dirDescr.dirName, SKStore.IID(inputSrc)),
          );
          (file: SKStore.Key) -> {
            rows = tdir.getAllDataIter(context.mclone(), file).collect(Array);
            !updateIsFromIgnoredSource(ignoredSrc, rows)
          }
        }
      };
      context.subscribe(
        context,
        edir.dirName,
        sessionID,
        cmd,
        init,
        reset,
        filter,
        (context) ~>
          getWatermark(context, request.viewName, request.ignoreSource)
        ,
      );
      writer.write(key, SKStore.IntFile(sessionID))
    },
  );
  (input, output)
}

fun updateIsFromIgnoredSource(
  ignoredSrc: SKStore.Source,
  rows: Array<
    (SKStore.Tick, SKStore.Source, SKStore.Source, Array<SKStore.File>),
  >,
): Bool {
  maxTick = SKStore.Tick(0);
  singleNonTomb: ?(SKStore.Tick, SKStore.Source) = None();

  for ((tick, _origSrc, src, files) in rows) {
    !maxTick = max(maxTick, tick);

    if (!files.isEmpty()) {
      // more than one non-tomb cannot be a replication update
      if (singleNonTomb is Some _) return false;
      !singleNonTomb = Some((tick, src));
    };
  };

  singleNonTomb match {
  | None() -> // all are tombs
    rows.all(row -> {
      (tick, _, src, _) = row;
      tick != maxTick || src == ignoredSrc
    })
  | Some((tick, src)) -> tick == maxTick && src == ignoredSrc
  }
}

/*****************************************************************************/
/* Indexes. */
/*****************************************************************************/

extension class Index extends SKStore.File

class IndexDescr{
  tableName: Name,
  tableDirName: SKStore.DirName,
  fields: Array<(Int, IKind, Type)>,
  unique: Bool,
  primary: Bool,
  text: ?String,
} extends SKStore.File, Descr uses Orderable {
  fun compare(y: IndexDescr): Order {
    this.name.compare(y.name)
  }
}

fun getIndexInputDir(context: mutable SKStore.Context): SKStore.EHandle<Index> {
  makeDir(Index::fromFile, context, indexInput, () ->
    context.mkdir(Index::fromFile, indexInput, Array[])
  )
}

fun getIndexOutputDir(
  context: mutable SKStore.Context,
): SKStore.EHandle<IndexDescr> {
  input = getIndexInputDir(context);
  makeDir(IndexDescr::fromFile, context, indexOutput, () -> {
    input.contextMap(
      IndexDescr::fromFile,
      context,
      indexOutput,
      (context, index) ~> {
        createUserIndex(
          context,
          index.name,
          index.pos,
          index.fields,
          index.unique,
          index.primary,
          index.text,
        )
      },
    )
  })
}

fun makeIndexEntry(tableName: Name, colNbr: Int): SKStore.SID {
  SKStore.SID::create(tableName.lower + ":" + colNbr);
}

fun getIndexByColNbr(
  context: mutable SKStore.Context,
): SKStore.EHandle<IndexDescr> {
  indexes = getIndexOutputDir(context);
  makeDir(IndexDescr::fromFile, context, indexByCol, () -> {
    indexes.contextWriterKeyValues(
      IndexDescr::fromFile,
      context,
      indexByCol,
      (_context, writer, _key, values) ~> {
        indexDescr = values[0];
        for (field in indexDescr.fields) {
          fieldNbr = field.i0;
          indexEntry = makeIndexEntry(indexDescr.tableName, fieldNbr);
          writer.write(indexEntry, indexDescr)
        }
      },
    )
  })
}

fun getIndexByName(
  context: mutable SKStore.Context,
): SKStore.EHandle<IndexDescr> {
  indexes = getIndexOutputDir(context);
  makeDir(IndexDescr::fromFile, context, indexByCol, () -> {
    indexes.contextWriterKeyValues(
      IndexDescr::fromFile,
      context,
      indexByCol,
      (_context, writer, _key, values) ~> {
        indexDescr = values[0];
        writer.write(SKStore.SID(indexDescr.tableName.lower), indexDescr)
      },
    )
  })
}

/*****************************************************************************/
/* Tables. */
/*****************************************************************************/

fun getTable(context: mutable SKStore.Context, pos: Int, name: Name): DirDescr {
  sid = SKStore.SID::create(name.lower);
  tableDir = getTableDir(context);
  tableDir.maybeGet(context, sid) match {
  | None() ->
    hviews = getViewsDir(context);
    viewsDir = context.unsafeGetEagerDir(hviews.dirName);
    viewArray = viewsDir.getArrayRaw(SKStore.SID(name.lower));
    if (viewArray.size() == 0) {
      error(pos, "Table '" + name + "' does not exist")
    } else {
      view = viewArray[0];
      selectFile = SelectFile::fromFile(view);
      dirName = SKStore.DirName::create("/" + selectFile.cselect.id + "/");
      cselect = selectFile.cselect;
      dirDescr = SKDB.Compiler::getDirDescr(
        selectFile.sparams,
        cselect.from,
        cselect.params,
        cselect.id,
        dirName,
      );
      if (!selectFile.virtual) {
        _ = evalSelect(context, cselect, None());
      };
      dirDescr
    }
  | Some(dirDescr) -> getLatestDirDescr(context, dirDescr)
  }
}

/*****************************************************************************/
/* DUMP. */
/*****************************************************************************/

fun printDirDescr(dirDescr: DirDescr, suffix: ?String): void {
  o = print_raw;
  o("CREATE ");
  o("TABLE ");
  o(dirDescr.name.origName);
  suffix match {
  | None() -> void
  | Some(x) -> o(x)
  };
  o(" (\n");
  for (colName in dirDescr.colNames) {
    colIndex = dirDescr.cols[colName];
    o("  ");
    o(colName.origName);
    o(" ");
    ty = dirDescr.schema[colIndex];
    o(
      ty.ty match {
      | INTEGER() -> "INTEGER"
      | FLOAT() -> "FLOAT"
      | TEXT() -> "TEXT"
      },
    );
    if (ty.unique) {
      o(" UNIQUE");
    };
    if (ty.primary) {
      o(" PRIMARY KEY");
    };
    if (ty.notNull) {
      o(" NOT NULL");
    };
    ty.default match {
    | None() -> void
    | Some(expr) ->
      expr match {
      | VNull() -> void
      | VInt(x) -> o(` DEFAULT ${x.toString()}`)
      | VFloat(x) -> o(` DEFAULT ${x.toString()}`)
      | VString(s) ->
        o(` DEFAULT `);
        escapeString(o, s)
      | VId(_, _) -> invariant_violation("Invalid expression for default value")
      | VTime() -> invariant_violation("Invalid expression for default value")
      | VParam(_) -> invariant_violation("Invalid expression for default value")
      }
    };
    if (colIndex < dirDescr.schema.size() - 1) {
      o(",");
    };
    o("\n");
  };
  o(");\n");
  flushStdout();
}

fun dumpTable(
  origContext: readonly SKStore.Context,
  tableName: String,
  suffix: ?String,
): void {
  context = SKStore.Context::fromSaved(origContext.clone());
  getTableDir(context).maybeGet(context, SKStore.SID(tableName)) match {
  | None() -> void
  | Some(dirDescr) -> printDirDescr(dirDescr, suffix)
  }
}

fun dumpTables(origContext: readonly SKStore.Context, suffix: ?String): void {
  context = SKStore.Context::fromSaved(origContext.clone());
  handle = getTableDir(context);
  sinkName = SKStore.DirName::create("/sink_" + SKStore.genSym(0) + "/");
  _ = handle.contextMap(handle.conv, context, sinkName, (context, dirDescr) ~> {
    if (!dirDescr.isInput) return dirDescr;
    printDirDescr(dirDescr, suffix);
    for (indexDescr in getIndexByName(context).getArray(
      context,
      SKStore.SID(dirDescr.dirName.toString()),
    )) {
      indexDescr.text match {
      | None() -> void
      | Some(text) -> print_string(text + ";")
      }
    };
    dirDescr
  });
}

fun dumpInserts(origContext: readonly SKStore.Context): void {
  context = SKStore.Context::fromSaved(origContext.clone());
  handle = getTableDir(context);
  sinkName = SKStore.DirName::create("/sink_" + SKStore.genSym(0) + "/");
  _ = handle.contextMap(handle.conv, context, sinkName, (context, dirDescr) ~> {
    if (!dirDescr.isInput) return dirDescr;
    o = print_raw;
    fileIter = context.unsafeGetEagerDir(dirDescr.dirName).unsafeGetFileIter();
    count = 1;
    o("BEGIN TRANSACTION;\n");
    for (kv in fileIter) {
      if (count % 1024 == 0) {
        o("COMMIT;\n");
        o("BEGIN TRANSACTION;\n");
      };
      (_, files) = kv;
      for (file in files) {
        row = RowValues::fromFile(file);
        for (_ in Range(0, row.repeat)) {
          o("INSERT INTO " + dirDescr.name + " VALUES ");
          o(row.toString());
          o(";\n");
          !count = count + 1;
        };
      };
    };
    o("COMMIT;\n");
    flushStdout();
    dirDescr
  });
}

fun dumpView(origContext: readonly SKStore.Context, viewName: String): void {
  context = SKStore.Context::fromSaved(origContext.clone());
  hviews = getViewsDir(context);
  viewsDir = context.unsafeGetEagerDir(hviews.dirName);
  arr = viewsDir.getArrayRaw(SKStore.SID(viewName));
  if (arr.size() == 0) {
    return void
  };
  invariant(arr.size() == 1);
  print_raw(SelectFile::fromFile(arr[0]).text);
  print_raw(";\n");
  flushStdout();
}

fun dumpViews(origContext: readonly SKStore.Context): void {
  context = SKStore.Context::fromSaved(origContext.clone());
  handle = getViewsDir(context);
  sinkName = SKStore.DirName::create("/sink_" + SKStore.genSym(0) + "/");
  sortedName = SKStore.DirName::create("/sorted_" + SKStore.genSym(0) + "/");
  sorted = handle.contextWriterKeyValues(
    handle.conv,
    context,
    sortedName,
    (_context, writer, _key, values) ~> {
      for (selectFile in values) {
        writer.write(SKStore.IID(selectFile.tick), selectFile)
      }
    },
  );
  _ = sorted.contextWriterKeyIter(
    sorted.conv,
    context,
    sinkName,
    (context, _writer, _key, views) ~> {
      o = print_raw;
      for (view in views) {
        o(view.text);
        o(";\n");
        for (indexDescr in getIndexByName(context).getArray(
          context,
          SKStore.SID(view.name.lower),
        )) {
          indexDescr.text match {
          | None() -> void
          | Some(text) -> o(text + ";\n")
          }
        };
      };
      flushStdout();
    },
  );
}

/*****************************************************************************/
/* File used for globals. */
/*****************************************************************************/

const GLOBALS: String = "GLOBALS";

class Globals(map: SortedMap<String, Int> = SortedMap[]) extends SKStore.File {
  fun set(var: String, val: Int): this {
    !this.map[var] = val;
    this
  }
  fun containsKey(var: String): Bool {
    this.map.containsKey(var)
  }
  fun get(var: String): Int {
    this.map[var]
  }
  fun maybeGet(var: String): ?Int {
    this.map.maybeGet(var)
  }
}
