/*****************************************************************************/
/* SQL tables.*/
/*****************************************************************************/

module SKSQL;

const tableInfo: SKFS.DirName = SKFS.DirName::create("/tablesInfo/");
const views: SKFS.DirName = SKFS.DirName::create("/views/");
const subsInput: SKFS.DirName = SKFS.DirName::create("/subsInput/");
const subsOutput: SKFS.DirName = SKFS.DirName::create("/subsOutput/");
const indexInput: SKFS.DirName = SKFS.DirName::create("/indexInput/");
const indexOutput: SKFS.DirName = SKFS.DirName::create("/indexOutput/");
const indexByCol: SKFS.DirName = SKFS.DirName::create("/indexByCol/");
const watermarks: SKFS.DirName = SKFS.DirName::create("/watermarks/");

fun getWatermark(
  context: readonly SKFS.Context,
  tableName: String,
  replicationSource: ?Int,
): ?SKFS.Tick {
  replicationSource match {
  | None() -> None()
  | Some(source) ->
    context.unsafeMaybeGetDir(watermarks) match {
    | None() -> None()
    | Some(d) ->
      key = SKFS.SID::create(`${tableName}_${source}`);
      arr = d.getArrayRaw(key);
      if (arr.size() > 0) Some(SKFS.TickFile::fromFile(arr[0]).value) else {
        None()
      }
    }
  }
}

fun setWatermark(
  context: mutable SKFS.Context,
  tableName: String,
  replicationSource: Int,
  checkpointTick: SKFS.Tick,
): void {
  watermarkDir = context.maybeGetDir(watermarks) match {
  | None() -> context.mkdir(SKFS.TickFile::fromFile, watermarks, false)
  | Some(d) -> SKFS.EHandle(SKFS.TickFile::fromFile, d.getDirName())
  };
  key = SKFS.SID::create(`${tableName}_${replicationSource}`);
  mark = watermarkDir
    .unsafeGetArray(context, key)
    .reduce(max, SKFS.TickFile(checkpointTick));
  watermarkDir.writeArray(context, key, Array[mark]);
}

extension class TypeDescr extends SKFS.File

class DirDescr{
  colNames: Array<Name>,
  schema: Array<TypeDescr>,
  kinds: Array<(Int, IKind, Type)>,
  cols: Map<Name, Int>,
  alias: ?Name,
  windowSize: ?Int,
  isInput: Bool,
} extends SKFS.File, Descr uses Orderable {
  fun compare(y: DirDescr): Order {
    this.name.compare(y.name)
  }

  static fun create{
    name: Name,
    schema: Array<TypeDescr>,
    dirName: SKFS.DirName,
    alias: ?Name,
    windowSize: ?Int,
    isInput: Bool,
  }: this {
    cols = mutable Map[];
    colNames = schema.map(x -> x.name);
    for (i => ty in schema) {
      cols![ty.name] = i;
    };
    static{
      name,
      colNames,
      schema,
      kinds => schema.mapWithIndex((idx, ty) -> (idx, IASC(), ty.ty)),
      cols => cols.chill(),
      dirName,
      alias,
      windowSize,
      isInput,
    }
  }
}

fun makeSelectName(id: String): SKFS.DirName {
  SKFS.DirName::create("/" + id + "/");
}

fun getDir(dirDescr: DirDescr): SKFS.EHandle<Row> {
  SKFS.EHandle(RowValues::fromFile, dirDescr.dirName)
}

fun makeDir<T: frozen>(
  fromFile: SKFS.File ~> T,
  context: mutable SKFS.Context,
  dirName: SKFS.DirName,
  make: () -> SKFS.EHandle<T>,
): SKFS.EHandle<T> {
  context.maybeGetDir(dirName) match {
  | None() -> make()
  | Some(dir) -> SKFS.EHandle(fromFile, dir.getDirName())
  };
}

fun getTableDir(context: mutable SKFS.Context): SKFS.EHandle<DirDescr> {
  makeDir(DirDescr::fromFile, context, tableInfo, () -> {
    context.mkdir(DirDescr::fromFile, tableInfo, false, Array[])
  })
}

/*****************************************************************************/
/* Getting the latest directory descriptor.
 *
 * Sometimes, we have to do physical copies of SQL tables or directories.
 * This will happen when we are dealing with a transaction that is both
 * reading and writing to the same table.
 *
 * For example:
 * begin transaction;
 *   delete from t1;
 *   insert into t1 ...
 * commit;
 *
 * You can guess what the problem here is. Because t1 is reactive, that means
 * that the delete statement will delete anything added to t1. The solution
 * is simple, the version that t1 inserts into is not the same than the one
 * we delete from. To keep track of the different version of table we have
 * a global called TableMap.
 *
 * At commit time, under the global lock, the different versions are thrown
 * away, and only the result is copied into the real time.
 */
/*****************************************************************************/

value class Version(value: Int) uses Orderable

class TableMap{
  startTick: SKFS.Tick,
  version: Version,
  map: SortedMap<SKFS.BaseName, (Version, Descr)>,
} extends SKFS.File

fun dirDescrCopy(
  context: mutable SKFS.Context,
  dirName: SKFS.DirName,
  tableName: String,
  version: Version,
): SKFS.DirName {
  oldDir = context.unsafeGetEagerDir(dirName);
  nextName = SKFS.DirName::create(
    "/next/" + tableName + "/" + version.value + "/",
  );
  sinkName = SKFS.DirName::create(
    "/sink/" + tableName + "/" + version.value + "/",
  );
  dir = SKFS.EagerDir{
    time => context.timeStamp(),
    dirName => nextName,
    input => true,
    fixedData => oldDir.fixedData,
    data => oldDir.data,
    totalSize => oldDir.totalSize,
    creator => context.currentArrow(),
    reallyRemove => false,
  };
  context.setDir(dir.dirName, dir);
  limit = context.tick;
  _ = SKFS.EagerDir::apply(
    context,
    dirName,
    sinkName,
    (context, _writer, key, _valueIter) ~> {
      entries = mutable Vector[];
      for (srcValue in (context.unsafeGetEagerDir(
        dirName,
      )).unsafeGetAllDataIterAfter(limit, key)) {
        (_, source, writer, values) = srcValue;
        entries.push((key, (source.path(), writer.path(), values)));
      };
      inputDir = context.unsafeGetEagerDir(nextName);
      inputDir.writeArraySourceMany(context, entries.iterator());
    },
    None(),
    None(),
    true,
  );
  nextName
}

base class Descr{name: Name, dirName: SKFS.DirName} {}

fun getLatestDescr(context: mutable SKFS.Context, descr: Descr): Descr {
  baseName = SKFS.SID(descr.name.lower);
  context.getGlobal("TableMap") match {
  | None() -> descr
  | Some(tableMapFile) ->
    tableMap = TableMap::fromFile(tableMapFile);
    oldDescr = tableMap.map.maybeGet(baseName) match {
    | None() -> descr
    | Some((version, oldDescr)) if (version == tableMap.version) ->
      return oldDescr
    | Some((_, x)) -> x
    };
    nextName = dirDescrCopy(
      context,
      oldDescr.dirName,
      descr.name.origName,
      tableMap.version,
    );
    result = descr with {dirName => nextName};
    !tableMap.map[baseName] = (tableMap.version, result);
    context.setGlobal("TableMap", tableMap);
    result
  }
}

fun getLatestDirDescr(
  context: mutable SKFS.Context,
  dirDescr: DirDescr,
): DirDescr {
  getLatestDescr(context, dirDescr) match {
  | IndexDescr _ -> invariant_violation("Was not expecting an index")
  | x @ DirDescr _ -> x
  }
}

fun getLatestIndexDescr(
  context: mutable SKFS.Context,
  indexDescr: IndexDescr,
): IndexDescr {
  getLatestDescr(context, indexDescr) match {
  | DirDescr _ -> invariant_violation("Was not expecting a table")
  | x @ IndexDescr _ -> x
  }
}

/*****************************************************************************/
/* Sharding stats for joins. */
/*****************************************************************************/

class ShardStats(tick: SKFS.Tick, left: Int, right: Int) extends SKFS.File

/*****************************************************************************/
/* Views. */
/*****************************************************************************/

fun getViewsDir(context: mutable SKFS.Context): SKFS.EHandle<SelectFile> {
  makeDir(SelectFile::fromFile, context, views, () ->
    context.mkdir(SelectFile::fromFile, views, false, Array[])
  )
}

/*****************************************************************************/
/* Subscriptions. */
/*****************************************************************************/

class SubRequestFile(
  viewName: String,
  viewDirName: SKFS.DirName,
  init: Bool,
  cmd: SKFS.CmdKind,
  sessionID: Int,
  user: ?String,
  ignoreSource: ?Int,
) extends SKFS.File

fun getSubsDirs(
  options: Options,
  context: mutable SKFS.Context,
): (SKFS.EHandle<SubRequestFile>, SKFS.EHandle<SKFS.IntFile>) {
  if (context.unsafeMaybeGetEagerDir(subsInput) is Some _) {
    input = SKFS.EHandle(SubRequestFile::fromFile, subsInput);
    output = SKFS.EHandle(SKFS.IntFile::fromFile, subsOutput);
    return (input, output)
  };
  input = context.mkdir(SubRequestFile::fromFile, subsInput, false, Array[]);
  output = input.contextWriterKeyValues(
    SKFS.IntFile::fromFile,
    context,
    subsOutput,
    (context, writer, key, values) ~> {
      request = SubRequestFile::fromFile(values[0]);
      viewName = request.viewName;
      cmd = request.cmd;
      init = request.init;
      sessionID = request.sessionID;
      tableDir = getTableDir(context);
      (edir, dirDescr) = tableDir.maybeGet(
        context,
        SKFS.SID(request.viewName),
      ) match {
      | None() ->
        views = SKSQL.getViewsDir(context);
        viewsDir = context.unsafeGetEagerDir(views.dirName);
        selectFiles = viewsDir.getArrayRaw(SKFS.SID(viewName.toString()));
        invariant(selectFiles.size() <= 1);
        if (selectFiles.size() == 0) {
          print_error(`Error: view ${viewName.toString()} doesn't exists`);
          skipExit(3)
        };
        selectFile = SKSQL.SelectFile::fromFile(selectFiles[0]);
        if (!selectFile.virtual) {
          print_error("Error: can only connect to virtual views");
          skipExit(23);
        };
        selectAst = selectFile.value;
        compiler = SKSQL.Compiler::create(
          false,
          options with {virtual => true},
          selectAst.pos,
        );
        cselect = compiler.compileSelect(context, selectAst, true);
        selectDir = SKSQL.evalSelect(context, cselect, None());
        edir = context.unsafeGetEagerDir(selectDir.dirName);
        dirDescr = Compiler::getDirDescr(
          selectAst.params,
          cselect.from,
          cselect.params,
          Name::create(selectDir.dirName.toString()),
          selectDir.dirName,
        );
        (edir, dirDescr)
      | Some(dirDescr) ->
        edir = context.unsafeGetEagerDir(dirDescr.dirName);
        (edir, dirDescr)
      };
      reset = request.user match {
      | None() -> (_, _) ~> false
      | Some(userName) ->
        userFile = SKSQL.UserFile::create(context, userName);
        (context: SKFS.Context, tick: SKFS.Tick) ~> {
          readers = context.unsafeGetEagerDir(SKFS.accessReaders);
          (isReset, changes) = readers.getChangesAfter(tick);
          if (isReset) return true;
          for (rowKey in changes) {
            rowKey match {
            | RowKey(row, _) ->
              if (row.getInt(1).fromSome() == userFile.id) {
                return true
              }
            | _ -> invariant_violation("Unexpected key type")
            }
          };
          false
        }
      };
      (userFile, matchesGroup, accessFilter) = request.user match {
      | None() -> (None(), (_ ~> 0), ((_, _) ~> (_ ~> true)))
      | Some(userName) ->
        userFile = SKSQL.UserFile::create(context, userName);
        dirDescr.cols.maybeGet(skdbAccess) match {
        | None() -> (Some(userFile.id), _ ~> 0, (_, _) ~> _ -> true)
        | Some(accessColNbr) ->
          if (!(dirDescr.schema[accessColNbr].ty is INTEGER())) {
            print_error("skdb_access must be of type integer");
            skipExit(2)
          };
          (
            Some(userFile.id),
            ((file: SKFS.BaseName) ~> {
              file match {
              | k @ RowKey _ ->
                k.row.getInt(accessColNbr) match {
                | None() -> 0
                | Some(gid) -> gid
                }
              | _ -> 0
              }
            }),
            ((context, _isReset) ~> {
              access = mutable AccessSolver(userFile.id);
              (file: SKFS.BaseName) -> {
                file match {
                | k @ RowKey _ ->
                  k.row.getInt(accessColNbr) match {
                  | None() -> true
                  | Some(accessID) -> access.canRead(context, accessID)
                  }
                | _ -> true
                }
              }
            }),
          )
        }
      };
      filter = request.ignoreSource match {
      | None() -> accessFilter
      | Some(inputSrc) ->
        (context, isReset) ~> {
          if (isReset) return accessFilter(context, isReset);
          tdir = context.unsafeGetEagerDir(dirDescr.dirName);
          ignoredSrc = SKFS.Source::create(
            SKFS.Path(dirDescr.dirName, SKFS.IID(inputSrc)),
          );
          composedFilter = accessFilter(context, isReset);
          (file: SKFS.BaseName) -> {
            rows = tdir.getAllDataIter(context.mclone(), file).collect(Array);
            !updateIsFromIgnoredSource(ignoredSrc, rows) && composedFilter(file)
          }
        }
      };
      context.subscribe(
        context,
        edir.dirName,
        sessionID,
        cmd,
        init,
        userFile,
        reset,
        matchesGroup,
        filter,
        (context) ~>
          getWatermark(context, request.viewName, request.ignoreSource)
        ,
      );
      writer.write(key, SKFS.IntFile(sessionID))
    },
  );
  (input, output)
}

fun updateIsFromIgnoredSource(
  ignoredSrc: SKFS.Source,
  rows: Array<(SKFS.Tick, SKFS.Source, SKFS.Source, Array<SKFS.File>)>,
): Bool {
  maxTick = SKFS.Tick(0);
  singleNonTomb: ?(SKFS.Tick, SKFS.Source) = None();

  for ((tick, _origSrc, src, files) in rows) {
    !maxTick = max(maxTick, tick);

    if (!files.isEmpty()) {
      // more than one non-tomb cannot be a replication update
      if (singleNonTomb is Some _) return false;
      !singleNonTomb = Some((tick, src));
    };
  };

  singleNonTomb match {
  | None() -> // all are tombs
    rows.all(row -> {
      (tick, _, src, _) = row;
      tick != maxTick || src == ignoredSrc
    })
  | Some((tick, src)) -> tick == maxTick && src == ignoredSrc
  }
}

/*****************************************************************************/
/* Indexes. */
/*****************************************************************************/

extension class Index extends SKFS.File

class IndexDescr{
  tableName: Name,
  tableDirName: SKFS.DirName,
  fields: Array<(Int, IKind, Type)>,
  unique: Bool,
  text: ?String,
} extends SKFS.File, Descr uses Orderable {
  fun compare(y: IndexDescr): Order {
    this.name.compare(y.name)
  }
}

fun getIndexInputDir(context: mutable SKFS.Context): SKFS.EHandle<Index> {
  makeDir(Index::fromFile, context, indexInput, () ->
    context.mkdir(Index::fromFile, indexInput, false, Array[])
  )
}

fun getIndexOutputDir(
  options: Options,
  context: mutable SKFS.Context,
): SKFS.EHandle<IndexDescr> {
  input = getIndexInputDir(context);
  makeDir(IndexDescr::fromFile, context, indexOutput, () -> {
    input.contextMap(
      IndexDescr::fromFile,
      context,
      indexOutput,
      (context, index) ~> {
        createUserIndex(
          options,
          context,
          index.name,
          index.pos,
          index.fields,
          index.unique,
          index.text,
        )
      },
    )
  })
}

fun makeIndexEntry(tableName: SKFS.DirName, colNbr: Int): SKFS.SID {
  SKFS.SID::create(tableName.toString() + ":" + colNbr);
}

fun getIndexByColNbr(
  options: Options,
  context: mutable SKFS.Context,
): SKFS.EHandle<IndexDescr> {
  indexes = getIndexOutputDir(options, context);
  makeDir(IndexDescr::fromFile, context, indexByCol, () -> {
    indexes.contextWriterMap(
      IndexDescr::fromFile,
      context,
      indexByCol,
      (_context, writer, indexDescr) ~> {
        for (field in indexDescr.fields) {
          fieldNbr = field.i0;
          indexEntry = makeIndexEntry(indexDescr.tableDirName, fieldNbr);
          writer.write(indexEntry, indexDescr)
        }
      },
    )
  })
}

fun getIndexByName(
  options: Options,
  context: mutable SKFS.Context,
): SKFS.EHandle<IndexDescr> {
  indexes = getIndexOutputDir(options, context);
  makeDir(IndexDescr::fromFile, context, indexByCol, () -> {
    indexes.contextWriterMap(
      IndexDescr::fromFile,
      context,
      indexByCol,
      (_context, writer, indexDescr) ~> {
        writer.write(SKFS.SID(indexDescr.tableName.lower), indexDescr)
      },
    )
  })
}

/*****************************************************************************/
/* Tables. */
/*****************************************************************************/

fun getTable(
  options: Options,
  context: mutable SKFS.Context,
  pos: Int,
  name: Name,
): DirDescr {
  sid = SKFS.SID::create(name.lower);
  tableDir = getTableDir(context);
  tableDir.maybeGet(context, sid) match {
  | None() ->
    hviews = getViewsDir(context);
    viewsDir = context.unsafeGetEagerDir(hviews.dirName);
    viewArray = viewsDir.getArrayRaw(SKFS.SID(name.lower));
    if (viewArray.size() == 0) {
      error(pos, "Table '" + name + "' does not exist")
    } else {
      view = viewArray[0];
      selectFile = SelectFile::fromFile(view);
      dirName = SKFS.DirName::create("/" + selectFile.value.id + "/");
      compiler = SKSQL.Compiler::create(false, options, pos);
      cselect = compiler.compileSelect(context, selectFile.value, true);
      dirDescr = SKSQL.Compiler::getDirDescr(
        selectFile.value.params,
        cselect.from,
        cselect.params,
        cselect.id,
        dirName,
      );
      if (!selectFile.virtual) {
        _ = evalSelect(context, cselect, None());
      };
      dirDescr
    }
  | Some(dirDescr) -> getLatestDirDescr(context, dirDescr)
  }
}

/*****************************************************************************/
/* DUMP. */
/*****************************************************************************/

fun printDirDescr(dirDescr: DirDescr, suffix: ?String): void {
  o = print_raw;
  o("CREATE ");
  o(
    dirDescr.windowSize match {
    | None() -> "TABLE "
    | Some(0) -> "STREAM " + " "
    | Some(size) -> "WINDOW " + size + " "
    },
  );
  o(dirDescr.name.origName);
  suffix match {
  | None() -> void
  | Some(x) -> o(x)
  };
  o(" (\n");
  for (colName in dirDescr.colNames) {
    colIndex = dirDescr.cols[colName];
    o("  ");
    o(colName.origName);
    o(" ");
    ty = dirDescr.schema[colIndex];
    o(
      ty.ty match {
      | INTEGER() -> "INTEGER"
      | FLOAT() -> "FLOAT"
      | TEXT() -> "TEXT"
      },
    );
    if (ty.unique) {
      o(" UNIQUE");
    };
    if (ty.primary) {
      o(" PRIMARY KEY");
    };
    if (ty.notNull) {
      o(" NOT NULL");
    };
    ty.default match {
    | None() -> void
    | Some(expr) ->
      expr match {
      | VNull() -> void
      | VInt(x) -> o(` DEFAULT ${x.toString()}`)
      | VFloat(x) -> o(` DEFAULT ${x.toString()}`)
      | VString(s) ->
        o(` DEFAULT `);
        escapeString(o, s)
      | VLShift(_, _) ->
        invariant_violation("Invalid expression for default value")
      | VId(_, _) -> invariant_violation("Invalid expression for default value")
      | VTime() -> invariant_violation("Invalid expression for default value")
      }
    };
    if (colIndex < dirDescr.schema.size() - 1) {
      o(",");
    };
    o("\n");
  };
  o(");\n");
  flushStdout();
}

fun dumpTable(
  origContext: readonly SKFS.Context,
  tableName: String,
  suffix: ?String,
): void {
  context = SKFS.Context::fromSaved(origContext.clone());
  getTableDir(context).maybeGet(context, SKFS.SID(tableName)) match {
  | None() -> void
  | Some(dirDescr) -> printDirDescr(dirDescr, suffix)
  }
}

fun dumpTables(
  options: Options,
  origContext: readonly SKFS.Context,
  suffix: ?String,
): void {
  context = SKFS.Context::fromSaved(origContext.clone());
  handle = getTableDir(context);
  sinkName = SKFS.DirName::create("/sink_" + SKFS.genSym(0) + "/");
  _ = handle.contextMap(handle.conv, context, sinkName, (context, dirDescr) ~> {
    if (!dirDescr.isInput) return dirDescr;
    printDirDescr(dirDescr, suffix);
    for (indexDescr in getIndexByName(options, context).getArray(
      context,
      SKFS.SID(dirDescr.dirName.toString()),
    )) {
      indexDescr.text match {
      | None() -> void
      | Some(text) -> print_string(text + ";")
      }
    };
    dirDescr
  });
}

fun dumpInserts(origContext: readonly SKFS.Context): void {
  context = SKFS.Context::fromSaved(origContext.clone());
  handle = getTableDir(context);
  sinkName = SKFS.DirName::create("/sink_" + SKFS.genSym(0) + "/");
  _ = handle.contextMap(handle.conv, context, sinkName, (context, dirDescr) ~> {
    if (!dirDescr.isInput) return dirDescr;
    o = print_raw;
    fileIter = context.unsafeGetEagerDir(dirDescr.dirName).unsafeGetFileIter();
    count = 1;
    o("BEGIN TRANSACTION;\n");
    for (kv in fileIter) {
      if (count % 1024 == 0) {
        o("COMMIT;\n");
        o("BEGIN TRANSACTION;\n");
      };
      (_, files) = kv;
      for (file in files) {
        row = RowValues::fromFile(file);
        for (_ in Range(0, row.repeat)) {
          o("INSERT INTO " + dirDescr.name + " VALUES ");
          o(row.toString());
          o(";\n");
          !count = count + 1;
        };
      };
    };
    o("COMMIT;\n");
    flushStdout();
    dirDescr
  });
}

fun dumpView(origContext: readonly SKFS.Context, viewName: String): void {
  context = SKFS.Context::fromSaved(origContext.clone());
  hviews = getViewsDir(context);
  viewsDir = context.unsafeGetEagerDir(hviews.dirName);
  arr = viewsDir.getArrayRaw(SKFS.SID(viewName));
  if (arr.size() == 0) {
    return void
  };
  invariant(arr.size() == 1);
  print_raw(SelectFile::fromFile(arr[0]).text);
  print_raw(";\n");
  flushStdout();
}

fun dumpViews(options: Options, origContext: readonly SKFS.Context): void {
  context = SKFS.Context::fromSaved(origContext.clone());
  handle = getViewsDir(context);
  sinkName = SKFS.DirName::create("/sink_" + SKFS.genSym(0) + "/");
  sortedName = SKFS.DirName::create("/sorted_" + SKFS.genSym(0) + "/");
  sorted = handle.contextWriterKeyValues(
    handle.conv,
    context,
    sortedName,
    (_context, writer, _key, values) ~> {
      for (selectFile in values) {
        writer.write(SKFS.IID(selectFile.tick), selectFile)
      }
    },
  );
  _ = sorted.contextWriterKeyIter(
    sorted.conv,
    context,
    sinkName,
    (context, _writer, _key, views) ~> {
      o = print_raw;
      for (view in views) {
        o(view.text);
        o(";\n");
        for (indexDescr in getIndexByName(options, context).getArray(
          context,
          SKFS.SID(view.name.lower),
        )) {
          indexDescr.text match {
          | None() -> void
          | Some(text) -> o(text + ";\n")
          }
        };
      };
      flushStdout();
    },
  );
}

/*****************************************************************************/
/* File used for globals. */
/*****************************************************************************/

const GLOBALS: String = "GLOBALS";

class Globals(map: SortedMap<String, Int> = SortedMap[]) extends SKFS.File {
  fun set(var: String, val: Int): this {
    !this.map[var] = val;
    this
  }
  fun containsKey(var: String): Bool {
    this.map.containsKey(var)
  }
  fun get(var: String): Int {
    this.map[var]
  }
  fun maybeGet(var: String): ?Int {
    this.map.maybeGet(var)
  }
}
