/*****************************************************************************/
/* SQL SELECT */
/*****************************************************************************/

module SKSQL;

type MapFunRow = (
  mutable SKFS.Context,
  mutable SKFS.Writer,
  SKFS.BaseName,
  mutable Iterator<SKSQL.Row>,
) ~> void;

class SubTask(
  name: String,
  key: SKFS.BaseName,
  inputRow: Row,
  entries: List<Row>,
  remainingTables: List<(SKSQL.DirDescr, ?Array<SKFS.KeyRange>)>,
)

class KVFile(value: (SKFS.BaseName, Array<SKFS.File>)) extends SKFS.File

class ProjKey(
  value: ?CValue,
  leftShard: Int,
  rightShard: Int,
) extends SKFS.BaseName {
  fun toString(): String {
    this.value.toString()
  }
}

class LeftFile(SKFS.BaseName, RowValues) extends SKFS.File
class LeftShardedFile{
  leftShardID: Int,
  rightShard: Int,
  value: RowValues,
} extends SKFS.File

class RightFile(SKFS.BaseName, RowValues) extends SKFS.File
class RightShardedFile{
  leftShard: Int,
  rightShardID: Int,
  value: RowValues,
} extends SKFS.File

/*****************************************************************************/
/* Helper */
/*****************************************************************************/

fun firstRow(rows: mutable Iterator<Row>): ?Row {
  for (row in rows) {
    break Some(row);
  } else {
    None()
  }
}

fun firstRowAsArray(rows: mutable Iterator<Row>): Array<Row> {
  firstRow(rows) match {
  | None() -> Array[]
  | Some(x) -> Array[x]
  }
}

fun firstRowAsArrayRepeat1(rows: mutable Iterator<Row>): Array<Row> {
  firstRow(rows) match {
  | None() -> Array[]
  | Some(x) ->
    Array[
      x match {
      | RowValues(values, _) -> RowValues::create(values, 1)
      | _ -> invariant_violation("Unexpected Row type")
      },
    ]
  }
}

fun initRepeatRow(rows: mutable Iterator<Row>): Array<Row> {
  firstRow(rows) match {
  | None() -> Array[]
  | Some(RowValues(values, n)) ->
    for (row in rows) {
      row match {
      | RowValues(_, r) -> !n = n + r
      | _ -> invariant_violation("Unexpected Row kind")
      }
    };
    Array[RowValues::create(values, n)]
  | _ -> invariant_violation("Unexpected Row kind")
  }
}

fun updateRepeatRow(
  state: Array<Row>,
  remove: Array<Row>,
  adds: Array<Row>,
): ?Array<Row> {
  invariant(state.size() == 1);
  (values, n) = state[0] match {
  | RowValues(values, n) -> (values, n)
  | _ -> invariant_violation("Unexpected state in updateRepeatRow")
  };
  for (row in remove) {
    row match {
    | RowValues(_, r) -> !n = n - r
    | _ -> invariant_violation("Unexpected state in updateRepeatRow")
    }
  };
  for (row in adds) {
    row match {
    | RowValues(_, r) -> !n = n + r
    | _ -> invariant_violation("Unexpected state in updateRepeatRow")
    }
  };
  if (n == 0) Some(Array[]) else Some(Array[RowValues::create(values, n)])
}

// produces the closest power of 2 larger than n
fun pow2(n: Int): Int {
  invariant(n >= 0);
  if (n <= 1) 2 else 2 * pow2(n / 2)
}

fun noop(
  _context: mutable SKFS.Context,
  writer: mutable SKFS.Writer,
  key: SKFS.BaseName,
  valueIter: mutable Iterator<SKFS.File>,
): void {
  writer.writeArray(key, valueIter.collect(Array))
}

/*****************************************************************************/
/* We need to be able to write more than one row per key. */
/*****************************************************************************/

mutable class MultiWriter{
  mutable writes: SortedMap<
    SKFS.BaseName,
    mutable Vector<SKFS.File>,
  > = SortedMap[],
} {
  mutable fun write(key: SKFS.BaseName, value: SKFS.File): void {
    if (!this.writes.containsKey(key)) {
      this.!writes[key] = mutable Vector[];
    };
    this.writes[key].push(value);
  }

  mutable fun writeArray(key: SKFS.BaseName, values: Array<SKFS.File>): void {
    if (!this.writes.containsKey(key)) {
      this.!writes[key] = mutable Vector[];
    };
    this.writes[key].extend(values);
  }
}

/*****************************************************************************/
/* The value returned by the evaluator. */
/*****************************************************************************/

class SelectDir(dirName: SKFS.DirName, types: Array<Type>) extends SKFS.File

/*****************************************************************************/
/* The main entry point. */
/*****************************************************************************/

fun evalSelect(
  context: mutable SKFS.Context,
  select: CSelect,
  up: ?ExprEvaluator,
): SelectDir {
  result = makeSelectEvaluator(select, up).evalSelect(context);
  result
}

fun makeSelectEvaluator(select: CSelect, up: ?ExprEvaluator): SelectEvaluator {
  selectName1 = makeSelectName(
    select.id.lower + if (select.needUp) "_" + hash(up) else "",
  );
  selectName2 = if (select.aggr is Some _) {
    SKFS.DirName::create(selectName1.toString() + "aggrEnv/")
  } else {
    selectName1
  };
  types = select.params.map(x -> x.getType());
  SelectEvaluator{
    select,
    up,
    params => select.params,
    selectName1,
    selectName2,
    kinds => select.kinds,
    types,
  }
}

/*****************************************************************************/
/* The Sql Select evaluator (should only be used by evalSelect). */
/*****************************************************************************/

class SelectEvaluator{
  select: CSelect,
  directMode: ?Int = None(),
  up: ?ExprEvaluator,
  params: Array<CGExpr>,
  selectName1: SKFS.DirName,
  selectName2: SKFS.DirName,
  kinds: Array<(Int, SKSQL.IKind, Type)>,
  types: Array<Type>,
} {
  fun evalStaticInt(context: mutable SKFS.Context, expr: CExpr<Int>): Int {
    emptyEval = ExprEvaluator(None(), Array[], this.select.from, this.up);
    emptyEval.evalCIExpr(context, expr) match {
    | ANull() -> 0
    | ADef(x) -> x
    | AUndef() -> invariant_violation("Unexpected Undef")
    }
  }

  fun evalSelect(context: mutable SKFS.Context): SelectDir {
    if (this.select.directMode) {
      !this.directMode = this.select.limit match {
      | None() -> Some(Int::max)
      | Some(limitExpr) -> Some(this.evalStaticInt(context, limitExpr))
      };
    };
    for (subTask in this.select.other) {
      static::evalSubTask(context, subTask);
    };
    this.select.limit match {
    | None() -> this.evalSelectNoLimit(context)
    | Some(limitExpr) ->
      limitMappedName = this.selectName1;
      limitName = SKFS.DirName::create(this.selectName1.toString() + "limit/");
      !this.selectName1 = SKFS.DirName::create(
        this.selectName1.toString() + "nolimit/",
      );
      !this.selectName2 = SKFS.DirName::create(
        this.selectName2.toString() + "nolimit/",
      );
      limit = this.evalStaticInt(context, limitExpr);
      if (this.select.directMode) {
        this.evalSelectNoLimit(context)
      } else {
        limitDir = context.unsafeMaybeGetEagerDir(limitName) match {
        | None() ->
          h = context.mkdir(Row::fromFile, limitName, false, Array[]);
          context.unsafeGetEagerDir(h.dirName)
        | Some(dir) ->
          context.!newDirs = context.newDirs.set(limitName);
          dir
        };
        selectDir = this.evalSelectNoLimit(context);
        iter = (context.unsafeGetEagerDir(selectDir.dirName)).getIterator(
          context,
        );
        arr = mutable Vector[];
        i = 0;
        while (i < limit) {
          iter.next() match {
          | None() ->
            arr.push(((SKFS.IID(i) : SKFS.BaseName), Array[]));
            !i = i + 1
          | Some((_, fileIter)) ->
            values = fileIter.map(RowValues::fromFile).collect(Array);
            if (values.size() == 0) continue;
            value = values[0];
            repeat = 0;
            for (v in values) {
              !repeat = repeat + v.repeat;
            };
            if (repeat == 0) continue;
            !value = value.setRepeat(repeat);
            arr.push(((SKFS.IID(i) : SKFS.BaseName), Array[value]));
            !i = i + 1
          }
        };
        j = 0;
        arr2 = mutable Vector[];
        source = SKFS.Path::create(limitName, SKFS.IID(0));
        for (elt in arr) {
          (key, values) = elt;
          if (values.size() == 0) {
            arr2.push((key, (source, Array[])))
          } else {
            value = values[0];
            repeat = if (j + value.repeat >= limit) limit - j else value.repeat;
            if (repeat > 0) {
              !value = value.setRepeat(repeat);
              arr2.push((key, (source, Array[(value : SKFS.File)])));
              !j = j + repeat;
            } else {
              arr2.push((key, (source, Array[])));
            }
          }
        };
        limitDir.writeArraySourceMany(context, arr2.iterator());
        kinds = this.kinds;
        SKFS.EagerDir::apply(
          context,
          limitDir.dirName,
          limitMappedName,
          (_context, writer, _key, valueIter) ~> {
            values = valueIter.collect(Array);
            if (values.isEmpty()) return void;
            writer.writeArray(
              RowKey(RowValues::fromFile(values[0]), kinds),
              values,
            );
          },
        );
        SelectDir(limitMappedName, selectDir.types)
      }
    }
  }

  static fun evalSubTask(
    context: mutable SKFS.Context,
    subTask: SubSelectTask,
  ): void {
    subTask match {
    | SubSelect(cselect) -> _ = evalSelect(context, cselect, None())
    | SubMerge{
      leftDirName,
      leftColNbr,
      leftIsUnique => _,
      leftRanges,
      rightDirName,
      rightColNbr,
      rightIsUnique => _,
      rightRanges,
      childName,
      kinds,
      joinKind,
      onlyLeftValues,
    } ->
      leftHandle = SKFS.EHandle(Row::fromFile, leftDirName);
      rightHandle = SKFS.EHandle(Row::fromFile, rightDirName);

      shardsDirName = SKFS.DirName::create(
        childName.toString() + "proj/shards/",
      );
      shards = context.unsafeMaybeGetEagerDir(shardsDirName) match {
      | None() ->
        context.mkdir(ShardStats::fromFile, shardsDirName, false, Array[])
      | Some(x) -> SKFS.EHandle(ShardStats::fromFile, x.dirName)
      };

      projLeftName = SKFS.DirName::create(childName.toString() + "proj/left/");

      SKFS.EagerDir::applyMany(
        context,
        SKFS.FixedSingle::create(
          mutable Vector[
            (leftHandle.dirName, (noop, leftRanges)),
            (shardsDirName, (noop, None())),
          ],
        ),
        projLeftName,
      );

      projRightName = SKFS.DirName::create(
        childName.toString() + "proj/right/",
      );

      SKFS.EagerDir::applyMany(
        context,
        SKFS.FixedSingle::create(
          mutable Vector[
            (rightHandle.dirName, (noop, rightRanges)),
            (shardsDirName, (noop, None())),
          ],
        ),
        projRightName,
      );

      projName = SKFS.DirName::create(childName.toString() + "proj/");

      projLeftFun = (_context, writer, fileKey, valueIter) ~> {
        (rowOpt, shardStats) = normalizeValueIter(valueIter);
        row = rowOpt match {
        | None() -> return void
        | Some(r) -> r
        };
        (leftShard, rightShard) = computeShardSizes(shardStats);
        key = row.getValue(leftColNbr);
        leftShardID = SKFS.genSym(leftShard) % leftShard;
        shardedFile = LeftShardedFile{leftShardID, rightShard, value => row};
        for (i in Range(0, rightShard)) {
          projKey = ProjKey(key, leftShardID, i);
          writer.write(projKey, LeftFile(fileKey, shardedFile.value))
        }
      };

      projRightFun = (_context, writer, fileKey, valueIter) ~> {
        (rowOpt, shardStats) = normalizeValueIter(valueIter);
        row = rowOpt match {
        | None() -> return void
        | Some(r) -> r
        };
        (leftShard, rightShard) = computeShardSizes(shardStats);
        key = row.getValue(rightColNbr);
        rightShardID = SKFS.genSym(rightShard) % rightShard;
        shardedFile = RightShardedFile{leftShard, rightShardID, value => row};
        for (i in Range(0, leftShard)) {
          projKey = ProjKey(key, i, rightShardID);
          writer.write(projKey, RightFile(fileKey, shardedFile.value))
        }
      };

      SKFS.EagerDir::applyMany(
        context,
        SKFS.FixedSingle::create(
          mutable Vector[
            (projLeftName, (projLeftFun, None())),
            (projRightName, (projRightFun, None())),
          ],
        ),
        projName,
      );
      SKFS.EagerDir::applyMany(
        context,
        SKFS.FixedSingle::create(
          mutable Vector[
            (
              projName,
              (
                makeJoinReducer(shards, joinKind, kinds, onlyLeftValues),
                None(),
              ),
            ),
          ],
        ),
        childName,
      )
    };
  }

  fun evalSelectNoLimit(context: mutable SKFS.Context): SelectDir {
    dirName = this.select.aggr match {
    | None() if (this.select.from.size() == 0) ->
      this.evalEmptyFrom(context);
      this.selectName1
    | None() ->
      resultDir = this.evalSelectTableList(
        context,
        List::createFromItems(this.select.from),
        List[],
      );
      resultDir.dirName
    | Some(_) ->
      if (this.select.rest is Some _) {
        invariant_violation("Unexpected select type for aggregate function")
      };
      this.evalAggr(context)
    };
    SelectDir(dirName, this.types)
  }

  fun evalAggr(context: mutable SKFS.Context): SKFS.DirName {
    aggrs = this.select.aggr.fromSome();

    if (this.select.from.size() == 0) {
      if (context.unsafeMaybeGetEagerDir(this.selectName1) is None()) {
        emptyEval = ExprEvaluator(None(), Array[], this.select.from, this.up);
        entry = this.evalRow(context, emptyEval, aggrs.map(y -> y.i1), 1);
        evaluator = ExprEvaluator(
          None(),
          Array[entry],
          this.select.from,
          this.up,
        );
        row = this.evalRow(context, evaluator, this.select.params, 1);
        _dir = context.mkdir(
          Row::fromFile,
          this.selectName1,
          false,
          Array[(SKFS.IID(0), row)],
        );
      } else {
        context.!newDirs = context.newDirs.set(this.selectName1);
      };
      this.selectName1
    } else {
      resultDir = (this with {
        params => aggrs.map(x -> x.i1),
      }).evalSelectTableList(
        context,
        List::createFromItems(this.select.from),
        List[],
      );

      isGlobalAggr =
        aggrs.any(x -> !(x.i0 is Noop())) &&
        this.select.groupBy is None _;

      dataName = if (isGlobalAggr) {
        SKFS.DirName::create(this.selectName1.toString() + "data/");
      } else {
        this.selectName1
      };

      // Case with actual data
      _ = resultDir.contextWriterKeyIter(
        Row::fromFile,
        context,
        dataName,
        (context, writer, key, aggrResult) ~> {
          entry = firstRow(aggrResult) match {
          | None() -> return void
          | Some(x) -> x
          };
          evaluator = ExprEvaluator(
            None(),
            Array[entry],
            this.select.from,
            this.up,
          );
          this.select.having match {
          | None() ->
            row = this.evalRow(context, evaluator, this.select.params, 1);
            writer.write(key, row)
          | Some(cond) ->
            evaluator.evalCIExpr(context, cond) match {
            | ADef(0)
            | ANull() ->
              void
            | AUndef() ->
              invariant_violation("Having should never be undefined")
            | ADef(_) ->
              row = this.evalRow(context, evaluator, this.select.params, 1);
              writer.write(key, row)
            }
          }
        },
      );

      if (isGlobalAggr) {
        selectName1Empty = SKFS.DirName::create(
          this.selectName1.toString() + "empty/",
        );
        if (context.unsafeMaybeGetEagerDir(selectName1Empty) is None()) {
          emptyEntry = RowValues::create(
            aggrs.map(x ->
              x.i0 match {
              | Noop() -> None()
              | Sum(_) -> None()
              | Max() -> None()
              | Min() -> None()
              | Count(_) -> Some(CInt(0))
              }
            ),
          );
          emptyEvaluator = ExprEvaluator(
            None(),
            Array[emptyEntry],
            this.select.from,
            this.up,
          );
          emptyRow = this.evalRow(
            context,
            emptyEvaluator,
            this.select.params,
            1,
          );
          _ = context.mkdir(
            Row::fromFile,
            selectName1Empty,
            false,
            Array[(SKFS.IID(0), emptyRow)],
          );
        } else {
          context.!newDirs = context.newDirs.set(selectName1Empty);
        };

        SKFS.EagerDir::applyMany(
          context,
          SKFS.FixedSingle::create(
            mutable Vector[
              (
                selectName1Empty,
                (
                  (context, writer, key, values) ~> {
                    dataDir = context.unsafeGetEagerDir(dataName);
                    if (dataDir.isEmpty(context)) {
                      writer.writeArray(key, values.collect(Array))
                    }
                  },
                  None(),
                ),
              ),
              (
                dataName,
                (
                  (_context, writer, key, values) ~> {
                    writer.writeArray(key, values.collect(Array))
                  },
                  None(),
                ),
              ),
            ],
          ),
          this.selectName1,
        )
      };
      this.selectName1
    }
  }

  fun evalRow(
    context: mutable SKFS.Context,
    evaluator: ExprEvaluator,
    params: Array<CGExpr>,
    repeat: Int,
  ): RowValues {
    RowValues::create(
      params.map(param ->
        evaluator.evalCGExpr(context, param) match {
        | AUndef() -> invariant_violation("Unexpected undefined value")
        | ANull() -> None()
        | ADef(x) -> Some(x)
        }
      ),
      repeat,
    )
  }

  fun evalEmptyFrom(context: mutable SKFS.Context): void {
    dirName = this.selectName2;
    if (context.unsafeMaybeGetEagerDir(dirName) is None()) {
      evaluator = ExprEvaluator(None(), Array[], this.select.from, this.up);

      whereVal = evaluator.evalWhere(context, this.select.where);
      row = whereVal match {
      | ANull()
      | ADef(0) ->
        this.evalRow(context, evaluator, Array[CGNull()], 1)
      | AUndef()
      | ADef(_) ->
        this.evalRow(context, evaluator, this.select.params, 1)
      };
      _dir = context.mkdir(
        Row::fromFile,
        dirName,
        false,
        Array[(SKFS.IID(0), row)],
      );
    } else {
      context.!newDirs = context.newDirs.set(dirName);
    }
  }

  fun evalSelectTableList(
    context: mutable SKFS.Context,
    tables: List<(DirDescr, ?Array<SKFS.KeyRange>)>,
    entries: List<Row>,
  ): SKFS.EHandle<Row> {
    tables match {
    | List.Nil() -> invariant_violation("empty select")
    | List.Cons(table, remainingTables) ->
      this.evalSelectTable(
        context,

        getDir(table.i0),
        table.i1,
        remainingTables,
        entries,
      )
    }
  }

  fun makeQueryKind(
    queryKind: SKSQL.QueryKind,
    rest: ?(SKSQL.QueryKind, SKSQL.CSelect),
  ): SKSQL.QueryKind {
    isIntersect = false;
    restIter = rest;
    while (!isIntersect && restIter is Some _) {
      !isIntersect = restIter is Some((QIntersect(_), _));
      !restIter = restIter.fromSome().i1.rest;
    };

    isUnionAll = queryKind is QUnion(UAll());
    !restIter = rest;
    while (isUnionAll && restIter is Some _) {
      !isUnionAll = restIter is Some((QUnion(UAll()), _));
      !restIter = restIter.fromSome().i1.rest;
    };

    queryKind match {
    | _ if (isUnionAll) -> QUnion(UAll())
    | QUnion _ if (isIntersect) -> QUnion(UIntersect())
    | QUnion(UAll()) -> QUnion(USingle())
    | QIntersect(_) -> QIntersect(isIntersect)
    | qk -> qk
    }
  }

  fun makeParents(
    dirName: SKFS.DirName,
    rangeOpt: ?Array<SKFS.KeyRange>,
    remainingTables: List<(DirDescr, ?Array<SKFS.KeyRange>)>,
    entries: List<Row>,
  ): SKFS.FixedSingle<SKFS.DirName, (MapFunRow, ?Array<SKFS.KeyRange>)> {
    queryKind = this.select.rest match {
    | None() -> None()
    | Some((QUnion(UAll()), _)) ->
      Some((0, this.makeQueryKind(QUnion(UAll()), this.select.rest)))
    | Some(_) ->
      Some((0, this.makeQueryKind(QUnion(USingle()), this.select.rest)))
    };
    mapFunRow = (ctx, wrt, key, rows) ~> {
      this.evalSelectTableRows(
        queryKind,
        remainingTables,
        entries,
        ctx,
        wrt,
        key,
        rows,
      );
    };
    mparents = mutable Vector[(dirName, (mapFunRow, rangeOpt))];
    order = 1;
    rest = this.select.rest;

    while (rest is Some _) {
      currentOrder = order;
      (qKind, query) = rest.fromSome();
      ev = makeSelectEvaluator(query, this.up);
      rtables = List::createFromItems(query.from);
      (rtable, rremainingTables) = rtables match {
      | List.Nil() -> invariant_violation("Should have been expanded")
      | List.Cons(x, y) -> (x, y)
      };
      rentries = List<Row>[];
      rmapFun: MapFunRow = (ctx, wrt, key, rows) ~> {
        ev.evalSelectTableRows(
          Some((currentOrder, this.makeQueryKind(qKind, query.rest))),
          rremainingTables,
          rentries,
          ctx,
          wrt,
          key,
          rows,
        )
      };
      dirDescr = getDir(rtable.i0);
      mparents.push((dirDescr.dirName, (rmapFun, rtable.i1)));
      !rest = query.rest;
      !order = order + 1
    };
    SKFS.FixedSingle::create(mparents)
  }

  fun evalSelectTable(
    context: mutable SKFS.Context,
    dir: SKFS.EHandle<Row>,
    rangeOpt: ?Array<SKFS.KeyRange>,
    remainingTables: List<(DirDescr, ?Array<SKFS.KeyRange>)>,
    entries: List<Row>,
  ): SKFS.EHandle<Row> {
    parents = this.makeParents(dir.dirName, rangeOpt, remainingTables, entries);
    result = SKFS.EHandle::multiContextWriterKeyIter(
      Row::fromFile,
      context,
      parents,
      this.selectName2,
      this.evalSelectTableReducer(),
    );
    if (this.directMode is Some _) throw IgnoreAndContinue();
    result
  }

  fun evalSelectTableRows(
    qkind: ?(Int, QueryKind),
    remainingTables: List<(DirDescr, ?Array<SKFS.KeyRange>)>,
    entries: List<Row>,
    context: mutable SKFS.Context,
    writer: mutable SKFS.Writer,
    key: SKFS.BaseName,
    inputRows: mutable Iterator<Row>,
  ): void {
    mwriter = mutable MultiWriter{};

    key match {
    | RowKey _ ->
      inputRow = inputRows.next() match {
      | None() -> return void
      | Some(x @ RowValues _) -> x
      | Some(x) ->
        debug(x);
        invariant_violation("Unexpected row type")
      };

      repeat = inputRow.repeat;

      for (ir in inputRows) {
        ir match {
        | RowValues(_, r) -> !repeat = repeat + r
        | _ ->
          debug(ir);
          invariant_violation("Unexpected Row type")
        }
      };

      if (repeat != inputRow.repeat) {
        !inputRow = inputRow.setRepeat(repeat);
      };

      this.evalSelectTableRow(
        qkind,
        remainingTables,
        entries,
        context,
        mwriter,
        key,
        inputRow,
        repeat,
      )

    | _ ->
      for (inputRow in inputRows) {
        repeat = inputRow match {
        | RowValues(_, x) -> x
        | _ -> invariant_violation("Expected RowValues")
        };
        this.evalSelectTableRow(
          qkind,
          remainingTables,
          entries,
          context,
          mwriter,
          key,
          inputRow,
          repeat,
        )
      }
    };

    for (rkey => rvaluesIter in mwriter.writes) {
      rvalues = rvaluesIter.toArray();
      writer.writeArray(rkey, rvalues);
    }
  }

  fun evalSelectTableRow(
    qkind: ?(Int, QueryKind),
    remainingTables: List<(DirDescr, ?Array<SKFS.KeyRange>)>,
    entries: List<Row>,
    context: mutable SKFS.Context,
    mwriter: mutable MultiWriter,
    key: SKFS.BaseName,
    inputRow: Row,
    repeat: Int,
  ): void {
    evaluator = ExprEvaluator(
      None(),
      entries match {
      | List.Nil() -> Array[inputRow]
      | l -> List.Cons(inputRow, l).reversed().collect(Array)
      },
      this.select.from,
      this.up,
    );

    whereVal = evaluator.evalWhere(context, this.select.where);
    whereVal match {
    | ANull()
    | ADef(0) ->
      return void
    | AUndef()
    | ADef(_) ->
      void
    };

    remainingTables match {
    | List.Nil() ->
      this.evalSelectRow(context, qkind, key, evaluator, mwriter, repeat)

    | _ ->
      this.evalSelectCross(
        context,
        remainingTables,
        entries,
        key,
        inputRow,
        mwriter,
        repeat,
      )
    }
  }

  fun evalSelectTableReducer(): ?SKFS.EReducer<Row> {
    reducer = this.select.aggr match {
    | None() ->
      if (this.select.kind is SDistinct() || this.select.groupBy is Some _) {
        Some(
          SKFS.EReducer{
            canReset => true,
            init => firstRowAsArrayRepeat1,
            update => (_, _, _) ~> None(),
          },
        )
      } else {
        Some(
          SKFS.EReducer{
            canReset => false,
            init => initRepeatRow,
            update => updateRepeatRow,
          },
        )
      }
    | Some(aggrs) ->
      aggrKinds = aggrs.map(x -> x.i0);
      Some(
        SKFS.EReducer{
          canReset => true,
          init => rows ~> reducerInit(aggrKinds, rows),
          update => (state, old, new) ~>
            reducerUpdate(aggrKinds, state, old, new),
        },
      )
    };
    this.select.rest match {
    | None() -> reducer
    | Some(_) ->
      Some(
        SKFS.EReducer{
          canReset => true,
          init => initUnion,
          update => (_, _, _) ~> None(),
        },
      )
    }
  }

  fun evalSelectRow(
    context: mutable SKFS.Context,
    qkind: ?(Int, QueryKind),
    _inputKey: SKFS.BaseName,
    evaluator: SKSQL.ExprEvaluator,
    writer: mutable MultiWriter,
    repeat: Int,
  ): void {
    row = this.evalRow(context, evaluator, this.params, repeat);
    if (this.select.aggr is Some _) {
      !evaluator = evaluator with {entries => Array[row]};
      key = this.select.groupBy match {
      | None() -> SKFS.IID(0)
      | Some(groupBy) -> makeGroupByKey(context, evaluator, row, groupBy)
      };
      writer.write(key, row);
    } else {
      invariant(this.select.groupBy is None());
      key = RowKey::create(row, this.kinds);
      qkind match {
      | None() ->
        writer.write(key, row);
        this.directMode match {
        | None() -> void
        | Some(limit) ->
          i = context.getGlobal("DIRECT_MODE_COUNT") match {
          | None() -> 0
          | Some(x) -> SKFS.IntFile::fromFile(x).value
          };
          for (_ in Range(0, row.repeat)) {
            print_string(row.toStringSingle(this.select.format));
            !i = i + 1;
            if (i >= limit) {
              throw IgnoreAndContinue()
            }
          };
          context.setGlobal("DIRECT_MODE_COUNT", SKFS.IntFile(i))
        }
      | Some((order, k)) -> writer.write(key, RowKind(order, k, row))
      }
    };
  }

  fun createSub(
    context: mutable SKFS.Context,
    subTask: SubTask,
  ): mutable Iterator<KVFile> {
    subStr = subTask.name + "sub_" + hash(subTask.key).toString();
    subSelectName = SKFS.DirName::create(subStr + "/");
    nthis = this;
    !nthis.selectName2 = subSelectName;
    result = nthis.evalSelectTableList(
      context,
      subTask.remainingTables,
      List.Cons(subTask.inputRow, subTask.entries),
    );
    context.unsafeGetEagerDir(result.dirName).unsafeGetFileIter().map(x ->
      KVFile((x.i0, x.i1.collect(Array)))
    )
  }

  fun evalSelectCross(
    context: mutable SKFS.Context,
    remainingTables: List<(DirDescr, ?Array<SKFS.KeyRange>)>,
    entries: List<Row>,
    key: SKFS.BaseName,
    inputRow: SKSQL.Row,
    writer: mutable MultiWriter,
    repeat: Int,
  ): void {
    subTask = SubTask(
      this.selectName2.toString(),
      key,
      inputRow,
      entries,
      remainingTables,
    );
    result = this.createSub(context, subTask);
    for (kv in result) {
      writer.writeArray(
        kv.value.i0,
        kv.value.i1.map(x -> {
          x match {
          | RowValues(values, r) -> RowValues::create(values, r * repeat)
          | _ -> invariant_violation("Unexpected Row type")
          }
        }),
      )
    }
  }
}

/*****************************************************************************/
/* Reducer used by aggregate functions. */
/*****************************************************************************/

fun updateState(
  op: (CValue, CValue) ~> CValue,
  adding: Bool,
  state: mutable Array<?SKSQL.CValue>,
  rows: mutable Iterator<Row>,
  aggrKinds: Array<AggrKind>,
): (Bool, Bool) {
  lastRow: ?Row = None();
  size = 0;
  for (row in rows) {
    !size = size + 2;
    for (i => vOpt in row) {
      kind = aggrKinds[i];
      repeat = row match {
      | RowValues(_, x) -> x
      | _ -> invariant_violation("Expected a RowValue")
      };
      (kind, lastRow, vOpt) match {
      | (Min(), _, None()) -> continue
      | (Min(), _, Some(_)) ->
        if (state[i] is None() && adding) state![i] = vOpt;
        if (state[i] < vOpt) continue;
        if (!adding) return (true, false);
        state![i] = vOpt
      | (Max(), _, None()) -> continue
      | (Max(), _, Some(_)) ->
        if (state[i] > vOpt) continue;
        if (!adding) return (true, false);
        state![i] = vOpt
      | (
        Sum(SDistinct()),
        Some(lrow),
        Some(_),
      ) if (lrow.getInt(i) == vOpt.flatMap(x -> x.getInt())) ->
        void
      | (Sum _, _, None()) -> void
      | (Sum _, _, Some(v @ CInt(_))) ->
        state[i] match {
        | None() -> state![i] = Some(op(CInt(0), v * repeat))
        | Some(acc) -> state![i] = Some(op(acc, v * repeat))
        }

      | (Sum _, _, Some(v @ CFloat(_))) ->
        state[i] match {
        | None() -> state![i] = Some(op(CFloat(0.0), v * repeat))
        | Some(acc) -> state![i] = Some(op(acc, v * repeat))
        }

      | (
        Count(SDistinct()),
        Some(lrow),
        Some(_),
      ) if (lrow.getInt(i) == vOpt.flatMap(x -> x.getInt())) ->
        void
      | (Count(_), _, None()) -> void
      | (Count(_), _, Some(_)) ->
        state[i] match {
        | None() -> state![i] = Some(op(CInt(0), CInt(repeat)))
        | Some(acc) -> state![i] = Some(op(acc, CInt(repeat)))
        }

      | (Noop(), _, x) -> state![i] = x

      | (_, _, Some(SKSQL.CString _)) ->
        invariant_violation("Invalid aggregate")
      }
    };
    !lastRow = Some(row);
  };
  (false, lastRow is None())
}

fun reducerInit(
  aggrKinds: Array<AggrKind>,
  rows: mutable Iterator<Row>,
): Array<Row> {
  state = Array<?CValue>::mcreateFromItems(
    aggrKinds.map(kind -> {
      kind match {
      | Max()
      | Min()
      | Noop()
      | Sum(_) ->
        None()
      | Count(_) -> Some(CInt(0))
      }
    }),
  );
  (shouldReset, isEmpty) = updateState(
    (x, y) ~> x + y,
    true,
    state,
    rows,
    aggrKinds,
  );
  invariant(!shouldReset);
  if (isEmpty) return Array[];
  Array[RowValues::create(unsafe_chill_trust_me(state).map(x -> x))]
}

fun isPotentiallyEmpty(
  aggrKinds: Array<AggrKind>,
  state: readonly Array<?CValue>,
): Bool {
  for (i in Range(0, aggrKinds.size())) {
    if (aggrKinds[i] is Noop()) continue;
    state[i] match {
    | Some(CInt(n)) -> if (n != 0) return false
    | Some(CFloat(f)) -> if (f < -0.01 || f > 0.01) return false
    | x ->
      debug(x);
      invariant_violation("Unexpected type")
    }
  };
  true
}

fun reducerUpdate(
  aggrKinds: Array<AggrKind>,
  stateRow: Array<Row>,
  oldRows: Array<Row>,
  newRows: Array<Row>,
): ?Array<Row> {
  stateRowValues: Array<?CValue> = stateRow[0] match {
  | RowValues(data, 1) -> data
  | _ -> invariant_violation("Was expecting RowValues")
  };

  state = Array::mcreateFromItems(stateRowValues);

  (shouldReset, _) = updateState(
    (x, y) ~> x - y,
    false,
    state,
    oldRows.iterator(),
    aggrKinds,
  );
  if (shouldReset) return None();
  _ = updateState((x, y) ~> x + y, true, state, newRows.iterator(), aggrKinds);

  if (newRows.isEmpty() && isPotentiallyEmpty(aggrKinds, state)) {
    return None();
  };

  values = unsafe_chill_trust_me(state).map(x -> x);
  Some(Array[RowValues::create(values)])
}

/*****************************************************************************/
/* Reducer for intersections/unions/except. */
/*****************************************************************************/

fun initUnion(rowIter: mutable Iterator<Row>): Array<Row> {
  unsortedRows = rowIter.collect(Array);

  indexes = unsortedRows
    .mapWithIndex((idx, x) ->
      x match {
      | RowKind(order, _, _) -> (order, idx)
      | _ -> (0, idx)
      }
    )
    .sorted();

  rows = Array::fillBy(unsortedRows.size(), i ->
    unsortedRows[indexes[i].i1] match {
    | r @ RowKind _ -> r
    | r ->
      debug(r);
      invariant_violation("Expected a row kind")
    }
  );

  if (rows.size() == 0) return Array[];
  count = 0;
  countIntersect = 0;
  intersectOrder = -1;

  for (row in rows) {
    row.kind match {
    | QUnion(UIntersect()) ->
      if (row.order > intersectOrder) {
        !countIntersect = countIntersect + 1;
        !intersectOrder = row.order;
      }
    | QUnion(USingle()) -> !count = 1
    | QUnion(UAll()) -> !count = count + 1
    | QIntersect(nextIsIntersect) ->
      if (intersectOrder + 1 == row.order) {
        if (nextIsIntersect) {
          !countIntersect = countIntersect + 1;
          !intersectOrder = row.order;
          !count = 0;
        } else {
          !count = 1;
        }
      } else {
        !count = 0;
        !countIntersect = 0;
        !intersectOrder = -1;
      }
    | QExcept() -> !count = 0
    }
  };

  if (count == 0) {
    return Array[];
  };
  if (count == 1) {
    return Array[rows[0].row];
  };

  result = mutable Vector[];
  for (_ in Range(0, count)) {
    result.push(rows[0].row);
  };
  result.toArray()
}

/*****************************************************************************/
/* Builds the key used by a group by. */
/*****************************************************************************/

fun makeGroupByKey(
  context: mutable SKFS.Context,
  evaluator: ExprEvaluator,
  row: Row,
  groupBy: Array<CGroupByElt>,
): RowKey {
  rowKey = mutable Vector[];
  kinds = mutable Vector[];
  for (idx => elt in groupBy) {
    elt match {
    | CGBCol(n, ty) ->
      value = row.getValue(n);
      rowKey.push(value);
      kinds.push((idx, IASC(), ty))
    | CGBExpr(e, ty) ->
      value = evaluator.evalCGExpr(context, e) match {
      | ANull() -> None()
      | ADef(x) -> Some(x)
      | _ -> invariant_violation("Should have successfully interpreted")
      };
      rowKey.push(value);
      kinds.push((idx, IASC(), ty))
    }
  };
  result = RowKey(RowValues::create(rowKey.toArray()), kinds.toArray());
  result
}

/*****************************************************************************/
/* Reducer used by joins. */
/*****************************************************************************/

fun makeJoinReducer(
  shardTable: SKFS.EHandle<ShardStats>,
  joinKind: JoinKind,
  kinds: Array<(Int, IKind, Type)>,
  onlyLeftValues: Bool,
): (
  mutable SKFS.Context,
  mutable SKFS.Writer,
  SKFS.BaseName,
  mutable Iterator<SKFS.File>,
) ~> void {
  (context, writer, _, files) ~> {
    leftRows = mutable Vector[];
    rightRows = mutable Vector[];
    for (file in files) {
      file match {
      | LeftFile(key, leftFile) ->
        leftRows.push((key, RowValues::fromFile(leftFile)))
      | RightFile(key, rightFile) ->
        rightRows.push((key, RowValues::fromFile(rightFile)))
      | _ ->
        debug(file);
        invariant_violation("Unexpected file type in joinReducer")
      }
    };
    leftSize = leftRows.size();
    rightSize = rightRows.size();
    if (
      leftSize / max(1, rightSize) > 128 ||
      rightSize / max(1, leftSize) > 128
    ) {
      oldStats = getStats(context, shardTable, leftRows) match {
      | None() -> getStats(context, shardTable, rightRows)
      | x -> x
      };
      stats = oldStats match {
      | None() -> ShardStats(context.tick, pow2(leftSize), pow2(rightSize))
      | Some(x) -> x
      };
      if (oldStats is None() || stats.tick < context.tick) {
        !stats = stats with {
          tick => context.tick,
          left => stats.left * 2,
          right => stats.right * 2,
        };
        for (kv in leftRows) {
          (key, _) = kv;
          shardTable.writeArray(context, key, Array[stats]);
        };
        for (kv in rightRows) {
          (key, _) = kv;
          shardTable.writeArray(context, key, Array[stats]);
        }
      }
    };
    for (kv in leftRows) {
      (_, left) = kv;
      if (
        rightRows.isEmpty() &&
        (joinKind is JLeft _ || joinKind is JOuter _)
      ) {
        values = if (onlyLeftValues) left.values else {
          right = Array::fill(kinds.size() - left.size(), None<CValue>());
          left.values.concat(right);
        };
        row = RowValues::create(values, left.repeat);
        writer.write(RowKey(row, kinds), row);
      };
      for (rkv in rightRows) {
        (_, right) = rkv;
        values = if (onlyLeftValues) left.values else {
          left.values.concat(right.values)
        };
        row = RowValues::create(values, left.repeat * right.repeat);
        writer.write(RowKey(row, kinds), row);
      }
    };
    if (
      (joinKind is JRight _ || joinKind is JOuter _) &&
      !onlyLeftValues &&
      leftRows.size() == 0
    ) {
      for (kv in rightRows) {
        (_, right) = kv;
        left = Array::fill(kinds.size() - right.size(), None<CValue>());
        values = left.concat(right.values);
        row = RowValues::create(values, right.repeat);
        writer.write(RowKey(row, kinds), row);
      }
    }
  }
}

fun normalizeValueIter(
  valueIter: mutable Iterator<SKFS.File>,
): (?RowValues, ?ShardStats) {
  shardStats: ?ShardStats = None();
  valueOpt: ?RowValues = None();
  repeat = 0;
  for (v in valueIter) {
    v match {
    | stats @ ShardStats _ -> !shardStats = Some(stats)
    | r @ RowValues _ ->
      if (valueOpt is None()) !valueOpt = Some(r);
      !repeat = repeat + r.repeat
    | _ ->
      debug(v);
      invariant_violation("Unexpected type")
    }
  };
  valueOpt match {
  | None() -> (None(), None())
  | Some(v) ->
    if (repeat == 0) (None(), None()) else {
      !v = v.setRepeat(repeat);
      (Some(v), shardStats)
    }
  }
}

fun computeShardSizes(stats: ?ShardStats): (Int, Int) {
  stats match {
  | None() -> (1, 1)
  | Some(ShardStats(_, leftSize, rightSize)) ->
    (
      if (rightSize == 0 || rightSize >= leftSize) {
        1
      } else {
        leftSize / rightSize
      },
      if (leftSize == 0 || leftSize >= rightSize) {
        1
      } else {
        rightSize / leftSize;
      },
    )
  }
}

fun getStats(
  context: mutable SKFS.Context,
  shardTable: SKFS.EHandle<ShardStats>,
  x: readonly Vector<(SKFS.BaseName, SKFS.File)>,
): ?ShardStats {
  for (kv in x) {
    (key, _) = kv;
    oldStatsArray = context
      .unsafeGetEagerDir(shardTable.dirName)
      .getArrayRaw(key);
    if (oldStatsArray.size() != 0) {
      return Some(ShardStats::fromFile(oldStatsArray[0]));
    }
  };
  None()
}
