/*****************************************************************************/
/* SQL SELECT */
/*****************************************************************************/

module alias P = SQLParser;

module SKDB;

base class QueryKind uses Orderable {
  children =
  | QExcept()
  | QUnion(QUnionKind)
  | QIntersect(Bool)
}

base class QUnionKind uses Orderable {
  children =
  | USingle()
  | UAll()
  | UIntersect()
}

type MapFunRow = (
  mutable SKStore.Context,
  mutable SKStore.TWriter<SKStore.Key, Row>,
  SKStore.Key,
  mutable Iterator<Row>,
) ~> void;

class SubTask(
  name: String,
  key: SKStore.Key,
  inputRow: Row,
  entries: List<Row>,
  remainingTables: List<(SKDB.DirDescr, ?Array<SKStore.KeyRange>)>,
)

class KVFile(value: (SKStore.Key, Array<SKStore.File>)) extends SKStore.File

class ProjKey(
  value: ?CValue,
  leftShard: Int,
  rightShard: Int,
) extends SKStore.Key {
  fun toString(): String {
    this.value.toString()
  }
}

class LeftFile(SKStore.Key, RowValues) extends SKStore.File
class LeftShardedFile{
  leftShardID: Int,
  rightShard: Int,
  value: RowValues,
} extends SKStore.File

class RightFile(SKStore.Key, RowValues) extends SKStore.File
class RightShardedFile{
  leftShard: Int,
  rightShardID: Int,
  value: RowValues,
} extends SKStore.File

/*****************************************************************************/
/* Helper */
/*****************************************************************************/

fun firstRow(rows: mutable Iterator<Row>): ?Row {
  for (row in rows) {
    break Some(row);
  } else {
    None()
  }
}

fun firstRowAsArray(rows: mutable Iterator<Row>): Array<Row> {
  firstRow(rows) match {
  | None() -> Array[]
  | Some(x) -> Array[x]
  }
}

fun firstRowAsArrayRepeat1(rows: mutable Iterator<Row>): Array<Row> {
  firstRow(rows) match {
  | None() -> Array[]
  | Some(x) ->
    Array[
      x match {
      | RowValues(values, _) -> RowValues::create(values, 1)
      | _ -> invariant_violation("Unexpected Row type")
      },
    ]
  }
}

fun initRepeatRow(rows: mutable Iterator<Row>): Array<Row> {
  firstRow(rows) match {
  | None() -> Array[]
  | Some(RowValues(values, n)) ->
    for (row in rows) {
      row match {
      | RowValues(_, r) -> !n = n + r
      | _ -> invariant_violation("Unexpected Row kind")
      }
    };
    Array[RowValues::create(values, n)]
  | _ -> invariant_violation("Unexpected Row kind")
  }
}

fun updateRepeatRow(
  state: Array<Row>,
  remove: Array<Row>,
  adds: Array<Row>,
): ?Array<Row> {
  invariant(state.size() == 1);
  (values, n) = state[0] match {
  | RowValues(values, n) -> (values, n)
  | _ -> invariant_violation("Unexpected state in updateRepeatRow")
  };
  for (row in remove) {
    row match {
    | RowValues(_, r) -> !n = n - r
    | _ -> invariant_violation("Unexpected state in updateRepeatRow")
    }
  };
  for (row in adds) {
    row match {
    | RowValues(_, r) -> !n = n + r
    | _ -> invariant_violation("Unexpected state in updateRepeatRow")
    }
  };
  if (n == 0) Some(Array[]) else Some(Array[RowValues::create(values, n)])
}

// produces the closest power of 2 larger than n
fun pow2(n: Int): Int {
  invariant(n >= 0);
  if (n <= 1) 2 else 2 * pow2(n / 2)
}

fun noop(
  _context: mutable SKStore.Context,
  writer: mutable SKStore.Writer,
  key: SKStore.Key,
  valueIter: mutable Iterator<SKStore.File>,
): void {
  writer.setArray(key, valueIter.collect(Array))
}

/*****************************************************************************/
/* We need to be able to write more than one row per key. */
/*****************************************************************************/

mutable class MultiWriter{
  mutable writes: SortedMap<SKStore.Key, mutable Vector<Row>> = SortedMap[],
} {
  mutable fun write(key: SKStore.Key, value: Row): void {
    if (!this.writes.containsKey(key)) {
      this.!writes[key] = mutable Vector[];
    };
    this.writes[key].push(value);
  }

  mutable fun writeArray(key: SKStore.Key, values: Array<Row>): void {
    if (!this.writes.containsKey(key)) {
      this.!writes[key] = mutable Vector[];
    };
    this.writes[key].extend(values);
  }
}

/*****************************************************************************/
/* The value returned by the evaluator. */
/*****************************************************************************/

class SelectDir(
  dirName: SKStore.DirName,
  types: Array<P.Type>,
) extends SKStore.File

/*****************************************************************************/
/* The main entry point. */
/*****************************************************************************/
const queryPrefix: String = "query/";

fun evalSelect(
  context: mutable SKStore.Context,
  select: CSelect,
  up: ?ExprEvaluator,
): SelectDir {
  makeSelectEvaluator(context, select, up).evalSelect(context)
}

fun makeSelectEvaluator(
  context: mutable SKStore.Context,
  select: CSelect,
  up: ?ExprEvaluator,
): SelectEvaluator {
  selectName1 = makeSelectName(
    if (context.canReuse is SKStore.CRNever()) {
      queryPrefix + SKStore.genSym(0)
    } else {
      select.id.lower + if (select.needUp) "_" + hash(up) else ""
    },
  );
  selectName2 = if (select.aggr is Some _) {
    SKStore.DirName::create(selectName1.toString() + "aggrEnv/")
  } else {
    selectName1
  };
  types = select.params.map(x -> x.getType());
  SelectEvaluator{
    select,
    up,
    params => select.params,
    selectName1,
    selectName2,
    kinds => select.kinds,
    types,
  }
}

/*****************************************************************************/
/* The Sql Select evaluator (should only be used by evalSelect). */
/*****************************************************************************/

class SelectEvaluator{
  select: CSelect,
  directMode: ?Int = None(),
  up: ?ExprEvaluator,
  params: Array<CGExpr>,
  selectName1: SKStore.DirName,
  selectName2: SKStore.DirName,
  kinds: Array<(Int, P.IKind, P.Type)>,
  types: Array<P.Type>,
} {
  fun evalStaticInt(context: mutable SKStore.Context, expr: CExpr<Int>): Int {
    emptyEval = ExprEvaluator(Array[], this.select.from, this.up);
    emptyEval.evalCIExpr(context, expr) match {
    | ANull() -> 0
    | ADef(x) -> x
    | AUndef() -> invariant_violation("Unexpected Undef")
    }
  }

  fun evalSelect(context: mutable SKStore.Context): SelectDir {
    for (subTask in this.select.other) {
      static::evalSubTask(context, subTask);
    };
    this.select.limit match {
    | Some(limitExpr) if (!this.select.directMode) ->
      limit = this.evalStaticInt(context, limitExpr);
      this.evalSelectLimit(context, limit)
    | _ ->
      if (this.select.directMode) {
        !this.directMode = this.select.limit match {
        | None() -> Some(Int::max)
        | Some(limitExpr) -> Some(this.evalStaticInt(context, limitExpr))
        };
      };
      this.evalSelectNoLimitOrDirectMode(context)
    }
  }

  fun evalSelectLimit(context: mutable SKStore.Context, limit: Int): SelectDir {
    invariant(!this.select.directMode);
    childName = this.selectName2;
    if (
      this.select.sets.size() != 0 ||
      this.select.aggr is Some _ ||
      this.select.from.size() != 1 ||
      this.select.groupBy is Some _ ||
      this.select.having is Some _ ||
      this.select.orderBy is Some _ ||
      !this.select.rest.isEmpty() ||
      this.up is Some _
    ) {
      !this.select.limit = None();
      !this.selectName1 = SKStore.DirName::create(
        this.selectName1.toString() + "nolimit/",
      );
      !this.selectName2 = SKStore.DirName::create(
        this.selectName2.toString() + "nolimit/",
      );
      result = this.evalSelectNoLimitOrDirectMode(context);
      handle = SKStore.EHandle(
        RowKey::keyType,
        RowValues::type,
        result.dirName,
      );
      filtered = handle.filter(
        context,
        childName,
        limit,
        (_, _key, _value) ~> true,
        value ~> value.repeat,
        (value, n) ~> {
          !value = value.setRepeat(value.repeat - n);
          value
        },
        None(),
      );
      SelectDir(filtered.dirName, this.types)
    } else {
      handle = SKStore.EHandle(
        SKStore.Key::unTyped,
        RowValues::type,
        this.select.from[0].i0.dirName,
      );
      select = this.select;
      up = this.up;
      invariant(up is None());
      filtered = handle.filter(
        context,
        SKStore.DirName::create(childName.toString() + "noparams/"),
        limit,
        (context, _key, value) ~> {
          evaluator = ExprEvaluator(Array[value], select.from, up);
          whereVal = evaluator.evalWhere(context, select.where);
          whereVal match {
          | ANull()
          | ADef(0) ->
            false
          | AUndef()
          | ADef(_) ->
            true
          }
        },
        value ~> value.repeat,
        (value, n) ~> {
          !value = value.setRepeat(value.repeat - n);
          value
        },
        this.select.from[0].i1,
      );
      kinds = this.kinds;
      _ = filtered.map(
        SKStore.Key::unTyped,
        RowValues::type,
        context,
        childName,
        (context, writer, _key, fileIter) ~> {
          entry = fileIter.first;
          repeat = 0;
          for (file in fileIter) {
            !repeat = repeat + file.repeat;
          };
          if (repeat != entry.repeat) {
            !entry = entry.setRepeat(repeat);
          };
          evaluator = ExprEvaluator(Array[entry], select.from, up);
          row = static::evalRow(context, evaluator, select.params, repeat);
          writer.set(RowKey(row, kinds), row)
        },
      );
      SelectDir(childName, this.types)
    }
  }

  static fun evalSubTask(
    context: mutable SKStore.Context,
    subTask: SubSelectTask,
  ): void {
    subTask match {
    | SubSelect(cselect) -> _ = evalSelect(context, cselect, None())
    | SubMerge{
      leftDirName,
      leftColNbr,
      leftIsUnique => _,
      leftRanges,
      rightDirName,
      rightColNbr,
      rightIsUnique => _,
      rightRanges,
      childName,
      kinds,
      joinKind,
      onlyLeftValues,
    } ->
      leftHandle = SKStore.EHandle(x ~> x, Row::type, leftDirName);
      rightHandle = SKStore.EHandle(x ~> x, Row::type, rightDirName);

      shardsDirName = SKStore.DirName::create(
        childName.toString() + "proj/shards/",
      );
      shards = context.unsafeMaybeGetEagerDir(shardsDirName) match {
      | None() ->
        context.mkdir(x ~> x, ShardStats::type, shardsDirName, Array[])
      | Some(x) -> SKStore.EHandle(x ~> x, ShardStats::type, x.dirName)
      };

      projLeftName = SKStore.DirName::create(
        childName.toString() + "proj/left/",
      );

      SKStore.EagerDir::applyMany(
        context,
        SKStore.FixedSingle::create(
          mutable Vector[
            (leftHandle.dirName, Array[(noop, leftRanges, None())]),
            (shardsDirName, Array[(noop, None(), None())]),
          ],
        ),
        projLeftName,
      );

      projRightName = SKStore.DirName::create(
        childName.toString() + "proj/right/",
      );

      SKStore.EagerDir::applyMany(
        context,
        SKStore.FixedSingle::create(
          mutable Vector[
            (rightHandle.dirName, Array[(noop, rightRanges, None())]),
            (shardsDirName, Array[(noop, None(), None())]),
          ],
        ),
        projRightName,
      );

      projName = SKStore.DirName::create(childName.toString() + "proj/");

      projLeftFun = (_context, writer, fileKey, valueIter) ~> {
        (rowOpt, shardStats) = normalizeValueIter(valueIter);
        row = rowOpt match {
        | None() -> return void
        | Some(r) -> r
        };
        (leftShard, rightShard) = computeShardSizes(shardStats);
        key = row.getValue(leftColNbr);
        leftShardID = SKStore.genSym(leftShard) % leftShard;
        shardedFile = LeftShardedFile{leftShardID, rightShard, value => row};
        for (i in Range(0, rightShard)) {
          projKey = ProjKey(key, leftShardID, i);
          writer.set(projKey, LeftFile(fileKey, shardedFile.value))
        }
      };

      projRightFun = (_context, writer, fileKey, valueIter) ~> {
        (rowOpt, shardStats) = normalizeValueIter(valueIter);
        row = rowOpt match {
        | None() -> return void
        | Some(r) -> r
        };
        (leftShard, rightShard) = computeShardSizes(shardStats);
        key = row.getValue(rightColNbr);
        rightShardID = SKStore.genSym(rightShard) % rightShard;
        shardedFile = RightShardedFile{leftShard, rightShardID, value => row};
        for (i in Range(0, leftShard)) {
          projKey = ProjKey(key, i, rightShardID);
          writer.set(projKey, RightFile(fileKey, shardedFile.value))
        }
      };

      SKStore.EagerDir::applyMany(
        context,
        SKStore.FixedSingle::create(
          mutable Vector[
            (projLeftName, Array[(projLeftFun, None(), None())]),
            (projRightName, Array[(projRightFun, None(), None())]),
          ],
        ),
        projName,
      );
      SKStore.EagerDir::applyMany(
        context,
        SKStore.FixedSingle::create(
          mutable Vector[
            (
              projName,
              Array[
                (
                  makeJoinReducer(shards, joinKind, kinds, onlyLeftValues),
                  None(),
                  None(),
                ),
              ],
            ),
          ],
        ),
        childName,
      )
    };
  }

  fun evalSelectNoLimitOrDirectMode(
    context: mutable SKStore.Context,
  ): SelectDir {
    dirName = this.select.aggr match {
    | None() if (this.select.from.size() == 0) ->
      this.evalEmptyFrom(context);
      this.selectName1
    | None() ->
      if (this.select.isNoop) {
        return SelectDir(this.select.from[0].i0.dirName, this.types)
      };
      resultDir = this.evalSelectTableList(
        context,
        List::createFromItems(this.select.from),
        List[],
      );
      resultDir.dirName
    | Some(_) ->
      if (!this.select.rest.isEmpty()) {
        invariant_violation("Unexpected select type for aggregate function")
      };
      this.evalAggr(context)
    };
    SelectDir(dirName, this.types)
  }

  fun evalAggr(context: mutable SKStore.Context): SKStore.DirName {
    aggrs = this.select.aggr.fromSome();

    if (this.select.from.size() == 0) {
      if (context.unsafeMaybeGetEagerDir(this.selectName1) is None()) {
        emptyEval = ExprEvaluator(Array[], this.select.from, this.up);
        entry = static::evalRow(context, emptyEval, aggrs.map(y -> y.i1), 1);
        evaluator = ExprEvaluator(Array[entry], this.select.from, this.up);
        row = static::evalRow(context, evaluator, this.select.params, 1);
        _dir = context.mkdir(
          SKStore.IID::keyType,
          Row::type,
          this.selectName1,
          Array[(SKStore.IID(0), row)],
        );
      } else {
        context.!newDirs = context.newDirs.set(this.selectName1);
      };
      this.selectName1
    } else {
      resultDir = (this with {
        params => aggrs.map(x -> x.i1),
      }).evalSelectTableList(
        context,
        List::createFromItems(this.select.from),
        List[],
      );

      isGlobalAggr =
        aggrs.any(x -> !(x.i0 is Noop())) &&
        this.select.groupBy is None _;

      dataName = if (isGlobalAggr) {
        SKStore.DirName::create(this.selectName1.toString() + "data/");
      } else {
        this.selectName1
      };

      // Case with actual data
      _ = resultDir.map(
        x ~> x,
        Row::type,
        context,
        dataName,
        (context, writer, key, aggrResult) ~> {
          entry = firstRow(aggrResult) match {
          | None() -> return void
          | Some(x) -> x
          };
          evaluator = ExprEvaluator(Array[entry], this.select.from, this.up);
          this.select.having match {
          | None() ->
            row = static::evalRow(context, evaluator, this.select.params, 1);
            writer.set(key, row)
          | Some(cond) ->
            evaluator.evalCIExpr(context, cond) match {
            | ADef(0)
            | ANull() ->
              void
            | AUndef() ->
              invariant_violation("Having should never be undefined")
            | ADef(_) ->
              row = static::evalRow(context, evaluator, this.select.params, 1);
              writer.set(key, row)
            }
          }
        },
      );

      if (isGlobalAggr) {
        selectName1Empty = SKStore.DirName::create(
          this.selectName1.toString() + "empty/",
        );
        if (context.unsafeMaybeGetEagerDir(selectName1Empty) is None()) {
          emptyEntry = RowValues::create(
            aggrs.map(x ->
              x.i0 match {
              | Noop() -> None()
              | Sum(_) -> None()
              | Max() -> None()
              | Min() -> None()
              | Count(_) -> Some(CInt(0))
              | InferSchema() -> Some(CType::create(SKJSON.Type::any))
              }
            ),
          );
          emptyEvaluator = ExprEvaluator(
            Array[emptyEntry],
            this.select.from,
            this.up,
          );
          emptyRow = static::evalRow(
            context,
            emptyEvaluator,
            this.select.params,
            1,
          );
          _ = context.mkdir(
            SKStore.IID::keyType,
            Row::type,
            selectName1Empty,
            Array[(SKStore.IID(0), emptyRow)],
          );
        } else {
          context.!newDirs = context.newDirs.set(selectName1Empty);
        };

        SKStore.EagerDir::applyMany(
          context,
          SKStore.FixedSingle::create(
            mutable Vector[
              (
                selectName1Empty,
                Array[
                  (
                    (context, writer, key, values) ~> {
                      dataDir = context.unsafeGetEagerDir(dataName);
                      if (dataDir.isEmpty(context)) {
                        writer.setArray(key, values.collect(Array))
                      }
                    },
                    None(),
                    None(),
                  ),
                ],
              ),
              (
                dataName,
                Array[
                  (
                    (_context, writer, key, values) ~> {
                      arr = values.collect(Array);
                      writer.setArray(key, arr)
                    },
                    None(),
                    None(),
                  ),
                ],
              ),
            ],
          ),
          this.selectName1,
        )
      };
      this.selectName1
    }
  }

  static fun evalRow(
    context: mutable SKStore.Context,
    evaluator: ExprEvaluator,
    params: Array<CGExpr>,
    repeat: Int,
  ): RowValues {
    RowValues::create(
      params.map(param ->
        evaluator.evalCGExpr(context, param) match {
        | AUndef() ->
          debug(param);
          invariant_violation("Unexpected undefined value")
        | ANull() -> None()
        | ADef(x) -> Some(x)
        }
      ),
      repeat,
    )
  }

  fun evalEmptyFrom(context: mutable SKStore.Context): void {
    dirName = this.selectName2;
    if (context.unsafeMaybeGetEagerDir(dirName) is None()) {
      evaluator = ExprEvaluator(Array[], this.select.from, this.up);

      whereVal = evaluator.evalWhere(context, this.select.where);
      row = whereVal match {
      | ANull()
      | ADef(0) ->
        static::evalRow(context, evaluator, Array[CGNull()], 1)
      | AUndef()
      | ADef(_) ->
        static::evalRow(context, evaluator, this.select.params, 1)
      };
      _dir = context.mkdir(
        SKStore.IID::keyType,
        Row::type,
        dirName,
        Array[(SKStore.IID(0), row)],
      );
    } else {
      context.!newDirs = context.newDirs.set(dirName);
    }
  }

  fun evalSelectTableList(
    context: mutable SKStore.Context,
    tables: List<(DirDescr, ?Array<SKStore.KeyRange>)>,
    entries: List<Row>,
  ): SKStore.EHandle<SKStore.Key, Row> {
    tables match {
    | List.Nil() -> invariant_violation("empty select")
    | List.Cons(table, remainingTables) ->
      this.evalSelectTable(
        context,

        getDir(table.i0),
        table.i1,
        remainingTables,
        entries,
      )
    }
  }

  fun makeQueryKind(
    queryKind: SKDB.QueryKind,
    rest: List<(SKDB.QueryKind, SKDB.CSelect)>,
  ): SKDB.QueryKind {
    isIntersect = rest.any(x -> x.i0 is QIntersect _);

    isUnionAll =
      queryKind is QUnion(UAll()) &&
      rest.all(x -> x.i0 is QUnion(UAll()));

    queryKind match {
    | _ if (isUnionAll) -> QUnion(UAll())
    | QUnion _ if (isIntersect) -> QUnion(UIntersect())
    | QUnion(UAll()) -> QUnion(USingle())
    | QIntersect(_) -> QIntersect(isIntersect)
    | qk -> qk
    }
  }

  fun makeParents(
    context: mutable SKStore.Context,
    dirName: SKStore.DirName,
    rangeOpt: ?Array<SKStore.KeyRange>,
    remainingTables: List<(DirDescr, ?Array<SKStore.KeyRange>)>,
    entries: List<Row>,
  ): Array<
    (SKStore.EHandle<SKStore.Key, Row>, (MapFunRow, ?Array<SKStore.KeyRange>)),
  > {
    queryKind = this.select.rest match {
    | List.Nil() -> None()
    | List.Cons((QUnion(UAll()), _), _) ->
      Some((0, this.makeQueryKind(QUnion(UAll()), this.select.rest)))
    | List.Cons _ ->
      Some((0, this.makeQueryKind(QUnion(USingle()), this.select.rest)))
    };
    mapFunRow = (ctx, wrt, key, rows) ~> {
      this.evalSelectTableRows(
        queryKind,
        remainingTables,
        entries,
        ctx,
        wrt,
        key,
        rows,
      );
    };
    mparents = mutable Vector[
      (SKStore.EHandle(x ~> x, Row::type, dirName), (mapFunRow, rangeOpt)),
    ];
    order = 1;

    rest = this.select.rest;
    for ((qKind, query) in this.select.rest) {
      !rest = rest.getTail();
      currentOrder = order;
      currentRest = rest;
      ev = makeSelectEvaluator(context, query, this.up);
      rtables = List::createFromItems(query.from);
      (rtable, rremainingTables) = rtables match {
      | List.Nil() -> invariant_violation("Should have been expanded")
      | List.Cons(x, y) -> (x, y)
      };
      rentries = List<Row>[];
      rmapFun: MapFunRow = (ctx, wrt, key, rows) ~> {
        ev.evalSelectTableRows(
          Some((currentOrder, this.makeQueryKind(qKind, currentRest))),
          rremainingTables,
          rentries,
          ctx,
          wrt,
          key,
          rows,
        )
      };
      dirDescr = getDir(rtable.i0);
      mparents.push(
        (
          SKStore.EHandle(x ~> x, Row::type, dirDescr.dirName),
          (rmapFun, rtable.i1),
        ),
      );
      !order = order + 1
    };
    mparents.toArray()
  }

  fun evalSelectTable(
    context: mutable SKStore.Context,
    dir: SKStore.EHandle<SKStore.Key, Row>,
    rangeOpt: ?Array<SKStore.KeyRange>,
    remainingTables: List<(DirDescr, ?Array<SKStore.KeyRange>)>,
    entries: List<Row>,
  ): SKStore.EHandle<SKStore.Key, Row> {
    parents = this.makeParents(
      context,
      dir.dirName,
      rangeOpt,
      remainingTables,
      entries,
    );
    this.directMode match {
    | Some(limit) ->
      this.select.format match {
      | SKStore.OTable(fieldNames) ->
        data = mutable Vector[];
        trailing = false;
        limited = false;
        i = 0;
        for (kv in context.unsafeGetEagerDir(dir.dirName).unsafeGetFileIter()) {
          (_, files) = kv;
          for (file in files) {
            input = RowValues::type(file);
            evaluator = ExprEvaluator(Array[input], Array[], None());
            whereVal = evaluator.evalWhere(context, this.select.where);
            whereVal match {
            | ANull()
            | ADef(0) ->
              continue
            | _ -> void
            };
            row = static::evalRow(
              context,
              evaluator,
              this.params,
              input.repeat,
            );
            for (_ in Range(0, row.repeat)) {
              !i = i + 1;
              if (i >= limit) {
                !limited = true;
                break void
              };
              if (data.size() > kMaxOutputRowsTable) {
                !trailing = true;
                break void
              };
              data.push(row.values)
            };
            if (trailing || limited) {
              break void
            }
          };
          if (trailing || limited) {
            break void
          }
        };

        printTable(fieldNames, data.toArray(), trailing)

      | _ ->
        RowValues::printHeader(this.select.format);
        i = 0;
        for (kv in context.unsafeGetEagerDir(dir.dirName).unsafeGetFileIter()) {
          (_, files) = kv;
          for (file in files) {
            input = RowValues::type(file);
            evaluator = ExprEvaluator(Array[input], Array[], None());
            whereVal = evaluator.evalWhere(context, this.select.where);
            whereVal match {
            | ANull()
            | ADef(0) ->
              continue
            | _ -> void
            };
            row = static::evalRow(
              context,
              evaluator,
              this.params,
              input.repeat,
            );
            for (_ in Range(0, row.repeat)) {
              RowValues::printItem(this.select.format, row);
              !i = i + 1;
              if (i >= limit) throw IgnoreAndContinue();
            }
          }
        }
      };
      throw IgnoreAndContinue()
    | None() ->
      result = this.evalSelectTableReducer() match {
      | None() ->
        SKStore.EHandle::multiMap(
          x ~> x,
          Row::type,
          context,
          parents,
          this.selectName2,
        )
      | Some(reducer) ->
        SKStore.EHandle::multiMapReduce(
          x ~> x,
          Row::type,
          context,
          parents,
          this.selectName2,
          reducer,
        )
      };
      result
    }
  }

  fun evalSelectTableRows(
    qkind: ?(Int, QueryKind),
    remainingTables: List<(DirDescr, ?Array<SKStore.KeyRange>)>,
    entries: List<Row>,
    context: mutable SKStore.Context,
    writer: mutable SKStore.TWriter<SKStore.Key, Row>,
    key: SKStore.Key,
    inputRows: mutable Iterator<Row>,
  ): void {
    mwriter = mutable MultiWriter{};

    key match {
    | RowKey _ ->
      inputRow = inputRows.next() match {
      | None() -> return void
      | Some(x @ RowValues _) -> x
      | Some(x) ->
        debug(x);
        invariant_violation("Unexpected row type")
      };

      repeat = inputRow.repeat;

      for (ir in inputRows) {
        ir match {
        | RowValues(_, r) -> !repeat = repeat + r
        | _ ->
          debug(ir);
          invariant_violation("Unexpected Row type")
        }
      };

      if (repeat != inputRow.repeat) {
        !inputRow = inputRow.setRepeat(repeat);
      };

      this.evalSelectTableRow(
        qkind,
        remainingTables,
        entries,
        context,
        mwriter,
        key,
        inputRow,
        repeat,
      )

    | _ ->
      for (inputRow in inputRows) {
        repeat = inputRow match {
        | RowValues(_, x) -> x
        | _ -> invariant_violation("Expected RowValues")
        };
        this.evalSelectTableRow(
          qkind,
          remainingTables,
          entries,
          context,
          mwriter,
          key,
          inputRow,
          repeat,
        )
      }
    };

    for (rkey => rvaluesIter in mwriter.writes) {
      rvalues = rvaluesIter.toArray();
      writer.setArray(rkey, rvalues);
    }
  }

  fun evalSelectTableRow(
    qkind: ?(Int, QueryKind),
    remainingTables: List<(DirDescr, ?Array<SKStore.KeyRange>)>,
    entries: List<Row>,
    context: mutable SKStore.Context,
    mwriter: mutable MultiWriter,
    key: SKStore.Key,
    inputRow: Row,
    repeat: Int,
  ): void {
    evaluator = ExprEvaluator(
      entries match {
      | List.Nil() -> Array[inputRow]
      | l -> List.Cons(inputRow, l).reversed().collect(Array)
      },
      this.select.from,
      this.up,
    );

    whereVal = evaluator.evalWhere(context, this.select.where);
    whereVal match {
    | ANull()
    | ADef(0) ->
      return void
    | AUndef()
    | ADef(_) ->
      void
    };

    remainingTables match {
    | List.Nil() ->
      this.evalSelectRow(context, qkind, key, evaluator, mwriter, repeat)

    | _ ->
      this.evalSelectCross(
        context,
        remainingTables,
        entries,
        key,
        inputRow,
        mwriter,
        repeat,
      )
    }
  }

  fun evalSelectTableReducer(): ?SKStore.EReducer<Row, Row> {
    reducer = this.select.aggr match {
    | None() ->
      if (this.select.distinct || this.select.groupBy is Some _) {
        Some(
          SKStore.EReducer{
            type => Row::type,
            canReset => true,
            init => firstRowAsArrayRepeat1,
            update => (_, _, _) ~> None(),
          },
        )
      } else {
        Some(
          SKStore.EReducer{
            type => Row::type,
            canReset => false,
            init => initRepeatRow,
            update => updateRepeatRow,
          },
        )
      }
    | Some(aggrs) ->
      aggrKinds = aggrs.map(x -> x.i0);
      Some(
        SKStore.EReducer{
          type => Row::type,
          canReset => true,
          init => rows ~> reducerInit(aggrKinds, rows),
          update => (state, old, new) ~>
            reducerUpdate(aggrKinds, state, old, new),
        },
      )
    };
    this.select.rest match {
    | List.Nil _ -> reducer
    | List.Cons _ ->
      Some(
        SKStore.EReducer{
          type => Row::type,
          canReset => true,
          init => initUnion,
          update => (_, _, _) ~> None(),
        },
      )
    }
  }

  fun evalSelectRow(
    context: mutable SKStore.Context,
    qkind: ?(Int, QueryKind),
    _inputKey: SKStore.Key,
    evaluator: SKDB.ExprEvaluator,
    writer: mutable MultiWriter,
    repeat: Int,
  ): void {
    row = static::evalRow(context, evaluator, this.params, repeat);
    if (this.select.aggr is Some _) {
      !evaluator = evaluator with {entries => Array[row]};
      key = this.select.groupBy match {
      | None() -> SKStore.IID(0)
      | Some(groupBy) -> makeGroupByKey(context, evaluator, row, groupBy)
      };
      writer.write(key, row);
    } else {
      invariant(this.select.groupBy is None());
      key = RowKey::create(row, this.kinds);
      qkind match {
      | None() -> writer.write(key, row)
      | Some((order, k)) -> writer.write(key, RowKind(order, k, row))
      }
    };
  }

  fun createSub(
    context: mutable SKStore.Context,
    subTask: SubTask,
  ): mutable Iterator<KVFile> {
    subStr = subTask.name + "sub_" + hash(subTask.key).toString();
    subSelectName = SKStore.DirName::create(subStr + "/");
    nthis = this;
    !nthis.selectName2 = subSelectName;
    result = nthis.evalSelectTableList(
      context,
      subTask.remainingTables,
      List.Cons(subTask.inputRow, subTask.entries),
    );
    context.unsafeGetEagerDir(result.dirName).unsafeGetFileIter().map(x ->
      KVFile((x.i0, x.i1.collect(Array)))
    )
  }

  fun evalSelectCross(
    context: mutable SKStore.Context,
    remainingTables: List<(DirDescr, ?Array<SKStore.KeyRange>)>,
    entries: List<Row>,
    key: SKStore.Key,
    inputRow: SKDB.Row,
    writer: mutable MultiWriter,
    repeat: Int,
  ): void {
    subTask = SubTask(
      this.selectName2.toString(),
      key,
      inputRow,
      entries,
      remainingTables,
    );
    result = this.createSub(context, subTask);
    for (kv in result) {
      writer.writeArray(
        kv.value.i0,
        kv.value.i1.map(x -> {
          x match {
          | RowValues(values, r) -> RowValues::create(values, r * repeat)
          | _ -> invariant_violation("Unexpected Row type")
          }
        }),
      )
    }
  }
}

/*****************************************************************************/
/* Reducer used by aggregate functions. */
/*****************************************************************************/

fun updateState(
  op: (CValue, CValue) ~> CValue,
  adding: Bool,
  state: mutable Array<?SKDB.CValue>,
  rows: mutable Iterator<Row>,
  aggrKinds: Array<AggrKind>,
): (Bool, Bool) {
  lastRow: ?Row = None();
  size = 0;
  for (row in rows) {
    !size = size + 2;
    for (i => vOpt in row) {
      kind = aggrKinds[i];
      repeat = row match {
      | RowValues(_, x) -> x
      | _ -> invariant_violation("Expected a RowValue")
      };
      (kind, lastRow, vOpt) match {
      | (InferSchema(), _, Some(CJSON(json))) ->
        schema = state[i] match {
        | None() -> SKJSON.Type::any
        | Some(CType(ty)) -> ty
        | _ -> invariant_violation("Unexpected schema type")
        };
        ty = json.toType();
        if (adding) !ty = schema.union(ty) else !ty = schema.remove(ty);
        state![i] = Some(CType::create(ty))
      | (InferSchema(), _, Some(CString(s))) ->
        schema = state[i] match {
        | None() -> SKJSON.Type::any
        | Some(CType(ty)) -> ty
        | _ -> invariant_violation("Unexpected schema type")
        };
        ty = SKJSON.decode(s, x -> x).toType();
        if (adding) !ty = schema.union(ty) else !ty = schema.remove(ty);
        state![i] = Some(CType::create(ty))
      | (InferSchema(), _, Some(CType(ty))) ->
        schema = state[i] match {
        | None() -> SKJSON.Type::any
        | Some(CType(x)) -> x
        | _ -> invariant_violation("Unexpected schema type")
        };
        if (adding) !ty = schema.union(ty) else !ty = schema.remove(ty);
        state![i] = Some(CType::create(ty))
      | (InferSchema(), _, _) -> continue
      | (Min(), _, None()) -> continue
      | (Min(), _, Some(_)) ->
        if (state[i] is None() && adding) state![i] = vOpt;
        if (state[i] < vOpt) continue;
        if (!adding) return (true, false);
        state![i] = vOpt
      | (Max(), _, None()) -> continue
      | (Max(), _, Some(_)) ->
        if (state[i] > vOpt) continue;
        if (!adding) return (true, false);
        state![i] = vOpt
      | (
        Sum(true),
        Some(lrow),
        Some(_),
      ) if (lrow.getInt(i) == vOpt.flatMap(x -> x.getInt())) ->
        void
      | (Sum _, _, None()) -> void
      | (Sum _, _, Some(v @ CInt(_))) ->
        state[i] match {
        | None() -> state![i] = Some(op(CInt(0), v * repeat))
        | Some(acc) -> state![i] = Some(op(acc, v * repeat))
        }

      | (Sum _, _, Some(v @ CFloat(_))) ->
        state[i] match {
        | None() -> state![i] = Some(op(CFloat(0.0), v * repeat))
        | Some(acc) -> state![i] = Some(op(acc, v * repeat))
        }

      | (
        Count(true),
        Some(lrow),
        Some(_),
      ) if (lrow.getInt(i) == vOpt.flatMap(x -> x.getInt())) ->
        void
      | (Count(_), _, None()) -> void
      | (Count(_), _, Some(_)) ->
        state[i] match {
        | None() -> state![i] = Some(op(CInt(0), CInt(repeat)))
        | Some(acc) -> state![i] = Some(op(acc, CInt(repeat)))
        }

      | (Noop(), _, x) -> state![i] = x

      | (_, _, Some(SKDB.CString _)) -> invariant_violation("Invalid aggregate")
      | (_, _, Some(SKDB.CType _)) -> invariant_violation("Invalid aggregate")
      | (_, _, Some(SKDB.CJSON _)) -> invariant_violation("Invalid aggregate")
      }
    };
    !lastRow = Some(row);
  };
  (false, lastRow is None())
}

fun reducerInit(
  aggrKinds: Array<AggrKind>,
  rows: mutable Iterator<Row>,
): Array<Row> {
  state = Array<?CValue>::mcreateFromItems(
    aggrKinds.map(kind -> {
      kind match {
      | Max()
      | Min()
      | Noop()
      | Sum(_) ->
        None()
      | Count(_) -> Some(CInt(0))
      | InferSchema() -> Some(CType::create(SKJSON.Type::any))
      }
    }),
  );
  (shouldReset, isEmpty) = updateState(
    (x, y) ~> x + y,
    true,
    state,
    rows,
    aggrKinds,
  );
  invariant(!shouldReset);
  if (isEmpty) return Array[];
  Array[RowValues::create(unsafe_chill_trust_me(state).map(x -> x))]
}

fun isPotentiallyEmpty(
  aggrKinds: Array<AggrKind>,
  state: readonly Array<?CValue>,
): Bool {
  for (i in Range(0, aggrKinds.size())) {
    if (aggrKinds[i] is Noop()) continue;
    state[i] match {
    | Some(CInt(n)) -> if (n != 0) return false
    | Some(CFloat(f)) -> if (f < -0.01 || f > 0.01) return false
    | Some(CType(ty)) -> if (ty.types.isEmpty()) return false
    | x ->
      debug(x);
      invariant_violation("Unexpected type")
    }
  };
  true
}

fun reducerUpdate(
  aggrKinds: Array<AggrKind>,
  stateRow: Array<Row>,
  oldRows: Array<Row>,
  newRows: Array<Row>,
): ?Array<Row> {
  stateRowValues: Array<?CValue> = stateRow[0] match {
  | RowValues(data, 1) -> data
  | _ -> invariant_violation("Was expecting RowValues")
  };

  state = Array::mcreateFromItems(stateRowValues);

  (shouldReset, _) = updateState(
    (x, y) ~> x - y,
    false,
    state,
    oldRows.iterator(),
    aggrKinds,
  );
  if (shouldReset) return None();
  _ = updateState((x, y) ~> x + y, true, state, newRows.iterator(), aggrKinds);

  if (newRows.isEmpty() && isPotentiallyEmpty(aggrKinds, state)) {
    return None();
  };

  values = unsafe_chill_trust_me(state).map(x -> x);
  Some(Array[RowValues::create(values)])
}

/*****************************************************************************/
/* Reducer for intersections/unions/except. */
/*****************************************************************************/

fun initUnion(rowIter: mutable Iterator<Row>): Array<Row> {
  unsortedRows = rowIter.collect(Array);

  indexes = unsortedRows
    .mapWithIndex((idx, x) ->
      x match {
      | RowKind(order, _, _) -> (order, idx)
      | _ -> (0, idx)
      }
    )
    .sorted();

  rows = Array::fillBy(unsortedRows.size(), i ->
    unsortedRows[indexes[i].i1] match {
    | r @ RowKind _ -> r
    | r ->
      debug(r);
      invariant_violation("Expected a row kind")
    }
  );

  if (rows.size() == 0) return Array[];
  count = 0;
  intersectOrder = -1;

  for (row in rows) {
    row.kind match {
    | QUnion(UIntersect()) ->
      if (row.order > intersectOrder) {
        !intersectOrder = row.order;
      }
    | QUnion(USingle()) -> !count = 1
    | QUnion(UAll()) -> !count = count + 1
    | QIntersect(nextIsIntersect) ->
      if (intersectOrder + 1 == row.order) {
        if (nextIsIntersect) {
          !intersectOrder = row.order;
          !count = 0;
        } else {
          !count = 1;
        }
      } else {
        !count = 0;
        !intersectOrder = -1;
      }
    | QExcept() -> !count = 0
    }
  };

  if (count == 0) {
    return Array[];
  };
  if (count == 1) {
    return Array[rows[0].row];
  };

  result = mutable Vector[];
  for (_ in Range(0, count)) {
    result.push(rows[0].row);
  };
  result.toArray()
}

/*****************************************************************************/
/* Builds the key used by a group by. */
/*****************************************************************************/

fun makeGroupByKey(
  context: mutable SKStore.Context,
  evaluator: ExprEvaluator,
  row: Row,
  groupBy: Array<CGroupByElt>,
): RowKey {
  rowKey = mutable Vector[];
  kinds = mutable Vector[];
  for (idx => elt in groupBy) {
    elt match {
    | CGBCol(n, ty) ->
      value = row.getValue(n);
      rowKey.push(value);
      kinds.push((idx, P.IASC(), ty))
    | CGBExpr(e, ty) ->
      value = evaluator.evalCGExpr(context, e) match {
      | ANull() -> None()
      | ADef(x) -> Some(x)
      | _ -> invariant_violation("Should have successfully interpreted")
      };
      rowKey.push(value);
      kinds.push((idx, P.IASC(), ty))
    }
  };
  result = RowKey(RowValues::create(rowKey.toArray()), kinds.toArray());
  result
}

/*****************************************************************************/
/* Reducer used by joins. */
/*****************************************************************************/

fun makeJoinReducer(
  shardTable: SKStore.EHandle<SKStore.Key, ShardStats>,
  joinKind: P.JoinKind,
  kinds: Array<(Int, P.IKind, P.Type)>,
  onlyLeftValues: Bool,
): (
  mutable SKStore.Context,
  mutable SKStore.Writer,
  SKStore.Key,
  mutable Iterator<SKStore.File>,
) ~> void {
  (context, writer, _, files) ~> {
    leftRows = mutable Vector[];
    rightRows = mutable Vector[];
    for (file in files) {
      file match {
      | LeftFile(key, leftFile) ->
        leftRows.push((key, RowValues::type(leftFile)))
      | RightFile(key, rightFile) ->
        rightRows.push((key, RowValues::type(rightFile)))
      | _ ->
        debug(file);
        invariant_violation("Unexpected file type in joinReducer")
      }
    };
    leftSize = leftRows.size();
    rightSize = rightRows.size();
    if (
      leftSize / max(1, rightSize) > 128 ||
      rightSize / max(1, leftSize) > 128
    ) {
      oldStats = getStats(context, shardTable, leftRows) match {
      | None() -> getStats(context, shardTable, rightRows)
      | x -> x
      };
      stats = oldStats match {
      | None() -> ShardStats(context.tick, pow2(leftSize), pow2(rightSize))
      | Some(x) -> x
      };
      if (oldStats is None() || stats.tick < context.tick) {
        !stats = stats with {
          tick => context.tick,
          left => stats.left * 2,
          right => stats.right * 2,
        };
        for (kv in leftRows) {
          (key, _) = kv;
          shardTable.writeArray(context, key, Array[stats]);
        };
        for (kv in rightRows) {
          (key, _) = kv;
          shardTable.writeArray(context, key, Array[stats]);
        }
      }
    };
    for (kv in leftRows) {
      (_, left) = kv;
      if (
        rightRows.isEmpty() &&
        (joinKind is P.JLeft _ || joinKind is P.JFull _)
      ) {
        values = if (onlyLeftValues) left.values else {
          right = Array::fill(kinds.size() - left.size(), None<CValue>());
          left.values.concat(right);
        };
        row = RowValues::create(values, left.repeat);
        writer.set(RowKey(row, kinds), row);
      };
      for (rkv in rightRows) {
        (_, right) = rkv;
        values = if (onlyLeftValues) left.values else {
          left.values.concat(right.values)
        };
        row = RowValues::create(values, left.repeat * right.repeat);
        writer.set(RowKey(row, kinds), row);
      }
    };
    if (
      (joinKind is P.JRight _ || joinKind is P.JFull _) &&
      !onlyLeftValues &&
      leftRows.size() == 0
    ) {
      for (kv in rightRows) {
        (_, right) = kv;
        left = Array::fill(kinds.size() - right.size(), None<CValue>());
        values = left.concat(right.values);
        row = RowValues::create(values, right.repeat);
        writer.set(RowKey(row, kinds), row);
      }
    }
  }
}

fun normalizeValueIter(
  valueIter: mutable Iterator<SKStore.File>,
): (?RowValues, ?ShardStats) {
  shardStats: ?ShardStats = None();
  valueOpt: ?RowValues = None();
  repeat = 0;
  for (v in valueIter) {
    v match {
    | stats @ ShardStats _ -> !shardStats = Some(stats)
    | r @ RowValues _ ->
      if (valueOpt is None()) !valueOpt = Some(r);
      !repeat = repeat + r.repeat
    | _ ->
      debug(v);
      invariant_violation("Unexpected type")
    }
  };
  valueOpt match {
  | None() -> (None(), None())
  | Some(v) ->
    if (repeat == 0) (None(), None()) else {
      !v = v.setRepeat(repeat);
      (Some(v), shardStats)
    }
  }
}

fun computeShardSizes(stats: ?ShardStats): (Int, Int) {
  stats match {
  | None() -> (1, 1)
  | Some(ShardStats(_, leftSize, rightSize)) ->
    (
      if (rightSize == 0 || rightSize >= leftSize) {
        1
      } else {
        leftSize / rightSize
      },
      if (leftSize == 0 || leftSize >= rightSize) {
        1
      } else {
        rightSize / leftSize;
      },
    )
  }
}

fun getStats(
  context: mutable SKStore.Context,
  shardTable: SKStore.EHandle<SKStore.Key, ShardStats>,
  x: readonly Vector<(SKStore.Key, SKStore.File)>,
): ?ShardStats {
  for (kv in x) {
    (key, _) = kv;
    oldStatsArray = context
      .unsafeGetEagerDir(shardTable.dirName)
      .getArrayRaw(key);
    if (oldStatsArray.size() != 0) {
      return Some(ShardStats::type(oldStatsArray[0]));
    }
  };
  None()
}

module end;
