/*****************************************************************************/
/* Compiles Sql queries from SqlAst to SqlCAst (for "compiled" Ast). */
/*****************************************************************************/

module SKDB;

/*****************************************************************************/
/* Determines if a select can be optimized away. */
/*****************************************************************************/

fun isNoopParams(
  params: Array<CGExpr>,
  from: Array<(DirDescr, ?Array<SKStore.KeyRange>)>,
): Bool {
  if (from.size() != 1) return false;
  kinds = from[0].i0.kinds;
  if (kinds.size() != params.size()) return false;
  for (i => param in params) {
    param match {
    | CIExpr(SKDB.CIGetFrom(0, x)) if (x == i) -> void
    | CFExpr(SKDB.CFGetFrom(0, x)) if (x == i) -> void
    | CSExpr(SKDB.CSGetFrom(0, x)) if (x == i) -> void
    | _ -> return false
    }
  };
  true
}

fun noRangeFrom(from: Array<(DirDescr, ?Array<SKStore.KeyRange>)>): Bool {
  for (tableRange in from) {
    if (tableRange.i1 is Some _) return false;
  };
  true
}

// The case that interests us specifically is in the case of a join:
// select * from t1, t2 where a = b;

// What will happen is that the result of the merge is exactly the
// result we want, so there is nothing left to do in the select.  All
// the other cases are not very interesting because if they were truly a
// noop, the query could be trivially rewritten to get rid of the
// overhead.

// Why not optimize it anyway you may ask? Because the result is going
// to be in an SKStore directory with the wrong name. Which means, every
// place where we are looking up select results by dirName are going to
// be broken.

fun optimizeNoopSelect(select: CSelect): CSelect {
  if (
    !select.distinct &&
    isNoopParams(select.params, select.from) &&
    noRangeFrom(select.from) &&
    select.sets.size() == 0 &&
    select.aggr is None() &&
    select.where is None() &&
    select.groupBy is None() &&
    select.having is None() &&
    select.orderBy is None() &&
    select.limit is None() &&
    select.rest is None() &&
    !select.needUp &&
    !select.directMode &&
    select.other.size() != 0
  ) {
    foundMerge = false;
    !select.other = select.other.map(task ->
      task match {
      | merge @ SubMerge _ if (merge.childName == select.from[0].i0.dirName) ->
        !foundMerge = true;
        !merge.childName = SKStore.DirName::create("/" + select.id.lower + "/");
        merge
      | _ -> task
      }
    );
    if (!foundMerge) return select;
    select with {isNoop => true}
  } else {
    select
  }
}

/*****************************************************************************/
/* Determines smallest window. */
/*****************************************************************************/

fun minWindowSize(x: ?Int, y: ?Int): ?Int {
  (x, y) match {
  | (Some(n1), Some(n2)) -> Some(min(n1, n2))
  | (r @ Some _, _)
  | (_, r @ Some _) ->
    r
  | (None(), None()) -> None()
  }
}

/*****************************************************************************/
/* Helper functions/types for merge joins. */
/*****************************************************************************/

class JTable{
  name: Name,
  dirName: SKStore.DirName,
  ranges: ?Array<SKStore.KeyRange>,
  schema: Array<SKDB.ColumnDefinition>,
  alias: ?Name,
} {
  static fun fromDirDescr(
    dirDescr: DirDescr,
    ranges: ?Array<SKStore.KeyRange>,
  ): this {
    JTable{
      name => dirDescr.name,
      dirName => dirDescr.dirName,
      ranges,
      schema => dirDescr.schema,
      alias => dirDescr.alias,
    }
  }
}

value class TableProj(tableNbr: Int, col: (Int, IKind, Type), isUnique: Bool)
value class EqJoin(left: TableProj, right: TableProj)

fun isUnique(tyDescr: ColumnDefinition): Bool {
  tyDescr.primary is Some _ || tyDescr.unique is Some _
}

const crossJoinMsg: String = `
This will be interpreted as a cross-join, which is almost
certainly not what you want.
If you are absolutely sure that's what you want to do, you can pass
the option '--always-allow-joins' to make this error go away.`;

const multipleTablesNoUniqueMsg: String = `
SELECT involves multiple tables but none of them defines a unique column.
`;

const multipleTablesNoClauseMsg: String = `
SELECT involves multiple tables but no appropriate join clause was found.
`;

fun errorNoMergeClause(pos: Int): void {
  errorNbr(
    1,
    pos,
    multipleTablesNoClauseMsg +
      "Was expecting to find a clause of the form:\n" +
      "... AND colName1 = colName2 AND ...\n" +
      "\n" +
      crossJoinMsg,
  )
}

/*****************************************************************************/
/* Finds table */
/*****************************************************************************/

mutable class Compiler{
  directMode: Bool,
  options: Options,
  pos: Int,
  params: Map<String, Value>,
  mutable subst: mutable Map<Identifier, CGExpr> = mutable Map[],
  mutable ambiguous: mutable Set<Identifier> = mutable Set[],
  mutable isAggr: Bool = false,
  mutable aggrVars: mutable Vector<(AggrKind, CGExpr)> = mutable Vector[],
  mutable needUp: Bool = false,
  mutable other: mutable Vector<SubSelectTask> = mutable Vector[],
} {
  static fun create(
    directMode: Bool,
    options: Options,
    pos: Int,
    params: Map<String, Value>,
  ): mutable this {
    mutable static{directMode, options, pos, params}
  }

  mutable fun expandGroupBy(select: Select): Select {
    // Tranforms:
    // 'select ... from ... group by ...'
    // ==> 'select * from (select ... from ... group by ...)'

    Select{
      pos => select.pos,
      id => select.id,
      distinct => select.distinct,
      params => Array[SelectStar(None())],
      from => Some(
        Array[
          TableName(
            FQuery(
              select with {
                id => Name::create(select.id.lower + "-groupBy"),
                distinct => false,
                orderBy => None(),
                limit => None(),
                rest => None(),
                shouldExpand => false,
              },
            ),
            None(),
            false,
          ),
        ],
      ),
      where => None(),
      groupBy => None(),
      having => None(),
      join => None(),
      orderBy => select.orderBy,
      limit => select.limit,
      shouldExpand => false,
      rest => select.rest.map(x -> (x.i0, x.i1 with {shouldExpand => true})),
    }
  }

  mutable fun compileSelect(
    context: mutable SKStore.Context,
    select: Select,
    toplevel: Bool,
    sets: Array<UpdateSet> = Array[],
  ): CSelect {
    if (
      select.distinct ||
      select.shouldExpand ||
      toplevel &&
        (select.orderBy is Some _ || select.limit is Some _) &&
        (select.groupBy is Some _) ||
      (select.rest is Some _ || toplevel) &&
        selectOrRestIsAggrOrEmptyFrom(select)
    ) {
      !select = this.expandGroupBy(select);
    };

    !select = this.expandJoins(select);

    substCopy = this.subst;
    ambiguousCopy = this.ambiguous;
    aggrVarsCopy = this.aggrVars;
    needUpCopy = this.needUp;
    isAggrCopy = this.isAggr;
    otherCopy = this.other;

    isAggr = selectIsAggr(select);
    this.!isAggr = isAggr;

    newSubst = mutable Map[];
    for (key => value in this.subst) {
      if (key.table is Some _) {
        newSubst![key] = value.up();
      }
    };

    newAmbiguous = mutable Set[];
    for (key in this.ambiguous) {
      if (key.table is Some _) {
        newAmbiguous.add(key);
      }
    };

    this.!subst = newSubst;
    this.!ambiguous = newAmbiguous;
    this.!aggrVars = mutable Vector[];
    this.!needUp = false;
    this.!other = mutable Vector[];

    origFrom = this.compileFrom(context, select.from);
    (cond, from) = this.compileJoin(context, origFrom, select.where);
    !select.where = cond;
    params = this.compileParams(context, select.params, origFrom);
    where = this.compileWhere(context, select.where);
    groupBy = this.compileGroupBy(context, select.groupBy, params);
    having = this.compileHaving(context, select.having);

    orderBy = this.compileOrderBy(select.params, from, select.orderBy);
    limit = this.compileLimit(context, select.limit);
    aggr: ?Array<(AggrKind, CGExpr)> = None();
    if (this.aggrVars.size() != 0) {
      !aggr = Some(this.aggrVars.toArray());
    };

    kinds = orderBy match {
    | None() ->
      i = 0;
      params.map(param -> {
        result = (i, IASC(), param.getType());
        !i = i + 1;
        result
      })
    | Some(ekinds) -> computeKinds(params, ekinds)
    };

    needUp = this.needUp;
    other = this.other.toArray();
    csets = this.compileSets(context, sets);

    this.!subst = substCopy;
    this.!ambiguous = ambiguousCopy;
    this.!aggrVars = aggrVarsCopy;
    this.!needUp = needUpCopy;
    this.!isAggr = isAggrCopy;
    this.!other = otherCopy;

    rest = this.compileRest(context, params, select.rest);

    /*
     * Direct mode is a setup where we want to output things on stdout
     * directly. Of course, that will not work with any kind of
     * query. So we restrict ourselves to queries of the form:
     * "select ... from ... where ..."
     *
     * (when exactly one table is involved). We don't use direct mode
     * when an index is involved because the result set is typically
     * small enough that direct mode won't matter. And it saves us a lot
     * of headache in the logic running the loop (no need to lookup the
     * index etc ...).
     */

    directMode =
      aggr is None() &&
      this.directMode &&
      toplevel &&
      /* There is exactly one table */
      from.size() == 1 &&
      /* No index is involved (could change in the future?)  */
      from[0].i1 is None() &&
      !select.distinct &&
      having is None() &&
      orderBy is None() &&
      groupBy is None() &&
      rest is None();

    format = this.options.format match {
    | OFK_CSV() -> SKStore.OCSV()
    | OFK_Table() ->
      schema = static::getSchema(select.params, from, params);
      fieldNames = schema.map(x -> x.name.origName);
      SKStore.OTable(fieldNames)
    | OFK_JSON() ->
      schema = static::getSchema(select.params, from, params);
      fieldNames = schema.map(x -> x.name.origName);
      SKStore.OJSON(fieldNames)
    | OFK_SQL() -> SKStore.OSQL()
    | OFK_JS() ->
      schema = static::getSchema(select.params, from, params);
      fieldNames = schema.map(x -> x.name.origName);
      SKStore.OJS(fieldNames)
    };

    cselect = CSelect{
      id => Name::create(
        select.id.lower +
          context.getGlobal("TableMap") match {
          | None() -> ""
          | Some(file) -> "_V" + TableMap::type(file).version.value.toString()
          },
      ),
      distinct => select.distinct,
      params,
      sets => csets,
      aggr,
      from,
      kinds,
      where => if (where is Some(CILiteral(1))) None() else where,
      groupBy,
      having,
      orderBy,
      limit,
      rest,
      needUp,
      directMode,
      format,
      other,
    };

    !cselect = optimizeNoopSelect(cselect);

    cselect
  }

  mutable fun compileSets(
    context: mutable SKStore.Context,
    params: Array<UpdateSet>,
  ): Array<(Int, CGExpr)> {
    this.noAggr(() -> {
      params.map(set -> {
        if (set.columns.size() != 1) {
          error(this.pos, "UPDATE ... SET a, b, c = expr not implemented")
        };
        (pos, colName) = set.columns[0];
        e = set.value;
        this.compileExpr(context, Identifier(colName)) match {
        | (CIExpr(CIGetFrom(0, n))) ->
          this.compileExpr(context, e) match {
          | CGNull() -> (n, CGNull())
          | v @ CIExpr(_) -> (n, v)
          | _ -> errorNbr(2, pos, "Incompatible types for set")
          }
        | (CFExpr(CFGetFrom(0, n))) ->
          this.compileExpr(context, e) match {
          | CGNull() -> (n, CGNull())
          | v @ CFExpr(_) -> (n, v)
          | _ -> errorNbr(2, pos, "Incompatible types for set")
          }
        | (CSExpr(CSGetFrom(0, n))) ->
          this.compileExpr(context, e) match {
          | CGNull() -> (n, CGNull())
          | v @ CSExpr(_) -> (n, v)
          | _ -> errorNbr(2, pos, "Incompatible types for set")
          }
        | _ -> errorNbr(3, pos, "Invalid set")
        };
      })
    })
  }

  mutable fun compileParams(
    context: mutable SKStore.Context,
    selectParams: Array<SelectResult>,
    origFrom: Array<DirDescr>,
  ): Array<CGExpr> {
    origFromMap = mutable Map[];
    for (table in origFrom) {
      if (!origFromMap.containsKey(table.name)) {
        origFromMap![table.name] = table;
      };
      table.alias match {
      | Some(alias) if (!origFromMap.containsKey(alias)) ->
        origFromMap![alias] = table
      | _ -> void
      }
    };
    expandedSParams = mutable Vector[];
    for (tableNbr => param in selectParams) {
      param match {
      | SelectStar(None()) ->
        for (dirDescr in origFrom) {
          tableName = dirDescr.alias match {
          // NOTE: This branch is actually never taken because `compileFrom()`
          // unconditionally sets `dirDescr.alias` to the desired value.
          | None() -> Name::create(`${dirDescr.name.origName}_${tableNbr}`)
          | Some(x) -> x
          };
          for (varName in dirDescr.colNames) {
            expandedSParams.push(
              SelectExpr(Identifier(varName, Some(tableName)), None()),
            )
          }
        }

      | SelectStar(Some(tableName)) ->
        if (!origFromMap.containsKey(tableName)) {
          error(this.pos, `Table not found: ${tableName}`);
        };
        tableDescr = origFromMap[tableName];
        for (colName in tableDescr.colNames) {
          expandedSParams.push(
            SelectExpr(Identifier(colName, Some(tableName)), None()),
          )
        }

      | p @ SelectExpr _ -> expandedSParams.push(p)
      }
    };

    expandedSParams.toArray().map(param -> {
      this.compileExpr(context, param.expr)
    })
  }

  mutable fun compileFrom(
    context: mutable SKStore.Context,
    from: ?Array<TableName>,
  ): Array<SKDB.DirDescr> {
    from match {
    | None() -> Array[]
    | Some(fromTables) ->
      tableNbr = 0;

      tables = fromTables.mapWithIndex((tableNbr, fromTable) -> {
        table = this.getFromDirDescr(context, fromTable.name);
        tableAlias = fromTable.asName match {
        | Some(x) -> x
        | None() -> Name::create(`${table.name.origName}_${tableNbr}`)
        };
        !table.alias = Some(tableAlias);
        table
      });

      for (i => fromName in fromTables) {
        table = tables[i];
        tableName = table.name;

        for (colName => colNbr in table.cols) {
          this.addGetFrom(tableNbr, table.schema, Identifier(colName), colNbr);
          if (fromName.asName is None _) {
            this.addGetFrom(
              tableNbr,
              table.schema,
              Identifier(colName, Some(table.alias.fromSome())),
              colNbr,
            )
          }
        };
        fromName.asName match {
        | None() ->
          for (colName => colNbr in table.cols) {
            dotName = Identifier(colName, Some(tableName));
            this.addGetFrom(tableNbr, table.schema, dotName, colNbr)
          }
        | Some(asName) ->
          for (colName => colNbr in table.cols) {
            dotName = Identifier(colName, Some(asName));
            this.addGetFrom(tableNbr, table.schema, dotName, colNbr)
          }
        };

        !tableNbr = tableNbr + 1;
      };

      !tableNbr = 0;

      for (i => fromName in fromTables) {
        table = tables[i];
        tableName = table.name;

        fromName.asName match {
        | None() -> void
        | Some(_) ->
          for (colName => colNbr in table.cols) {
            dotName = Identifier(colName, Some(tableName));
            if (!this.subst.containsKey(dotName)) {
              this.addGetFrom(tableNbr, table.schema, dotName, colNbr)
            }
          }
        };

        !tableNbr = tableNbr + 1;
      };

      tables
    }
  }

  mutable fun addGetFrom(
    tableNbr: Int,
    schema: Array<ColumnDefinition>,
    colName: Identifier,
    colNbr: Int,
  ): void {
    if (this.subst.containsKey(colName)) {
      this.ambiguous.insert(colName);
    } else {
      this.subst![colName] = schema[colNbr].ty match {
      | FLOAT() -> CFExpr(CFGetFrom(tableNbr, colNbr))
      | INTEGER() -> CIExpr(CIGetFrom(tableNbr, colNbr))
      | TEXT() -> CSExpr(CSGetFrom(tableNbr, colNbr))
      }
    }
  }

  mutable fun getFromDirDescr(
    context: mutable SKStore.Context,
    name: FromName,
  ): DirDescr {
    name match {
    | FName(tableName) -> getTable(context, this.pos, tableName)

    | FQuery(select @ Select _) ->
      cselect = this.compileSelect(context, select, false);
      selectDir = evalSelect(context, cselect, None());
      static::getDirDescr(
        select.params,
        cselect.from,
        cselect.params,
        Name::create(selectDir.dirName.toString()),
        selectDir.dirName,
      )
    }
  }

  static fun getCols(
    params: Array<SelectResult>,
    from: Array<(DirDescr, ?Array<SKStore.KeyRange>)>,
  ): (SortedMap<Name, Int>, readonly Map<Int, Name>) {
    cols = SortedMap[];
    invCols = mutable Map[];
    slot = 0;

    origFromMap = mutable Map[];
    for (tableRange in from) {
      (table, _range) = tableRange;
      if (!origFromMap.containsKey(table.name)) {
        origFromMap![table.name] = table;
      };
      table.alias match {
      | Some(alias) if (!origFromMap.containsKey(alias)) ->
        origFromMap![alias] = table
      | _ -> void
      }
    };

    for (param in params) {
      param match {
      | SelectStar(None()) ->
        for (dirDescr in from) {
          for (tyName in dirDescr.i0.colNames) {
            if (!cols.containsKey(tyName)) {
              !cols[tyName] = slot;
              invCols![slot] = tyName;
            };
            !slot = slot + 1;
          }
        }

      | SelectStar(Some(tableName)) ->
        dirDescr = origFromMap[tableName];
        for (tyName in dirDescr.colNames) {
          if (!cols.containsKey(tyName)) {
            !cols[tyName] = slot;
            invCols![slot] = tyName;
          };
          !slot = slot + 1;
        }

      | SelectExpr(_, Some(aliasColName)) ->
        if (cols.containsKey(aliasColName)) continue;
        !cols[aliasColName] = slot;
        invCols![slot] = aliasColName;
        !slot = slot + 1

      | SelectExpr(Identifier(colName, _), None _) ->
        if (cols.containsKey(colName)) continue;
        !cols[colName] = slot;
        invCols![slot] = colName;
        !slot = slot + 1
      | _ -> !slot = slot + 1
      }
    };

    (cols, invCols)
  }

  static fun getSchema(
    params: Array<SelectResult>,
    from: Array<(DirDescr, ?Array<SKStore.KeyRange>)>,
    cparams: Array<CGExpr>,
  ): Array<ColumnDefinition> {
    (cols, invCols) = static::getCols(params, from);
    cparams.mapWithIndex((idx, param) -> {
      ColumnDefinition{
        name => invCols.maybeGet(idx) match {
        | None() ->
          col = Name::create("col<" + idx + ">");
          // FIXME: This is a noop?
          !cols[col] = idx;
          col
        | Some(x) -> x
        },
        ty => param.getType(),
      }
    })
  }

  static fun getDirDescr(
    params: Array<SelectResult>,
    from: Array<(DirDescr, ?Array<SKStore.KeyRange>)>,
    cparams: Array<CGExpr>,
    selectId: Name,
    dirName: SKStore.DirName,
    view: Bool = false,
  ): DirDescr {
    schema = static::getSchema(params, from, cparams);
    DirDescr::create{
      name => selectId,
      schema,
      dirName,
      alias => Some(selectId),
      isInput => false,
      view,
    }
  }

  readonly fun expandJoins(select: Select): Select {
    select.join match {
    | None() -> select
    | Some(join) ->
      join.kind match {
      | JCross() ->
        !select.from = select.from match {
        | None() -> Some(join.names)
        | Some(names) -> Some(names.concat(join.names))
        };
        !select.join = None();
        select
      | _ ->
        !select.from = select.from match {
        | None() -> Some(join.names)
        | Some(names) -> Some(names.concat(join.names))
        };
        !select.join = None();
        join.on match {
        | None() -> errorNbr(4, this.pos, "Expected ON after JOIN")
        | Some((onClause, clauses)) ->
          clauseIter = clauses.iterator();

          for (clause in clauseIter) {
            !onClause = BinOp(OAnd(), onClause, clause);
          };
          !select.where = select.where match {
          | None() -> Some(On(join.kind, onClause))
          | Some(where) -> Some(BinOp(OAnd(), On(join.kind, onClause), where))
          };
          select
        }
      }
    }
  }

  mutable fun compileWhere(
    context: mutable SKStore.Context,
    whereOpt: ?Expr,
  ): ?CExpr<Int> {
    this.noAggr(() -> {
      whereOpt match {
      | None() -> None()
      | Some(expr) ->
        this.compileExpr(context, expr) match {
        | CGNull() -> Some(CNull())
        | CIExpr(x) -> Some(x)
        | CFExpr _ -> errorNbr(5, this.pos, "A where clause cannot be a FLOAT")
        | CSExpr _ -> errorNbr(5, this.pos, "A where clause cannot be a STRING")
        }
      }
    })
  }

  mutable fun compileGroupBy(
    context: mutable SKStore.Context,
    groupByOpt: ?Array<Expr>,
    params: Array<CGExpr>,
  ): ?Array<CGroupByElt> {
    groupByOpt match {
    | None() -> None()
    | Some(groupBy) ->
      Some(
        groupBy.map(group -> {
          this.compileExpr(context, group) match {
          | CIExpr(CILiteral(nIndexedAt1)) ->
            n = nIndexedAt1 - 1;
            if (n < 0 || n >= params.size()) {
              errorNbr(6, this.pos, "GROUP BY out of bounds");
            };
            e = params[n];
            CGBExpr(e, e.getType())
          | e -> CGBExpr(e, e.getType())
          }
        }),
      )
    }
  }

  mutable fun compileHaving(
    context: mutable SKStore.Context,
    havingOpt: ?Expr,
  ): ?CExpr<Int> {
    havingOpt.map(e ->
      this.compileExpr(context, e) match {
      | CGNull() -> CILiteral(0)
      | CIExpr(x) -> x
      | _ -> errorNbr(7, this.pos, "Invalid type for HAVING clause")
      }
    )
  }

  mutable fun compileRest(
    context: mutable SKStore.Context,
    cparams: Array<CGExpr>,
    rest: ?(CompoundOperator, Select),
  ): ?(QueryKind, CSelect) {
    crest = rest.map(x ->
      (
        x.i0 match {
        | COUnion() -> QUnion(USingle())
        | COUnionAll() -> QUnion(UAll())
        | COExcept() -> QExcept()
        | COIntersect() -> QIntersect(false)
        },
        this.compileSelect(context, x.i1, false),
      )
    );
    crest match {
    | None() -> void
    | Some((_, query)) ->
      qparams = query.params;
      if (cparams.size() != qparams.size()) {
        errorNbr(8, this.pos, "Incompatible select width for union");
      };
      for (i in Range(0, qparams.size())) {
        if (qparams[i].getType() != cparams[i].getType()) {
          errorNbr(9, this.pos, "Incompatible types for union");
        }
      }
    };
    crest
  }

  mutable fun compileOrderBy(
    params: Array<SelectResult>,
    from: Array<(SKDB.DirDescr, ?Array<SKStore.KeyRange>)>,
    orderByOpt: ?Array<(Expr, IKind)>,
  ): ?Array<(Int, IKind)> {
    orderByOpt match {
    | None() -> None()
    | Some(orderBy) ->
      (cols, _) = static::getCols(params, from);
      Some(
        orderBy.map(kv -> {
          (order, kind) = kv;
          order match {
          | VInt(n) -> (n, kind)
          | colName @ Identifier _ ->
            if (colName.table is Some _) {
              error(this.pos, "ORDER BY foo.bar not supported")
            };
            if (cols.containsKey(colName.name)) {
              (cols[colName.name] + 1, kind)
            } else {
              errorNbr(
                10,
                this.pos,
                `invalid ORDER BY, unbound name ${colName}`,
              )
            }
          | _ -> errorNbr(11, this.pos, "invalid ORDER BY")
          }
        }),
      )
    }
  }

  mutable fun compileLimit(
    context: mutable SKStore.Context,
    limit: ?Expr,
  ): ?CExpr<Int> {
    limit match {
    | None() -> None()
    | Some(e) ->
      this.compileExpr(context, e) match {
      | CIExpr(i) -> Some(i)
      | _ -> errorNbr(13, this.pos, "Invalid limit")
      }
    }
  }

  mutable fun compileExpr(
    context: mutable SKStore.Context,
    expr: Expr,
  ): CGExpr {
    expr match {
    | VNull() -> CGNull()
    | VInt(i) -> CIExpr(CILiteral(i))
    | VFloat(f) -> CFExpr(CFLiteral(f))
    | VString(s) -> CSExpr(CSLiteral(s))
    | VSeqNum _ -> invariant_violation("Unexpected SeqNum")
    | VSId _ -> invariant_violation("Unexpected SID")
    | VTime _ -> invariant_violation("Unexpected TIME")
    | VParam(handle) ->
      this.params.maybeGet(handle) match {
      | Some(val) -> this.compileExpr(context, val)
      | None() -> error(this.pos, "Unbound parameter: " + handle)
      }
    | id @ Identifier _ ->
      if (this.ambiguous.contains(id)) {
        error(this.pos, `Ambiguous name: ${id}`);
      };
      this.subst.maybeGet(id) match {
      | None() -> error(this.pos, `Unbound name: ${id}`)
      | Some(e) ->
        e match {
        | CIExpr(CUp _)
        | CFExpr(CUp _)
        | CSExpr(CUp _) ->
          this.!needUp = true
        | _ -> void
        };
        if (this.isAggr) {
          slot = this.aggrVars.size();
          this.aggrVars.push((Noop(), e));
          e.getType() match {
          | INTEGER() -> CIExpr(CIGetFrom(0, slot))
          | FLOAT() -> CFExpr(CFGetFrom(0, slot))
          | TEXT() -> CSExpr(CSGetFrom(0, slot))
          }
        } else {
          e
        }
      }

    | Tuple _ -> invariant_violation("not implemented")

    | BinOp(OIs(true), e1, e2) ->
      this.compileExpr(context, UnOp(UnaryNot(), BinOp(OIs(false), e1, e2)))

    | BinOp(OIs(false), e, VNull()) ->
      CIExpr(
        this.compileExpr(context, e) match {
        | CGNull() -> CILiteral(1)
        | CIExpr(i) -> CIIsNull(i)
        | CFExpr(f) -> CFIsNull(f)
        | CSExpr(s) -> CSIsNull(s)
        },
      )

    | BinOp(OIs(false), e, UnOp(UnaryNot(), VNull())) ->
      CIExpr(
        CNot(
          this.compileExpr(context, e) match {
          | CGNull() -> CILiteral(1)
          | CIExpr(i) -> CIIsNull(i)
          | CFExpr(f) -> CFIsNull(f)
          | CSExpr(s) -> CSIsNull(s)
          },
        ),
      )

    | Between(e1, e2, e3, false) ->
      (
        this.compileExpr(context, e1),
        this.compileExpr(context, e2),
        this.compileExpr(context, e3),
      ) match {
      | (CGNull(), _, _) -> CGNull()
      | (_, CGNull(), CGNull()) -> CGNull()

      | (CIExpr(i1), CIExpr(i2), CIExpr(i3)) -> CIExpr(CIBetween(i1, i2, i3))
      | (CIExpr(i1), CGNull(), CIExpr(i3)) -> CIExpr(CIBetween(i1, CNull(), i3))
      | (CIExpr(i1), CIExpr(i2), CGNull()) -> CIExpr(CIBetween(i1, i2, CNull()))

      | (CFExpr(f1), CFExpr(f2), CFExpr(f3)) -> CIExpr(CFBetween(f1, f2, f3))
      | (CFExpr(f1), CGNull(), CFExpr(f3)) -> CIExpr(CFBetween(f1, CNull(), f3))
      | (CFExpr(f1), CFExpr(f2), CGNull()) -> CIExpr(CFBetween(f1, f2, CNull()))

      | (CSExpr(s1), CSExpr(s2), CSExpr(s3)) -> CIExpr(CSBetween(s1, s2, s3))
      | (CSExpr(s1), CGNull(), CSExpr(s3)) -> CIExpr(CSBetween(s1, CNull(), s3))
      | (CSExpr(s1), CSExpr(s2), CGNull()) -> CIExpr(CSBetween(s1, s2, CNull()))

      | _ -> error(this.pos, "Type error: BETWEEN")
      }

    | Between(e1, e2, e3, true) ->
      (
        this.compileExpr(context, e1),
        this.compileExpr(context, e2),
        this.compileExpr(context, e3),
      ) match {
      | (CGNull(), _, _) -> CGNull()
      | (_, CGNull(), CGNull()) -> CGNull()

      | (CIExpr(i1), CIExpr(i2), CIExpr(i3)) -> CIExpr(CINotBetween(i1, i2, i3))
      | (CIExpr(i1), CGNull(), CIExpr(i3)) ->
        CIExpr(CINotBetween(i1, CNull(), i3))
      | (CIExpr(i1), CIExpr(i2), CGNull()) ->
        CIExpr(CINotBetween(i1, i2, CNull()))

      | (CFExpr(f1), CFExpr(f2), CFExpr(f3)) -> CIExpr(CFNotBetween(f1, f2, f3))
      | (CFExpr(f1), CGNull(), CFExpr(f3)) ->
        CIExpr(CFNotBetween(f1, CNull(), f3))
      | (CFExpr(f1), CFExpr(f2), CGNull()) ->
        CIExpr(CFNotBetween(f1, f2, CNull()))

      | (CSExpr(s1), CSExpr(s2), CSExpr(s3)) -> CIExpr(CSNotBetween(s1, s2, s3))
      | (CSExpr(s1), CGNull(), CSExpr(s3)) ->
        CIExpr(CSNotBetween(s1, CNull(), s3))
      | (CSExpr(s1), CSExpr(s2), CGNull()) ->
        CIExpr(CSNotBetween(s1, s2, CNull()))

      | _ -> error(this.pos, "Type error: NOT BETWEEN")
      }

    | Like(ge1, ge2, escape, true) ->
      this.compileExpr(context, UnOp(UnaryNot(), Like(ge1, ge2, escape, false)))

    | Like(ge1, ge2, escape, false) ->
      if (escape is Some _) {
        error(this.pos, "LIKE ESCAPE not implemented")
      };
      pattern = ge2 match {
      | VString(str) -> str
      | VParam(handle) ->
        this.params.maybeGet(handle) match {
        | Some(VString(str)) -> str
        | Some(_) -> error(this.pos, "Expected string parameter: " + handle)
        | None() -> error(this.pos, "Unbound parameter: " + handle)
        }

      | _ -> error(this.pos, "Invalid LIKE, expected a pattern")
      };

      this.compileExpr(context, ge1) match {
      | CSExpr(e1) -> CIExpr(CSLike(e1, parsePattern(pattern.chars())))
      | _ -> error(this.pos, "Invalid LIKE, expected a string")
      }

    | BinOp(bop, ge1, ge2) ->
      cge1 = this.compileExpr(context, ge1);
      cge2 = this.compileExpr(context, ge2);
      this.compileBinop(cge1, cge2, bop)

    | Case(None(), whenCases, Some(last)) ->
      result = this.compileExpr(context, last);
      for (whenCase in whenCases.reversed()) {
        (cond, action) = whenCase;
        !result = this.makeIf(
          this.compileExpr(context, cond),
          this.compileExpr(context, action),
          result,
        );
      };
      result
    | Case(Some(value), whenCases, Some(last)) ->
      result = this.compileExpr(context, last);
      for (whenCase in whenCases.reversed()) {
        (matchValue, action) = whenCase;
        !result = this.makeIf(
          this.compileExpr(context, BinOp(OEq(), value, matchValue)),
          this.compileExpr(context, action),
          result,
        );
      };
      result
    | Subquery(select @ Select _) ->
      cselect = this.compileSelect(context, select, false);
      if (cselect.params.size() != 1) {
        error(this.pos, "Invalid type for inner SELECT");
      };
      cselect.params[0].getType() match {
      | INTEGER() -> CIExpr(CIQuery(cselect))
      | FLOAT() -> CFExpr(CFQuery(cselect))
      | TEXT() -> CSExpr(CSQuery(cselect))
      }
    | Exists(select, true) ->
      this.compileExpr(context, UnOp(UnaryNot(), Exists(select, false)))
    | Exists(select @ Select _, false) ->
      CIExpr(CExists(this.compileSelect(context, select, false)))

    | In(_, InSelect _, _) -> error(this.pos, "IN SELECT not implemented")
    | e @ In(_, _, true) ->
      this.compileExpr(context, UnOp(UnaryNot(), e with {negated => false}))
    | In(e, InList(arr), false) ->
      this.compileExpr(context, e) match {
      | CGNull() -> CGNull()
      | CIExpr(i) ->
        set = arr.map(x ->
          this.compileExpr(context, x) match {
          | CIExpr(n) -> n
          | _ -> error(this.pos, "Incompatible types: IN")
          }
        );
        CIExpr(CIIn(i, set))

      | CFExpr(f) ->
        set = arr.map(x ->
          this.compileExpr(context, x) match {
          | CFExpr(n) -> n
          | _ -> error(this.pos, "Incompatible types: IN")
          }
        );
        CIExpr(CFIn(f, set))

      | CSExpr(s) ->
        set = arr.map(x ->
          this.compileExpr(context, x) match {
          | CSExpr(n) -> n
          | _ -> error(this.pos, "Incompatible types: IN")
          }
        );
        CIExpr(CSIn(s, set))
      }

    | UnOp(UnaryNot(), e) ->
      this.compileExpr(context, e) match {
      | CGNull() -> CGNull()
      | CIExpr(b) -> CIExpr(CNot(b))
      | _ ->
        debug(e);
        error(this.pos, "Invalid type for NOT")
      }

    | UnOp(UnaryMinus(), e) ->
      val = this.compileExpr(context, e);
      val match {
      | CGNull() -> CGNull()
      | CIExpr(i) -> CIExpr(CSub(CILiteral(0), i))
      | CFExpr(f) -> CFExpr(CSub(CFLiteral(0.0), f))
      | CSExpr _ -> error(this.pos, "cannot apply - on a string")
      }

    | UnOp(UnaryPlus(), e) ->
      val = this.compileExpr(context, e);
      val match {
      // FIXME: SQLite treats unary plus as a noop regardless of type.
      | CSExpr _ -> error(this.pos, "cannot apply + on a string")
      | x -> x
      }
    | UnOp _ -> error(this.pos, "operator not implemented")

    | Call(fname, args, distinct) ->
      fname.lower match {
      | "local_sequence_number" ->
        if (args.size() == 0) {
          return CIExpr(CILiteral(SKStore.genSym(0)))
        };
        if (args.size() != 1) {
          error(this.pos, "local_sequence_number expects at most one argument")
        };
        args[0] match {
        | VString(varName) ->
          globals = context.getGlobal(GLOBALS) match {
          | None() ->
            error(this.pos, "Unknown local_sequence_number name " + varName)
          | Some(file) -> Globals::type(file)
          };
          if (!globals.containsKey(varName)) {
            error(this.pos, "Unknown local_sequence_number name " + varName)
          };
          CIExpr(CILiteral(globals[varName]))
        | _ -> error(this.pos, "local_sequence_number expects a string literal")
        }
      | "sid" ->
        if (args.size() == 0) {
          return CSExpr(CSLiteral(Ksuid::create().toString()))
        };
        if (args.size() != 1) {
          error(this.pos, "sid expects at most one argument")
        };
        args[0] match {
        | VString(varName) ->
          namedIDs = context.getGlobal(NAMEDIDS) match {
          | None() -> error(this.pos, "Unknown id " + varName)
          | Some(file) -> NamedIDs::type(file)
          };
          if (!namedIDs.containsKey(varName)) {
            error(this.pos, "Unknown id " + varName)
          };
          CSExpr(CSLiteral(namedIDs[varName]))
        | _ -> error(this.pos, "sid expects a string literal")
        }
      | "skdb_permission" ->
        if (args.size() != 1) {
          error(this.pos, "skdb_permission expects one argument")
        };
        perm_str = args[0] match {
        | VString(str) -> str
        | _ -> error(this.pos, "skdb_permission expects a string literal")
        };
        res = 0;
        if (perm_str.contains("r")) {
          !res = res.or(kReadPermission)
        };
        if (perm_str.contains("i")) {
          !res = res.or(kInsertPermission)
        };
        if (perm_str.contains("d")) {
          !res = res.or(kDeletePermission)
        };
        if (perm_str.contains("w")) {
          !res = res.or(kInsertPermission).or(kDeletePermission)
        };
        CIExpr(CILiteral(res))
      | "upper" ->
        if (args.size() != 1) {
          error(this.pos, "upper expects one argument")
        };
        this.compileExpr(context, args[0]) match {
        | CGNull _ -> CGNull()
        | CSExpr(e) -> CSExpr(CSUpper(e))
        | _ -> error(this.pos, "upper expects a string")
        }
      | "lower" ->
        if (args.size() != 1) {
          error(this.pos, "lower expects one argument")
        };
        this.compileExpr(context, args[0]) match {
        | CGNull _ -> CGNull()
        | CSExpr(e) -> CSExpr(CSLower(e))
        | _ -> error(this.pos, "lower expects a string")
        }
      | "coalesce" ->
        if (args.isEmpty()) {
          error(this.pos, "Missing arguments for COALESCE")
        };
        tvalues = args.map(x -> this.compileExpr(context, x));
        ty = for (val in tvalues) {
          val match {
          | CGNull _ -> continue
          | CIExpr _ -> break Some(INTEGER())
          | CFExpr _ -> break Some(FLOAT())
          | CSExpr _ -> break Some(TEXT())
          }
        } else {
          None()
        };
        ty match {
        | None() -> CGNull()
        | Some(INTEGER()) ->
          CIExpr(
            CCoalesce(
              tvalues.map(tvalue ->
                tvalue match {
                | CGNull() -> CNull()
                | CIExpr(e) -> e
                | _ -> error(this.pos, "Inconsistent types in coalesce")
                }
              ),
            ),
          )
        | Some(FLOAT()) ->
          CFExpr(
            CCoalesce(
              tvalues.map(tvalue ->
                tvalue match {
                | CGNull() -> CNull()
                | CFExpr(e) -> e
                | _ -> error(this.pos, "Inconsistent types in coalesce")
                }
              ),
            ),
          )
        | Some(TEXT()) ->
          CSExpr(
            CCoalesce(
              tvalues.map(tvalue ->
                tvalue match {
                | CGNull() -> CNull()
                | CSExpr(e) -> e
                | _ -> error(this.pos, "Inconsistent types in coalesce")
                }
              ),
            ),
          )
        }

      | "sum" ->
        this.noAggr(() -> {
          if (args.size() != 1) {
            error(this.pos, "Invalid number of arguments for sum")
          };
          this.compileExpr(context, args[0]) match {
          | e @ CIExpr(_) ->
            slot = this.aggrVars.size();
            this.aggrVars.push((Sum(distinct), e));
            CIExpr(CIGetFrom(0, slot))
          | e @ CFExpr(_) ->
            slot = this.aggrVars.size();
            this.aggrVars.push((Sum(distinct), e));
            CFExpr(CFGetFrom(0, slot))
          | CSExpr _ -> error(this.pos, "Cannot call sum on a string")
          | CGNull _ -> CGNull()
          }
        })

      | "min" ->
        this.noAggr(() -> {
          if (args.size() != 1) {
            error(this.pos, "Invalid number of arguments for min")
          };
          this.compileExpr(context, args[0]) match {
          | e @ CIExpr(_) ->
            slot = this.aggrVars.size();
            this.aggrVars.push((Min(), e));
            CIExpr(CIGetFrom(0, slot))
          | e @ CFExpr(_) ->
            slot = this.aggrVars.size();
            this.aggrVars.push((Min(), e));
            CFExpr(CFGetFrom(0, slot))
          | e @ CSExpr(_) ->
            slot = this.aggrVars.size();
            this.aggrVars.push((Min(), e));
            CSExpr(CSGetFrom(0, slot))
          | CGNull _ -> CGNull()
          }
        })

      | "max" ->
        this.noAggr(() -> {
          if (args.size() != 1) {
            error(this.pos, "Invalid number of arguments for max")
          };
          this.compileExpr(context, args[0]) match {
          | e @ CIExpr(_) ->
            slot = this.aggrVars.size();
            this.aggrVars.push((Max(), e));
            CIExpr(CIGetFrom(0, slot))
          | e @ CFExpr(_) ->
            slot = this.aggrVars.size();
            this.aggrVars.push((Max(), e));
            CFExpr(CFGetFrom(0, slot))
          | e @ CSExpr(_) ->
            slot = this.aggrVars.size();
            this.aggrVars.push((Max(), e));
            CSExpr(CSGetFrom(0, slot))
          | CGNull _ -> CGNull()
          }
        })

      | "count" ->
        this.noAggr(() -> {
          value = args.size() match {
          | 0 -> VInt(1)
          | 1 -> args[0]
          | _ -> error(this.pos, "Invalid number of arguments for sum")
          };
          this.compileExpr(context, value) match {
          | e @ CIExpr(_) ->
            slot = this.aggrVars.size();
            this.aggrVars.push((Count(distinct), e));
            CIExpr(CIGetFrom(0, slot))
          | e @ CFExpr(_) ->
            slot = this.aggrVars.size();
            this.aggrVars.push((Count(distinct), e));
            CIExpr(CIGetFrom(0, slot))
          | e @ CSExpr(_) ->
            slot = this.aggrVars.size();
            this.aggrVars.push((Count(distinct), e));
            CIExpr(CIGetFrom(0, slot))
          | CGNull _ -> CGNull()
          }
        })

      | "avg" ->
        this.noAggr(() -> {
          if (args.size() != 1) {
            error(this.pos, "Invalid number of arguments for avg")
          };
          this.compileExpr(context, args[0]) match {
          | e @ CIExpr(_) ->
            sumSlot = this.aggrVars.size();
            this.aggrVars.push((Sum(distinct), e));
            countSlot = this.aggrVars.size();
            this.aggrVars.push((Count(distinct), e));
            CFExpr(
              CDiv(
                CFICast(CIGetFrom(0, sumSlot)),
                CFICast(CIGetFrom(0, countSlot)),
              ),
            )
          | e @ CFExpr(_) ->
            sumSlot = this.aggrVars.size();
            this.aggrVars.push((Sum(distinct), e));
            countSlot = this.aggrVars.size();
            this.aggrVars.push((Count(distinct), e));
            CFExpr(
              CDiv(CFGetFrom(0, sumSlot), CFICast(CIGetFrom(0, countSlot))),
            )
          | CSExpr _ -> error(this.pos, "Cannot call avg on a string")
          | CGNull _ -> CGNull()
          }
        })

      | "abs" ->
        if (args.size() != 1) {
          error(this.pos, "Invalid number of arguments for abs")
        };
        this.compileExpr(context, args[0]) match {
        | CIExpr(n) -> CIExpr(CIAbs(n))
        | CFExpr(f) -> CFExpr(CFAbs(f))
        | _ ->
          error(
            this.pos,
            "Invalid arguments for abs, expected an integer or a float",
          )
        }

      | "date" ->
        if (args.size() < 1) {
          error(this.pos, "Missing arguments");
        };
        this.compileExpr(
          context,
          Call(
            Name::create("strftime"),
            Array[VString("%Y-%m-%d")].concat(args),
            false,
          ),
        )

      | "time" ->
        if (args.size() < 1) {
          error(this.pos, "Missing arguments");
        };
        this.compileExpr(
          context,
          Call(
            Name::create("strftime"),
            Array[VString("%H:%M:%S")].concat(args),
            false,
          ),
        )

      | "datetime" ->
        if (args.isEmpty()) {
          error(this.pos, "Missing arguments");
        };
        this.compileExpr(
          context,
          Call(
            Name::create("strftime"),
            Array[VString("%Y-%m-%d %H:%M:%S")].concat(args),
            false,
          ),
        )

      | "julianday" -> error(this.pos, "julianday not supported")

      | "strftime" ->
        if (args.size() < 2) {
          error(this.pos, "Missing arguments strftime");
        };

        isStatic = for (arg in args) {
          arg match {
          | VString _ -> void
          | _ -> break false
          }
        } else {
          true
        };

        if (isStatic) {
          sargs = args.map(x ->
            x match {
            | VString(v) -> v
            | _ -> error(this.pos, "only static dates are supported")
            }
          );

          CSExpr(CSLiteral(callStrftime(this.pos, context, sargs)))
        } else {
          sargs = args.map(arg ->
            this.compileExpr(context, arg) match {
            | CSExpr(x) -> x
            | _ -> error(this.pos, "Expected a string")
            }
          );
          CSExpr(CStrftime(sargs[0], sargs[1], sargs.slice(2, sargs.size())))
        }

      | "nullif" ->
        if (args.size() != 2) {
          error(this.pos, "NULLIF expects 2 arguments");
        };
        (
          this.compileExpr(context, args[0]),
          this.compileExpr(context, args[1]),
        ) match {
        | (CGNull(), CGNull()) -> CGNull()
        | (CIExpr(e1), CIExpr(e2)) -> CIExpr(CNullIf(e1, e2))
        | (CFExpr(e1), CFExpr(e2)) -> CFExpr(CNullIf(e1, e2))
        | (CSExpr(e1), CSExpr(e2)) -> CSExpr(CNullIf(e1, e2))
        | (x, _) -> x
        }

      | _ -> error(this.pos, `Unknown function: ${fname}`)
      }

    | SKDB.Case(condOpt, cases, defaultOpt) ->
      acc = defaultOpt match {
      | None() -> CGNull()
      | Some(d) -> this.compileExpr(context, d)
      };
      for (case in cases.reversed()) {
        (pat, action) = case;
        cond = condOpt match {
        | None() -> this.compileExpr(context, pat)
        | Some(v) -> this.compileExpr(context, BinOp(OEq(), v, pat))
        };
        !acc = this.makeIf(cond, this.compileExpr(context, action), acc);
      };
      acc

    | Cast(e1, ty) ->
      (this.compileExpr(context, e1), ty) match {
      | (CGNull(), _) -> CGNull()
      | (CIExpr(i), FLOAT()) -> CFExpr(CFICast(i))
      | (CFExpr(f), INTEGER()) -> CIExpr(CIFCast(f))
      | (CSExpr(s), INTEGER()) -> CIExpr(CISCast(s))
      | (CIExpr(i), TEXT()) -> CSExpr(CSICast(i))
      | (CFExpr(f), TEXT()) -> CSExpr(CSFCast(f))
      | (CSExpr(s), FLOAT()) -> CFExpr(CFSCast(s))
      | (ci @ CIExpr _, INTEGER()) -> ci
      | (cf @ CFExpr _, FLOAT()) -> cf
      | (cs @ CSExpr _, TEXT()) -> cs
      }

    | On(k, e) ->
      this.compileExpr(context, e) match {
      | CGNull _ -> CIExpr(CNull())
      | CIExpr(ie) -> CIExpr(COn(k, ie))
      | _ -> error(this.pos, "Unexpected type for ON")
      }

    | Collate _ -> invariant_violation("not implemented")
    }
  }

  mutable fun noAggr<T>(f: () -> T): T {
    this.!isAggr = false;
    result = f();
    this.!isAggr = true;
    result
  }

  mutable fun compileBinop(
    cge1: CGExpr,
    cge2: CGExpr,
    op: BinaryOperator,
  ): CGExpr {
    (cge1, cge2, op) match {
    | (CGNull(), CGNull(), _) -> CGNull()

    | (CIExpr(e1), CIExpr(e2), OOr()) -> CIExpr(COr(e1, e2))
    | (CGNull(), CIExpr(e2), OOr()) -> CIExpr(COr(CNull(), e2))
    | (CIExpr(e1), CGNull(), OOr()) -> CIExpr(COr(e1, CNull()))

    | (CGNull(), _, _)
    | (_, CGNull(), _) ->
      CGNull()

    | (CIExpr(e1), CIExpr(e2), OLt()) -> CIExpr(CILt(e1, e2))
    | (CIExpr(e1), CIExpr(e2), OLtEq()) -> CIExpr(CILte(e1, e2))
    | (CIExpr(e1), CIExpr(e2), OGtEq()) -> CIExpr(CIGte(e1, e2))
    | (CIExpr(e1), CIExpr(e2), OGt()) -> CIExpr(CIGt(e1, e2))
    | (CIExpr(e1), CIExpr(e2), OEq()) -> CIExpr(CIEq(e1, e2))
    | (CIExpr(e1), CIExpr(e2), ONeq()) -> CIExpr(CIDiff(e1, e2))

    | (CFExpr(e1), CFExpr(e2), OLt()) -> CIExpr(CFLt(e1, e2))
    | (CFExpr(e1), CFExpr(e2), OLtEq()) -> CIExpr(CFLte(e1, e2))
    | (CFExpr(e1), CFExpr(e2), OGtEq()) -> CIExpr(CFGte(e1, e2))
    | (CFExpr(e1), CFExpr(e2), OGt()) -> CIExpr(CFGt(e1, e2))
    | (CFExpr(e1), CFExpr(e2), OEq()) -> CIExpr(CFEq(e1, e2))
    | (CFExpr(e1), CFExpr(e2), ONeq()) -> CIExpr(CFDiff(e1, e2))

    | (CSExpr(e1), CSExpr(e2), OLt()) -> CIExpr(CSLt(e1, e2))
    | (CSExpr(e1), CSExpr(e2), OLtEq()) -> CIExpr(CSLte(e1, e2))
    | (CSExpr(e1), CSExpr(e2), OGtEq()) -> CIExpr(CSGte(e1, e2))
    | (CSExpr(e1), CSExpr(e2), OGt()) -> CIExpr(CSGt(e1, e2))
    | (CSExpr(e1), CSExpr(e2), OEq()) -> CIExpr(CSEq(e1, e2))
    | (CSExpr(e1), CSExpr(e2), ONeq()) -> CIExpr(CSDiff(e1, e2))

    | (CIExpr(e1), CIExpr(e2), OPlus()) -> CIExpr(CAdd(e1, e2))
    | (CIExpr(e1), CIExpr(e2), OMinus()) -> CIExpr(CSub(e1, e2))
    | (CIExpr(e1), CIExpr(e2), OMul()) -> CIExpr(CMul(e1, e2))
    | (CIExpr(e1), CIExpr(e2), ODiv()) -> CIExpr(CDiv(e1, e2))
    | (CIExpr(e1), CIExpr(e2), OMod()) -> CIExpr(CMod(e1, e2))

    | (CFExpr(e1), CFExpr(e2), OPlus()) -> CFExpr(CAdd(e1, e2))
    | (CFExpr(e1), CFExpr(e2), OMinus()) -> CFExpr(CSub(e1, e2))
    | (CFExpr(e1), CFExpr(e2), OMul()) -> CFExpr(CMul(e1, e2))
    | (CFExpr(e1), CFExpr(e2), ODiv()) -> CFExpr(CDiv(e1, e2))

    | (CIExpr(e1), CIExpr(e2), OAnd()) -> CIExpr(CAnd(e1, e2))
    | (CSExpr(e1), CSExpr(e2), OConcat()) -> CSExpr(CSConcat(e1, e2))

    | _ -> error(this.pos, "Incompatible types: " + op)
    }
  }

  mutable fun makeIf(cond: CGExpr, branch1: CGExpr, branch2: CGExpr): CGExpr {
    cond match {
    | CGNull() -> branch2
    | CIExpr(icond) ->
      (branch1, branch2) match {
      | (CIExpr(e1), CIExpr(e2)) -> CIExpr(CIf(icond, e1, e2))
      | (CFExpr(e1), CFExpr(e2)) -> CFExpr(CIf(icond, e1, e2))
      | (CSExpr(e1), CSExpr(e2)) -> CSExpr(CIf(icond, e1, e2))
      | (CGNull(), CGNull()) -> CGNull()
      | (CGNull(), CIExpr(e2)) -> CIExpr(CIf(icond, CNull(), e2))
      | (CGNull(), CFExpr(e2)) -> CFExpr(CIf(icond, CNull(), e2))
      | (CGNull(), CSExpr(e2)) -> CSExpr(CIf(icond, CNull(), e2))
      | (CIExpr(e1), CGNull()) -> CIExpr(CIf(icond, e1, CNull()))
      | (CFExpr(e1), CGNull()) -> CFExpr(CIf(icond, e1, CNull()))
      | (CSExpr(e1), CGNull()) -> CSExpr(CIf(icond, e1, CNull()))
      | _ ->
        debug((branch1, branch2));
        error(this.pos, "Branch have different types")
      }
    | CFExpr(_) ->
      error(
        this.pos,
        "Unexpected if condition type, expected INTEGER, not FLOAT",
      )
    | CSExpr(_) ->
      error(
        this.pos,
        "Unexpected if condition type, expected INTEGER, not TEXT",
      )
    }
  }

  readonly fun findJoin(
    tables: readonly Vector<?JTable>,
    cond: Expr,
  ): (Expr, JoinKind, ?EqJoin) {
    cond match {
    | On(jk, e) ->
      (!e, _, eqJoin) = this.findJoin(tables, e);
      jk match {
      | JLeft(natural)
      | JRight(natural)
      | JFull(natural) ->
        if (natural) {
          error(this.pos, "NATURAL JOINs not implemented")
        };
        if (eqJoin is None()) {
          error(this.pos, "Invalid ON expression for JOIN");
        }
      | JInner(natural) ->
        if (natural) {
          error(this.pos, "NATURAL JOINs not implemented")
        }
      | JCross() -> void
      };
      (e, jk, eqJoin)

    | BinOp(OAnd(), e1, e2) ->
      (!e1, jk1, join1) = this.findJoin(tables, e1);
      join1 match {
      | None() ->
        (!e2, jk2, join2) = this.findJoin(tables, e2);
        join2 match {
        | None() -> (cond, JInner(false), None())
        | Some(_) ->
          (
            if (e2 is VInt(1)) e1 else {
              BinOp(OAnd(), e1, e2)
            },
            jk2,
            join2,
          )
        }
      | Some(_) ->
        (
          if (e1 is VInt(1)) e2 else {
            BinOp(OAnd(), e1, e2)
          },
          jk1,
          join1,
        )
      }

    | BinOp(
      OEq(),
      name1 @ Identifier _,
      name2 @ Identifier _,
    ) if (this.isVar(name1) && this.isVar(name2)) ->
      (this.subst[name1], this.subst[name2]) match {
      | (CIExpr(CIGetFrom(tableNbr1, col1)), CIExpr(CIGetFrom(tableNbr2, col2)))
      | (CFExpr(CFGetFrom(tableNbr1, col1)), CFExpr(CFGetFrom(tableNbr2, col2)))
      | (
        CSExpr(CSGetFrom(tableNbr1, col1)),
        CSExpr(CSGetFrom(tableNbr2, col2)),
      ) if (
        tables[tableNbr1] is Some _ &&
        tables[tableNbr2] is Some _ &&
        tableNbr1 != tableNbr2
      ) ->
        if (tableNbr1 > tableNbr2) {
          (!tableNbr1, !tableNbr2) = (tableNbr2, tableNbr1);
          (!col1, !col2) = (col2, col1);
        };
        table1 = tables[tableNbr1].fromSome();
        table2 = tables[tableNbr2].fromSome();
        col1IsUnique = isUnique(table1.schema[col1]);
        col2IsUnique = isUnique(table2.schema[col2]);
        col1Name = (col1, IASC(), table1.schema[col1].ty);
        proj1 = TableProj(tableNbr1, col1Name, col1IsUnique);
        col2Name = (col2, IASC(), table2.schema[col2].ty);
        proj2 = TableProj(tableNbr2, col2Name, col2IsUnique);
        (VInt(1), JInner(false), Some(EqJoin(proj1, proj2)))
      | _ -> (cond, JInner(false), None())
      }
    | _ -> (cond, JInner(false), None())
    }
  }

  mutable fun compileJoin(
    context: mutable SKStore.Context,
    origFrom: Array<DirDescr>,
    where: ?Expr,
  ): (?Expr, Array<(SKDB.DirDescr, ?Array<SKStore.KeyRange>)>) {
    where match {
    | None() ->
      if (origFrom.size() > 1) {
        if (this.options.virtual) {
          error(
            this.pos,
            "Cross joins not supported in virtual views (regardless of option --always-allow-joins)",
          );
        };
        if (!this.options.alwaysAllowJoins) {
          errorNoMergeClause(this.pos);
        }
      };
      (None(), origFrom.map(x -> (x, None())))
    | Some(cond) ->
      from = this.compileIndexes(context, origFrom, cond);
      (!cond, !from) = this.compileMerge(from, cond);

      tablesLeft = from.filter(x ->
        x.i1 match {
        | None() -> true
        | Some(_) -> false
        }
      );
      if (tablesLeft.size() >= 2 && !this.options.alwaysAllowJoins) {
        errorNoMergeClause(this.pos);
      };
      (Some(cond), from)
    }
  }

  mutable fun compileMerge(
    from: Array<(SKDB.DirDescr, ?Array<SKStore.KeyRange>)>,
    cond: Expr,
  ): (Expr, Array<(SKDB.DirDescr, ?Array<SKStore.KeyRange>)>) {
    tables = mutable Vector<?JTable>[];
    newFrom = mutable Vector[];
    moveMap = mutable Map[];

    for (tableRange in from) {
      tables.push(Some(JTable::fromDirDescr(tableRange.i0, tableRange.i1)))
    };

    loop {
      (!cond, joinKind, joinOpt) = this.findJoin(tables, cond);
      join = joinOpt match {
      | None() ->
        for (tableNbr => tableOpt in tables) {
          tableOpt match {
          | None() -> void
          | Some(table) ->
            moveMap![tableNbr] = newFrom.size();
            dirDescr = DirDescr::create{
              name => Name::create(table.dirName.toString()),
              dirName => table.dirName,
              schema => table.schema.map(x ->
                if (x.primary is Some _) {
                  x with {unique => Some(CCUnique{})}
                } else {
                  x
                }
              ),
              alias => table.alias,
              isInput => false,
            };
            newFrom.push((dirDescr, table.ranges))
          }
        };

        for (name => cexpr in this.subst.clone()) {
          cexpr match {
          | SKDB.CIExpr(
            SKDB.CIGetFrom(tableNbr, colNbr),
          ) if (moveMap.containsKey(tableNbr)) ->
            this.subst![name] = SKDB.CIExpr(
              SKDB.CIGetFrom(moveMap[tableNbr], colNbr),
            )
          | SKDB.CFExpr(
            SKDB.CFGetFrom(tableNbr, colNbr),
          ) if (moveMap.containsKey(tableNbr)) ->
            this.subst![name] = SKDB.CFExpr(
              SKDB.CFGetFrom(moveMap[tableNbr], colNbr),
            )
          | SKDB.CSExpr(
            SKDB.CSGetFrom(tableNbr, colNbr),
          ) if (moveMap.containsKey(tableNbr)) ->
            this.subst![name] = SKDB.CSExpr(
              SKDB.CSGetFrom(moveMap[tableNbr], colNbr),
            )
          | _ -> void
          }
        };

        return (cond, newFrom.toArray())
      | Some(x) -> x
      };
      leftTable = tables[join.left.tableNbr].fromSome();
      rightTable = tables[join.right.tableNbr].fromSome();
      viewName = Name::create(
        leftTable.name.origName + "_" + rightTable.name.origName,
      );
      if (!this.options.virtual && !this.options.alwaysAllowJoins) {
        leftSchema = tables[join.left.tableNbr].fromSome().schema;
        col1 = leftSchema[join.left.col.i0].name;
        rightSchema = tables[join.right.tableNbr].fromSome().schema;
        col2 = rightSchema[join.right.col.i0].name;
        msg =
          "Joins outside of virtual views are considered bad practice in skdb.\n" +
          "You should first create a virtual view joining " +
          leftTable.name.origName +
          " and " +
          rightTable.name.origName +
          " with a query of the form:\n\n" +
          "create virtual view " +
          viewName +
          " as select * from " +
          leftTable.name.origName +
          ", " +
          rightTable.name.origName +
          " where " +
          col1 +
          " = " +
          col2 +
          ";\n\n" +
          "And then use " +
          viewName +
          " directly.\n" +
          "PS: You can ignore this error message with " +
          "--always-allow-joins (not recommended).\n" +
          if (tables.size() == 2) {
            "PS2: don't forget you can add indexes to virtual views."
          } else {
            ""
          };
        error(this.pos, msg)
      };
      childName = SKStore.DirName::create(
        "/merge/left" +
          leftTable.dirName +
          join.left.col.i0 +
          "-" +
          hash(leftTable.ranges) +
          "/right" +
          rightTable.dirName +
          join.right.col.i0 +
          "-" +
          hash(rightTable.ranges) +
          "/",
      );
      leftKinds = tables[join.left.tableNbr]
        .fromSome()
        .schema.mapWithIndex((idx, tyDescr) -> (idx, IASC(), tyDescr.ty));
      rightKinds = tables[join.right.tableNbr]
        .fromSome()
        .schema.mapWithIndex((idx, tyDescr) -> (idx, IASC(), tyDescr.ty));
      this.other.push(
        SubMerge{
          leftDirName => leftTable.dirName,
          leftColNbr => join.left.col.i0,
          leftIsUnique => join.left.isUnique,
          leftRanges => leftTable.ranges,
          rightDirName => rightTable.dirName,
          rightColNbr => join.right.col.i0,
          rightIsUnique => join.right.isUnique,
          rightRanges => rightTable.ranges,
          childName,
          kinds => leftKinds.concat(
            rightKinds.map(x -> (leftKinds.size() + x.i0, x.i1, x.i2)),
          ),
          joinKind,
        },
      );

      for (name => cexpr in this.subst.clone()) {
        cexpr match {
        | SKDB.CIExpr(
          SKDB.CIGetFrom(tableNbr, colNbr),
        ) if (tableNbr == join.right.tableNbr) ->
          leftSize = tables[join.left.tableNbr].fromSome().schema.size();
          this.subst![name] = SKDB.CIExpr(
            SKDB.CIGetFrom(join.left.tableNbr, leftSize + colNbr),
          )
        | SKDB.CFExpr(
          SKDB.CFGetFrom(tableNbr, colNbr),
        ) if (tableNbr == join.right.tableNbr) ->
          leftSize = tables[join.left.tableNbr].fromSome().schema.size();
          this.subst![name] = SKDB.CFExpr(
            SKDB.CFGetFrom(join.left.tableNbr, leftSize + colNbr),
          )
        | SKDB.CSExpr(
          SKDB.CSGetFrom(tableNbr, colNbr),
        ) if (tableNbr == join.right.tableNbr) ->
          leftSize = tables[join.left.tableNbr].fromSome().schema.size();
          this.subst![name] = SKDB.CSExpr(
            SKDB.CSGetFrom(join.left.tableNbr, leftSize + colNbr),
          )
        | _ -> void
        }
      };
      newSchema = tables[join.left.tableNbr]
        .fromSome()
        .schema.concat(tables[join.right.tableNbr].fromSome().schema);
      tables![join.right.tableNbr] = None();
      tables![join.left.tableNbr] = Some(
        JTable{
          name => viewName,
          dirName => childName,
          ranges => None(),
          schema => newSchema,
          alias => None(),
        },
      );
    }
  }

  mutable fun compileIndexes(
    context: mutable SKStore.Context,
    from: Array<DirDescr>,
    cond: Expr,
  ): Array<(SKDB.DirDescr, ?Array<SKStore.KeyRange>)> {
    tables = mutable Vector[];
    for (dirDescr in from) {
      tables.push(JTable::fromDirDescr(dirDescr, None()));
    };
    killed = mutable Set[];
    rangeMap = mutable Map[];

    loop {
      this.findLookUps(context, killed, tables, cond).select() match {
      | None() ->
        result = from.mapWithIndex((idx, table) -> {
          rangeMap.maybeGet(idx) match {
          | None() -> (table, None())
          | Some((indexDirName, ranges)) ->
            (table with {dirName => indexDirName}, Some(ranges))
          }
        });
        return result
      | Some((index, tableNbr, ranges)) ->
        for (range in ranges) {
          (low, high) = range;
          if (low > high) {
            error(
              this.pos,
              "contradictory inequalities, result will always be empty",
            );
          };
        };
        if (this.options.showUsedIndexes) {
          print_string("USING INDEX: " + index.name);
        };
        killed.add(index.tableDirName);
        rowRanges = ranges.map(range -> {
          (minKeyValues, maxKeyValues) = range;
          kinds = index.fields.mapWithIndex((idx, field) -> {
            (idx, IASC(), field.i2)
          });
          maxValues = kinds.mapWithIndex((idx, kind) -> {
            if (idx < maxKeyValues.size()) {
              Some(maxKeyValues[idx])
            } else {
              Some(
                kind.i2 match {
                | INTEGER() -> CInt(Int::max)
                | FLOAT() -> CFloat(Float::inf)
                | TEXT() -> CString(largestString())
                },
              )
            }
          });
          minKey = RowKey(
            RowValues::create(minKeyValues.map(x -> Some(x))),
            kinds,
          );
          maxKey = RowKey(RowValues::create(maxValues), kinds);
          SKStore.KeyRange(minKey, maxKey)
        });
        rangeMap![tableNbr] = (index.dirName, rowRanges)
      }
    }
  }

  // TODO: use this everywhere!
  readonly fun isVar(name: Identifier): Bool {
    this.subst.containsKey(name)
  }

  mutable fun findLookUps(
    context: mutable SKStore.Context,
    killed: readonly Set<SKStore.DirName>,
    tables: readonly Vector<JTable>,
    cond: Expr,
  ): LookUps {
    cond match {
    | BinOp(op, Call(fname, args, _), e2) ->
      if (
        !Array["strftime", "date", "time", "datetime"].contains(fname.lower)
      ) {
        return LookUps[];
      };
      this.findLookUps(
        context,
        killed,
        tables,
        BinOp(op, this.evalTimeFun(context, fname, args), e2),
      )

    | BinOp(op, e1, Call(fname, args, _)) ->
      if (
        !Array["strftime", "date", "time", "datetime"].contains(fname.lower)
      ) {
        return LookUps[];
      };
      this.findLookUps(
        context,
        killed,
        tables,
        BinOp(op, e1, this.evalTimeFun(context, fname, args)),
      )

    | Like(Call(fname, args, _), e2, escape, negated) ->
      if (
        !Array["strftime", "date", "time", "datetime"].contains(fname.lower)
      ) {
        return LookUps[];
      };
      this.findLookUps(
        context,
        killed,
        tables,
        Like(this.evalTimeFun(context, fname, args), e2, escape, negated),
      )

    | Like(e1, Call(fname, args, _), escape, negated) ->
      if (
        !Array["strftime", "date", "time", "datetime"].contains(fname.lower)
      ) {
        return LookUps[];
      };
      this.findLookUps(
        context,
        killed,
        tables,
        Like(e1, this.evalTimeFun(context, fname, args), escape, negated),
      )

    | BinOp(OAnd(), e1, e2) ->
      this.findLookUps(context, killed, tables, e1).and(
        this.findLookUps(context, killed, tables, e2),
      )
    | BinOp(OOr(), e1, e2) ->
      this.findLookUps(context, killed, tables, e1).or(
        this.findLookUps(context, killed, tables, e2),
      )

    | BinOp(_, name1 @ Identifier _, name2 @ Identifier _)
    | Like(
      name1 @ Identifier _,
      name2 @ Identifier _,
      _,
      _,
    ) if (this.isVar(name1) && this.isVar(name2)) ->
      LookUps[]

    | In(e, InList(values), _) ->
      if (values.size() == 0) {
        error(this.pos, "Invalid IN")
      };
      acc = BinOp(OEq(), e, values[0]);
      for (i in Range(1, values.size())) {
        !acc = BinOp(OOr(), acc, BinOp(OEq(), e, values[i]))
      };
      this.findLookUps(context, killed, tables, acc)

    | BinOp(op, e1 @ Value _, e2 @ Identifier _)
    | BinOp(
      op,
      e1 @ Identifier _,
      e2 @ Identifier _,
    ) if (this.isVar(e2)) ->
      !op = op match {
      | OEq() -> op
      | OLt() -> OGt()
      | OLtEq() -> OGtEq()
      | OGt() -> OLt()
      | OGtEq() -> OLtEq()
      | _ -> return LookUps[]
      };
      this.findLookUps(context, killed, tables, BinOp(op, e2, e1))

    | Like(e1 @ Value _, e2 @ Identifier _, escape, negated)
    | Like(
      e1 @ Identifier _,
      e2 @ Identifier _,
      escape,
      negated,
    ) if (this.isVar(e2)) ->
      this.findLookUps(context, killed, tables, Like(e2, e1, escape, negated))

    | BinOp(op, name1 @ Identifier _, e @ Value _)
    | BinOp(
      op,
      name1 @ Identifier _,
      e @ Identifier _,
    ) if (this.isVar(name1)) ->
      op match {
      | OEq()
      | OLt()
      | OLtEq()
      | OGt()
      | OGtEq() ->
        void
      | _ -> return LookUps[]
      };
      (tableNbr, colNbr) = this.subst[name1] match {
      | (CIExpr(CIGetFrom(x, y))) -> (x, y)
      | (CFExpr(CFGetFrom(x, y))) -> (x, y)
      | (CSExpr(CSGetFrom(x, y))) -> (x, y)
      | _ -> return LookUps[]
      };
      table = tables[tableNbr];
      indexEntry = makeIndexEntry(table.name, colNbr);
      indexTable = getIndexByColNbr(context);
      indexes = indexTable.getArray(context, indexEntry);
      !indexes = indexes.filter(index -> !killed.contains(index.tableDirName));
      ce = this.compileExpr(context, e);
      if (ce.getType() != table.schema[colNbr].ty) {
        error(this.pos, "Incompatible types");
      };
      value = ce match {
      | CIExpr(CILiteral(v)) -> CInt(v)
      | CFExpr(CFLiteral(f)) -> CFloat(f)
      | CSExpr(CSLiteral(s)) -> CString(s)
      | _ -> return LookUps[]
      };
      lookUps = indexes.map(index -> {
        (lookUpColNbr, unique) = for (slot => field in index.fields) {
          if (field.i0 == colNbr) break (slot, isUnique(table.schema[colNbr]))
        } else {
          invariant_violation("Could not find column: " + colNbr)
        };
        cols = SortedA[
          Col(lookUpColNbr, Array[(ColOp::create(op, value))], unique),
        ];
        !index = getLatestIndexDescr(context, index);
        LookUp{index, tableNbr, cols}
      });
      LookUps::createFromItems(lookUps)

    | Like(name1 @ Identifier _, e @ Value _, _, false)
    | Like(
      name1 @ Identifier _,
      e @ Identifier _,
      _,
      false,
    ) if (this.isVar(name1)) ->
      (tableNbr, colNbr) = this.subst[name1] match {
      | (CSExpr(CSGetFrom(x, y))) -> (x, y)
      | _ -> return LookUps[]
      };
      table = tables[tableNbr];
      indexEntry = makeIndexEntry(table.name, colNbr);
      indexTable = getIndexByColNbr(context);
      indexes = indexTable.getArray(context, indexEntry);
      !indexes = indexes.filter(index -> !killed.contains(index.tableDirName));
      ce = this.compileExpr(context, e);
      if (ce.getType() != table.schema[colNbr].ty) {
        error(this.pos, "Incompatible types");
      };
      value = ce match {
      | CSExpr(CSLiteral(s)) -> CString(s)
      | _ -> return LookUps[]
      };
      lookUps = indexes.map(index -> {
        (lookUpColNbr, unique) = for (slot => field in index.fields) {
          if (field.i0 == colNbr) break (slot, isUnique(table.schema[colNbr]))
        } else {
          invariant_violation("Could not find column: " + colNbr)
        };
        cols = SortedA[Col(lookUpColNbr, Array[(COLike(value.value))], unique)];
        !index = getLatestIndexDescr(context, index);
        LookUp{index, tableNbr, cols}
      });
      LookUps::createFromItems(lookUps)
    | _ -> LookUps[]
    }
  }

  readonly fun evalTimeFun(
    context: mutable SKStore.Context,
    fname: Name,
    args: Array<Expr>,
  ): Expr {
    fname.lower match {
    | "strftime" ->
      sargs = args.map(x ->
        x match {
        | VString(str) -> str
        | _ -> invariant_violation("Unexpected type")
        }
      );
      VString(callStrftime(this.pos, context, sargs))
    | "date" ->
      if (args.size() < 1) {
        error(this.pos, "Missing arguments");
      };
      Call(
        Name::create("strftime"),
        Array[VString("%Y-%m-%d")].concat(args),
        false,
      )
    | "time" ->
      if (args.size() < 1) {
        error(this.pos, "Missing arguments");
      };
      Call(
        Name::create("strftime"),
        Array[VString("%H:%M:%S")].concat(args),
        false,
      )
    | "datetime" ->
      if (args.size() < 1) {
        error(this.pos, "Missing arguments");
      };
      Call(
        Name::create("strftime"),
        Array[VString("%Y-%m-%d %H:%M:%S")].concat(args),
        false,
      )
    | _ -> invariant_violation("unreachable")
    }
  }
}

/*****************************************************************************/
/* LIKE patterns parsing. */
/*****************************************************************************/

fun parsePattern(str: Vector<Char>): Pattern {
  text = mutable Vector[];
  subs = mutable Vector[];
  hasUnderscore = false;
  for (c in str) {
    if (c == '%') {
      if (text.size() != 0) {
        subs.push(text.toArray());
        text.clear();
      };
      continue;
    };
    if (c == '_') {
      !hasUnderscore = true;
    };
    text.push(c);
  };
  if (text.size() != 0) {
    subs.push(text.toArray());
    text.clear();
  };
  firstIsPercent = str.size() > 0 && str[0] == '%';
  lastIsPercent = str.size() > 0 && str[str.size() - 1] == '%';
  Pattern{hasUnderscore, firstIsPercent, lastIsPercent, subs => subs.toArray()}
}
