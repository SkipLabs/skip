module SKDB;

base class SchemaChange {
  children =
  | ScRemoveTable()
  | ScMigrateTable(schema: Array<TableChange>)
}

base class TableChange {
  children =
  | TcNoChange(col: TypeDescr)
  | TcNewCol(col: TypeDescr)
  | TcChange(old: TypeDescr, new: TypeDescr)
}

fun tableDiff(desired: Table, existing: DirDescr): Array<TableChange> {
  desiredCols = desired.schema;
  existingCols = existing.schema;

  acc = mutable Vector[];

  // very simple algo. cols form a set (with some position info), so
  // no need to find minimum edits
  for (desiredCol in desiredCols) {
    acc.push(
      existingCols.find(c -> c.name == desiredCol.name) match {
      | None() -> TcNewCol(desiredCol)
      | Some(existingCol) if (desiredCol == existingCol) ->
        TcNoChange(desiredCol)
      | Some(existingCol) -> TcChange(existingCol, desiredCol)
      },
    )
  };

  acc.collect(Array)
}

fun migrationDiff(
  desired: Array<Stmt>,
  existing: Array<DirDescr>,
): Map<Name, SchemaChange> {
  desiredTables: Array<Table> = desired
    .map(x ->
      x match {
      | t @ Table _ -> Some(t)
      | _ -> None()
      }
    )
    .filterNone();
  desiredTableNames = desiredTables.map(x -> x.name).collect(Set);
  existingTableNames = existing.map(x -> x.name).collect(Set);
  tablesToRemove = existingTableNames.difference(desiredTableNames);

  tableChanges = Vector::mcreateFromItems(
    tablesToRemove.map(name -> (name, (ScRemoveTable() : SchemaChange))),
  );

  for (name in desiredTableNames.intersection(existingTableNames)) {
    desiredTable = desiredTables.find(t -> t.name == name).fromSome();
    existingTable = existing.find(t -> t.name == name).fromSome();
    diff = tableDiff(desiredTable, existingTable);
    tableChanges.push((name, ScMigrateTable(diff)))
  };

  tableChanges.collect(Map)
}
