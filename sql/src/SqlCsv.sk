module SKCSV;

base class Token {
  children =
  | NewLine()
  | Comma()
  | Chars(Array<Char>)
}

@cpp_extern("SKIP_stdin_has_data")
native fun stdinHasData(): Int32;

fun lexRaw(next: () -> Char): mutable Iterator<Token> {
  acc = mutable Vector[];
  lastIsString = false;
  loop {
    next() match {
    | '\n' ->
      if (!lastIsString) {
        str = acc.toArray();
        acc.clear();
        yield Chars(str);
      };
      break void
    | ',' ->
      if (!lastIsString) {
        str = acc.toArray();
        acc.clear();
        yield Chars(str);
      };
      !lastIsString = false;

      yield Comma()
    | '"' ->
      !lastIsString = true;
      acc.push('"');
      loop {
        c = next();
        acc.push(c);
        if (c == '"') {
          break void;
        }
      };
      str = acc.toArray();
      acc.clear();
      yield Chars(str)
    | x ->
      !lastIsString = false;
      acc.push(x)
    }
  }
}

base class CValue {
  children =
  | CInt(Int)
  | CFloat(Float)
  | CString(String)
}

fun trim(chars: Array<Char>): Array<Char> {
  i = 0;
  while (i < chars.size() && chars[i] == ' ') !i = i + 1;
  j = chars.size();
  while (j - 1 >= 0 && chars[j - 1] == ' ') !j = j - 1;
  chars.slice(i, j)
}

fun lex(next: () -> Char): mutable Iterator<(Bool, String)> {
  stringAcc: ?mutable Vector<Char> = None();
  isString: Bool = false;
  for (tok in lexRaw(next)) {
    (tok, stringAcc) match {
    | (Chars(chars), Some(acc)) if (chars.size() > 0 && chars[0] == '"') ->
      !isString = true;
      !chars = trim(chars);
      acc.extend(chars.slice(0, chars.size() - 1))
    | (
      Chars(chars),
      None(),
    ) if (chars.size() > 0 && chars[chars.size() - 1] == '"') ->
      !isString = true;
      !chars = trim(chars);
      !chars = chars.slice(1, chars.size() - 1);
      !stringAcc = Some(Vector::mcreateFromItems(chars))
    | _ ->
      stringAcc match {
      | None() -> void
      | Some(acc) ->
        !stringAcc = None();
        yield (isString, String::fromChars(acc.toArray()))
      };
      !isString = false;
      tok match {
      | Chars(chars) -> yield (false, String::fromChars(trim(chars)))
      | NewLine() -> break void
      | Comma() -> void
      }
    }
  };
  stringAcc match {
  | None() -> void
  | Some(acc) ->
    !stringAcc = None();
    yield (isString, String::fromChars(acc.toArray()))
  }
}

fun parseCsv<T>(
  line: mutable Ref<Int>,
  f: ((Bool, String)) ~> T,
): (Bool, Array<Array<T>>) {
  array = mutable Vector[];
  eof = false;
  vtry(
    () -> {
      for (_ in Range(0, 1000)) {
        values = mutable Vector[];
        for (value in lex(() -> getChar())) {
          values.push(value);
        };
        cvalues = values.map(f);
        array.push(cvalues.toArray());
        line.set(line.get() + 1);
      }
    },
    exn -> {
      if (exn is EndOfFile _) {
        !eof = true;
        return void;
      };
      print_error("Error, line " + line.get() + ": " + exn.getMessage());
      skipExit(23);
    },
  );
  (eof, array.toArray())
}

fun insert(
  context: mutable SKFS.Context,
  line: mutable Ref<Int>,
  options: SKSQL.Options,
  table: SKSQL.DirDescr,
  user: ?SKSQL.UserFile,
): SKFS.ContextOp {
  eval = SKSQL.Evaluator{options, user};
  pos = 0;
  inTransaction = false;
  paramsOpt = None();
  (eof, array) = parseCsv(line, SKSQL.parseCSVValue);
  f = eval.insert(context, pos, None(), inTransaction, table, paramsOpt, array);
  if (!eof) return SKFS.CContinue(f);
  SKFS.CStop(f)
}

fun replayDiff(
  context: mutable SKFS.Context,
  lineNbr: mutable Ref<Int>,
  getLine: () -> String,
  table: SKSQL.DirDescr,
  user: ?String,
  identity: Int,
): SKFS.ContextOp {
  userFileOpt = user.map(x -> SKSQL.UserFile::create(context, x));
  writer = SKFS.Path(table.dirName, SKFS.IID(identity));
  buffer: mutable Vector<SKSQL.RowValues> = mutable Vector[];

  if (table.windowSize is Some _) {
    print_error("Cannot use write-csv on a window or a stream");
    skipExit(23);
  };

  shouldShortCircuitUpdate = (context, checkpoint) ~> {
    previouslySeen = SKSQL.getWatermark(
      context,
      table.name.lower,
      Some(identity),
    );
    (checkpoint, previouslySeen) match {
    | (Some(x), Some(y)) if (x <= y.value) -> true
    | _ -> false
    };
  };

  checkpointAndAck = (context, delta, checkpoint) ~> {
    if (checkpoint is Some _) {
      checkpointTick = SKFS.Tick(checkpoint.fromSome());
      SKSQL.setWatermark(context, table.name.lower, identity, checkpointTick);
      delta.setGlobal("Ack", SKSQL.StdoutCheckpointAck(checkpointTick));
    };
  };

  // we have two update strategies depending on whether the diff is
  // assigning rows a repeat value or whether it is communicating
  // the entire current state (a reset).

  resetRows = (rows, checkpoint, snapshot) -> {
    Some((context, delta, _) ~> {
      if (shouldShortCircuitUpdate(context, checkpoint)) {
        return void;
      };

      dir = context.unsafeGetEagerDir(table.dirName);
      entries = mutable Vector[];

      // we may only affect rows that have been seen
      isEligibleForTomb = (tick, source) ~>
        tick.value <= snapshot.default(0) || source.path() == writer;

      for (row in rows) {
        key: SKFS.BaseName = SKSQL.RowKey(row.setRepeat(1), table.kinds);
        for ((tick, source, _) in dir.getDataIterWithoutTombs(context, key)) {
          if (isEligibleForTomb(tick, source)) {
            entries.push((key, (source.path(), writer, Array<SKFS.File>[])));
          }
        };
      };
      if (!entries.isEmpty()) {
        !dir = dir.writeArraySourceManyReturnDir(context, entries.iterator());
      };
      !dir = dir.writeArraySourceManyReturnDir(
        context,
        rows
          .iterator()
          .filter(row -> row.repeat != 0)
          .map(row -> {
            (k, v) = (SKSQL.RowKey(row, table.kinds), Array[row]);
            ((k : SKFS.BaseName), (writer, writer, (v : Array<SKFS.File>)))
          }),
      );

      isVisibleToUser = userFileOpt match {
      | None() -> _ -> true
      | Some(userFile) ->
        access = mutable SKSQL.AccessSolver(userFile.id);
        table.cols.maybeGet(SKSQL.skdbAccess) match {
        | None() -> _ -> true
        | Some(accessColNbr) ->
          (file: SKFS.BaseName) -> {
            file match {
            | k @ SKSQL.RowKey _ ->
              k.row.getInt(accessColNbr) match {
              | None() -> true
              | Some(accessID) -> access.canRead(context, accessID)
              }
            | _ -> true
            }
          }
        }
      };
      !dir = dir.reset(
        context,
        writer,
        rows
          .iterator()
          .filter(row -> row.repeat != 0)
          .map(x -> SKSQL.RowKey(x.setRepeat(1), table.kinds))
          .collect(SortedSet),
        isVisibleToUser,
        isEligibleForTomb,
      );

      context.setDir(dir.dirName, dir);
      checkpointAndAck(context, delta, checkpoint);
      context.update()
    })
  };

  assignRows = (rows, checkpoint, snapshot) -> {
    Some((context, delta, _) ~> {
      if (shouldShortCircuitUpdate(context, checkpoint)) {
        return void;
      };

      dir = context.unsafeGetEagerDir(table.dirName);
      entries = mutable Vector[];

      for (row in rows) {
        key: SKFS.BaseName = SKSQL.RowKey(row.setRepeat(1), table.kinds);
        for ((tick, source, _) in dir.getDataIterWithoutTombs(context, key)) {
          if (tick.value <= snapshot.default(0) || source.path() == writer) {
            entries.push((key, (source.path(), writer, Array<SKFS.File>[])));
          }
        };
      };
      if (!entries.isEmpty()) {
        !dir = dir.writeArraySourceManyReturnDir(context, entries.iterator());
      };
      !dir = dir.writeArraySourceManyReturnDir(
        context,
        rows
          .iterator()
          .filter(row -> row.repeat != 0)
          .map(row -> {
            (k, v) = (SKSQL.RowKey(row, table.kinds), Array[row]);
            ((k : SKFS.BaseName), (writer, writer, (v : Array<SKFS.File>)))
          }),
      );

      context.setDir(dir.dirName, dir);
      checkpointAndAck(context, delta, checkpoint);
      context.update()
    })
  };

  // the tick of the sender that this update takes us in sync to
  checkpoint: ?Int = None();
  // our tick that the sender is in sync with - they applied this
  // change to our snapshot at this time
  snapshot: ?Int = None();
  reset = false;

  vtry<SKFS.ContextOp>(
    () -> {
      loop {
        line = getLine();
        lineNbr.set(lineNbr.get() + 1);
        if (line == "") continue;

        chars: mutable Vector<Char> = mutable Vector[];
        iter = line.getIter();
        (repeat, !reset, !checkpoint, !snapshot) = loop {
          c = iter.next() match {
          | None() ->
            print_error(
              "Error, line " + lineNbr.get() + ": unexpected end of line",
            );
            skipExit(23)
          | Some(':') ->
            ticks = line
              .sub(iter, line.length() - chars.size() - 1)
              .split(" ")
              .map(x -> x.toInt());
            break (None(), reset, ticks.maybeGet(0), ticks.maybeGet(1))
          | Some(x) -> x
          };
          if (c == '\t') {
            if (chars.size() == 0 || chars[0] == '\t') {
              break (None(), true, checkpoint, snapshot)
            } else {
              break (
                Some(String::fromChars(chars.toArray()).toInt()),
                reset,
                checkpoint,
                snapshot,
              )
            }
          };
          if (c < '0' || c > '9') {
            print_error(
              "Error, line " + lineNbr.get() + ": expected an integer",
            );
            skipExit(23)
          };
          chars.push(c);
        };

        if (repeat is Some _) {
          str = line.sub(iter, line.length() - chars.size() - 1);
          values = mutable Vector[];
          strIter = str.getIter();
          next = () -> {
            val = strIter.next();
            val match {
            | None() -> '\n'
            | Some(x) -> x
            }
          };
          for (value in lex(next)) {
            values.push(value);
          };
          cvalues = values.map(SKSQL.parseCSVValue);
          pos = lineNbr.get();
          newRows = SKSQL.computeInsert(
            context,
            false,
            pos,
            None(),
            Array[cvalues.toArray()],
            table,
          );
          userFileOpt match {
          | None() -> void
          | Some(userFile) ->
            SKSQL.checkUserRows(context, userFile, pos, table, newRows)
          };
          buffer.extend(newRows.map(x -> x.setRepeat(repeat.fromSome())));
        };

        checkpoint match {
        | None() -> void
        | Some(_) ->
          rows = buffer.toArray();
          buffer.clear();
          break SKFS.CContinue(
            if (reset) resetRows(rows, checkpoint, snapshot) else {
              assignRows(rows, checkpoint, snapshot)
            },
          )
        }
      }
    },
    exn -> {
      if (exn is EndOfFile _) {
        rows = buffer.toArray();
        SKFS.CStop(
          if (reset) resetRows(rows, checkpoint, snapshot) else {
            assignRows(rows, checkpoint, snapshot)
          },
        )
      } else {
        flushStdout();
        SKFS.CContinue(None())
      }
    },
  );
}

fun replayStdin(): Map<String, (Int, Int)> {
  txNbr = 0;
  all = mutable Map<String, (Int, Int)>[];
  tx = mutable Map<String, (Int, Int)>[];
  commit = () -> {
    for (x => y in tx) {
      all![x] = y
    };
    tx.clear();
    !txNbr = txNbr + 1;
  };
  lineNbr = 1;
  loop {
    line = read_line() match {
    | None() -> break all.chill()
    | Some("") -> continue
    | Some(l) -> l
    };
    chars: mutable Vector<Char> = mutable Vector[];
    iter = line.getIter();
    checkpoint = false;
    reset = false;
    loop {
      c = iter.next() match {
      | None() ->
        print_error("Error, line " + lineNbr + ": unexpected end of line");
        skipExit(23)
      | Some(':') ->
        !checkpoint = true;
        break void
      | Some(x) -> x
      };
      if (c == '\t') {
        if (chars.size() == 0 || chars[0] == '\t') {
          !reset = true;
          break void
        } else {
          break void
        }
      };
      if (c < '0' || c > '9') {
        print_error("Error, line " + lineNbr + ": expected an integer key");
        skipExit(23)
      };
      chars.push(c);
    };
    if (reset) {
      all.clear();
      commit();
      continue;
    };
    if (checkpoint) {
      commit();
      continue;
    };
    repeat = String::fromChars(chars.toArray()).toInt();
    value = line.sub(iter, line.length() - chars.size() - 1);
    tx![value] = (txNbr, repeat);
    !lineNbr = lineNbr + 1;
  }
}
