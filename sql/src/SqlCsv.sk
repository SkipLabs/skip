module SKCSV;

base class Token {
  children =
  | NewLine()
  | Comma()
  | Chars(Array<Char>)
}

@cpp_extern("SKIP_stdin_has_data")
native fun stdinHasData(): Int32;

fun lexRaw(next: () -> Char): mutable Iterator<Token> {
  acc = mutable Vector[];
  lastIsString = false;
  loop {
    next() match {
    | '\n' ->
      if (!lastIsString) {
        str = acc.toArray();
        acc.clear();
        yield Chars(str);
      };
      break void
    | ',' ->
      if (!lastIsString) {
        str = acc.toArray();
        acc.clear();
        yield Chars(str);
      };
      !lastIsString = false;

      yield Comma()
    | '"' ->
      !lastIsString = true;
      acc.push('"');
      loop {
        c = next();
        acc.push(c);
        if (c == '"') {
          break void;
        }
      };
      str = acc.toArray();
      acc.clear();
      yield Chars(str)
    | x ->
      !lastIsString = false;
      acc.push(x)
    }
  }
}

base class CValue {
  children =
  | CInt(Int)
  | CFloat(Float)
  | CString(String)
}

fun trim(chars: Array<Char>): Array<Char> {
  i = 0;
  while (i < chars.size() && chars[i] == ' ') !i = i + 1;
  j = chars.size();
  while (j - 1 >= 0 && chars[j - 1] == ' ') !j = j - 1;
  chars.slice(i, j)
}

fun lex(next: () -> Char): mutable Iterator<(Bool, String)> {
  stringAcc: ?mutable Vector<Char> = None();
  isString: Bool = false;
  for (tok in lexRaw(next)) {
    (tok, stringAcc) match {
    | (Chars(chars), Some(acc)) if (chars.size() > 0 && chars[0] == '"') ->
      !isString = true;
      !chars = trim(chars);
      acc.extend(chars.slice(0, chars.size() - 1))
    | (
      Chars(chars),
      None(),
    ) if (chars.size() > 0 && chars[chars.size() - 1] == '"') ->
      !isString = true;
      !chars = trim(chars);
      !chars = chars.slice(1, chars.size() - 1);
      !stringAcc = Some(Vector::mcreateFromItems(chars))
    | _ ->
      stringAcc match {
      | None() -> void
      | Some(acc) ->
        !stringAcc = None();
        yield (isString, String::fromChars(acc.toArray()))
      };
      !isString = false;
      tok match {
      | Chars(chars) -> yield (false, String::fromChars(trim(chars)))
      | NewLine() -> break void
      | Comma() -> void
      }
    }
  };
  stringAcc match {
  | None() -> void
  | Some(acc) ->
    !stringAcc = None();
    yield (isString, String::fromChars(acc.toArray()))
  }
}

fun parseCsv<T>(
  line: mutable Ref<Int>,
  f: ((Bool, String)) ~> T,
): (Bool, Array<Array<T>>) {
  array = mutable Vector[];
  eof = false;
  vtry(
    () -> {
      for (_ in Range(0, 1000)) {
        values = mutable Vector[];
        for (value in lex(() -> getChar())) {
          values.push(value);
        };
        cvalues = values.map(f);
        array.push(cvalues.toArray());
        line.set(line.get() + 1);
      }
    },
    exn -> {
      if (exn is EndOfFile _) {
        !eof = true;
        return void;
      };
      print_error("Error, line " + line.get() + ": " + exn.getMessage());
      skipExit(23);
    },
  );
  (eof, array.toArray())
}

fun insert(
  context: mutable SKFS.Context,
  line: mutable Ref<Int>,
  options: SKSQL.Options,
  table: SKSQL.DirDescr,
  user: ?SKSQL.UserFile,
): SKFS.ContextOp {
  eval = SKSQL.Evaluator{options, user};
  pos = 0;
  inTransaction = false;
  paramsOpt = None();
  (eof, array) = parseCsv(line, SKSQL.parseCSVValue);
  f = eval.insert(context, pos, None(), inTransaction, table, paramsOpt, array);
  if (!eof) return SKFS.CContinue(f);
  SKFS.CStop(f)
}

fun reasonSchemaUnsupported(
  origContext: readonly SKFS.Context,
  tableName: String,
): ?String {
  context = SKFS.Context::fromSaved(origContext.clone());
  SKSQL.getTableDir(context).maybeGet(context, SKFS.SID(tableName)) match {
  | None() -> Some("Table does not exist.")
  | Some(dirDescr) ->
    if (dirDescr.schema.any(x ~> x.unique)) {
      return Some("Cannot mirror tables with unique constraints.")
    };
    None()
  };
}

fun lwwEdits(
  table: SKSQL.DirDescr,
  snapshot: Int,
  writer: SKFS.Path,
  primaryIdxOpt: ?Int,
  context: mutable SKFS.Context,
  dir: SKFS.EagerDir,
  row: SKSQL.RowValues,
): mutable Iterator<(SKFS.BaseName, (SKFS.Path, SKFS.Path, Array<SKFS.File>))> {
  primaryIdx = primaryIdxOpt match {
  | None() -> invariant_violation("Using LWW without a primary key.")
  | Some(p) -> p
  };
  select = SKSQL.CSelect{
    id => SKSQL.Name::create("SELECT_" + SKFS.genSym(0)),
    kind => SKSQL.SAll(),
    params => table.kinds.map(kind ~> {
      (idx, _, type) = kind;
      type match {
      | SKSQL.FLOAT() -> SKSQL.CFExpr(SKSQL.CFGetFrom(0, idx))
      | SKSQL.INTEGER() -> SKSQL.CIExpr(SKSQL.CIGetFrom(0, idx))
      | SKSQL.TEXT() -> SKSQL.CSExpr(SKSQL.CSGetFrom(0, idx))
      }
    }),
    sets => Array[],
    aggr => None(),
    kinds => table.kinds,
    from => Array[(table, None())],
    where => Some(
      table.schema[primaryIdx].ty match {
      | SKSQL.FLOAT() ->
        SKSQL.CFEq(
          SKSQL.CFGetFrom(0, primaryIdx),
          SKSQL.CFLiteral(row.getFloat(primaryIdx).fromSome()),
        )
      | SKSQL.INTEGER() ->
        SKSQL.CIEq(
          SKSQL.CIGetFrom(0, primaryIdx),
          SKSQL.CILiteral(row.getInt(primaryIdx).fromSome()),
        )
      | SKSQL.TEXT() ->
        SKSQL.CSEq(
          SKSQL.CSGetFrom(0, primaryIdx),
          SKSQL.CSLiteral(row.getString(primaryIdx).fromSome()),
        )
      },
    ),
    groupBy => None(),
    having => None(),
    orderBy => None(),
    limit => None(),
    rest => None(),
    needUp => false,
    needGetParam => false,
    directMode => false,
    format => SKFS.OSQL(),
    other => Array[],
  };
  selectHandle = SKSQL.evalSelect(context, select, None());
  selectDir = context.unsafeGetEagerDir(selectHandle.dirName);

  entries = mutable Vector[];

  keepingCurrent = false;
  selectDir.unsafeIterKeys((key, _tick) -> {
    for ((tick, source, _) in dir.getDataIterWithoutTombs(context, key)) {
      if (
        tick.value < snapshot ||
        source.path() == writer ||
        SKSQL.RowKey::fromFile(key).row < row
      ) {
        entries.push((key, (source.path(), writer, Array<SKFS.File>[])));
      } else {
        !keepingCurrent = true;
        return void;
      }
    };
  });
  if (!keepingCurrent) {
    for (entry in entries) yield entry;
    yield (
      SKSQL.RowKey(row, table.kinds),
      (writer, writer, Array<SKFS.File>[row]),
    );
  }
}

fun applyDiffStrategy(
  table: SKSQL.DirDescr,
  identity: Int,
  userFileOpt: ?SKSQL.UserFile,
  reset: Bool,
  rows: Array<SKSQL.RowValues>,
  checkpoint: ?Int,
  snapshot: ?Int,
): ?((mutable SKFS.Context, mutable SKFS.Context, SKFS.Context) ~> void) {
  writer = SKFS.Path(table.dirName, SKFS.IID(identity));

  shouldShortCircuitUpdate = (context) ~> {
    previouslySeen = SKSQL.getWatermark(
      context,
      table.name.lower,
      Some(identity),
    );
    (checkpoint, previouslySeen) match {
    | (Some(x), Some(y)) if (x <= y.value) -> true
    | _ -> false
    };
  };

  checkpointAndAck = (context, delta) ~> {
    if (checkpoint is Some _) {
      checkpointTick = SKFS.Tick(checkpoint.fromSome());
      SKSQL.setWatermark(context, table.name.lower, identity, checkpointTick);
      delta.setGlobal("Ack", SKSQL.StdoutCheckpointAck(checkpointTick));
    };
  };

  isVisibleToUser = (context) ~> {
    userFileOpt match {
    | None() -> _ -> true
    | Some(userFile) ->
      access = mutable SKSQL.AccessSolver(userFile.id);
      table.cols.maybeGet(SKSQL.skdbAccess) match {
      | None() -> _ -> true
      | Some(accessColNbr) ->
        (file: SKFS.BaseName) -> {
          file match {
          | k @ SKSQL.RowKey _ ->
            k.row.getInt(accessColNbr) match {
            | None() -> true
            | Some(accessID) -> access.canRead(context, accessID)
            }
          | _ -> true
          }
        }
      }
    };
  };

  primaryIdx = for ((i, type) in table.schema.items()) {
    if (type.primary) {
      break Some(i)
    }
  } else {
    None()
  };

  // we have several update strategies:

  // assignRows - if there are no constraints on the table then we
  // treat the relations as a multiset CRDT. inserts beat deletes when
  // concurrent.
  assignRows = Some((context, delta, _) ~> {
    if (shouldShortCircuitUpdate(context)) {
      return void;
    };

    dir = context.unsafeGetEagerDir(table.dirName);
    entries = mutable Vector[];

    for (row in rows) {
      key: SKFS.BaseName = SKSQL.RowKey(row.setRepeat(1), table.kinds);
      for ((tick, source, _) in dir.getDataIterWithoutTombs(context, key)) {
        if (tick.value < snapshot.default(0) || source.path() == writer) {
          entries.push((key, (source.path(), writer, Array<SKFS.File>[])));
        }
      };
    };
    if (!entries.isEmpty()) {
      !dir = dir.writeArraySourceManyReturnDir(context, entries.iterator());
    };
    !dir = dir.writeArraySourceManyReturnDir(
      context,
      rows
        .iterator()
        .filter(row -> row.repeat != 0)
        .map(row -> {
          (k, v) = (SKSQL.RowKey(row, table.kinds), Array[row]);
          ((k : SKFS.BaseName), (writer, writer, (v : Array<SKFS.File>)))
        }),
    );

    context.setDir(dir.dirName, dir);
    checkpointAndAck(context, delta);
    context.update()
  });

  // resetRows - if the update is communicating the entire current
  // state (a reset).
  resetRows = Some((context, delta, _) ~> {
    if (shouldShortCircuitUpdate(context)) {
      return void;
    };

    dir = context.unsafeGetEagerDir(table.dirName);
    entries = mutable Vector[];

    // we may only affect rows that have been seen
    isEligibleForTomb = (tick, source) ~>
      tick.value < snapshot.default(0) || source.path() == writer;

    for (row in rows) {
      key: SKFS.BaseName = SKSQL.RowKey(row, table.kinds);
      keyRepeat = row.repeat;
      for ((tick, source, files) in dir.getDataIterWithoutTombs(context, key)) {
        if (!isEligibleForTomb(tick, source)) {
          continue
        };
        srcRepeat = 0;
        for (file in files) {
          !srcRepeat = srcRepeat + SKSQL.RowValues::fromFile(file).repeat
        };

        if (keyRepeat - srcRepeat < 0) {
          entries.push((key, (source.path(), writer, Array<SKFS.File>[])));
        } else {
          !keyRepeat = keyRepeat - srcRepeat;
        }
      };

      if (keyRepeat != 0) {
        entries.push((key, (writer, writer, Array[row.setRepeat(keyRepeat)])));
      }
    };

    if (!entries.isEmpty()) {
      !dir = dir.writeArraySourceManyReturnDir(context, entries.iterator());
    };

    !dir = dir.reset(
      context,
      writer,
      rows
        .iterator()
        .filter(row -> row.repeat != 0)
        .map(x -> SKSQL.RowKey(x.setRepeat(1), table.kinds))
        .collect(SortedSet),
      isVisibleToUser(context),
      isEligibleForTomb,
    );

    context.setDir(dir.dirName, dir);
    checkpointAndAck(context, delta);
    context.update()
  });

  // lwwRows - if there is a unique constraint on the table (e.g. a
  // PK) then we resolve this using LWW. the total order is formed
  // using the vector clock. concurrent tiebreaks use the row data.
  lwwRows = Some((context, delta, _) ~> {
    if (shouldShortCircuitUpdate(context)) {
      return void;
    };

    dir = context.unsafeGetEagerDir(table.dirName);
    entries = mutable Vector[];

    for (row in rows) {
      if (row.repeat < 1) {
        key: SKFS.BaseName = SKSQL.RowKey(row.setRepeat(1), table.kinds);
        for ((tick, source, _) in dir.getDataIterWithoutTombs(context, key)) {
          if (tick.value < snapshot.default(0) || source.path() == writer) {
            entries.push((key, (source.path(), writer, Array<SKFS.File>[])));
          }
        };
        continue;
      };

      for (change in lwwEdits(
        table,
        snapshot.default(0),
        writer,
        primaryIdx,
        context,
        dir,
        row,
      )) {
        entries.push(change);
      }
    };

    !dir = dir.writeArraySourceManyReturnDir(context, entries.iterator());
    context.setDir(dir.dirName, dir);
    checkpointAndAck(context, delta);
    context.update()
  });

  // lwwReset - if the update is communicating the entire current
  // state (a reset) on a table where we use LWW.
  lwwReset = Some((context, delta, _) ~> {
    if (shouldShortCircuitUpdate(context)) {
      return void;
    };

    dir = context.unsafeGetEagerDir(table.dirName);
    entries = mutable Vector[];

    for (row in rows) {
      if (row.repeat < 1) {
        continue;
      };

      for (change in lwwEdits(
        table,
        snapshot.default(0),
        writer,
        primaryIdx,
        context,
        dir,
        row,
      )) {
        entries.push(change);
      }
    };
    !dir = dir.writeArraySourceManyReturnDir(context, entries.iterator());

    !dir = dir.reset(
      context,
      writer,
      rows
        .iterator()
        .filter(row -> row.repeat != 0)
        .map(x -> SKSQL.RowKey(x.setRepeat(1), table.kinds))
        .collect(SortedSet),
      isVisibleToUser(context),
      (tick, source) ~>
        tick.value < snapshot.default(0) || source.path() == writer
      ,
    );

    context.setDir(dir.dirName, dir);
    checkpointAndAck(context, delta);
    context.update()
  });

  if (primaryIdx is Some _) {
    if (reset) return lwwReset;
    return lwwRows;
  };

  if (reset) return resetRows;

  assignRows
}

fun replayDiff(
  context: mutable SKFS.Context,
  lineNbr: mutable Ref<Int>,
  getLine: () -> String,
  table: SKSQL.DirDescr,
  user: ?String,
  identity: Int,
): SKFS.ContextOp {
  userFileOpt = user.map(x -> SKSQL.UserFile::create(context, x));
  buffer: mutable Vector<SKSQL.RowValues> = mutable Vector[];

  if (table.windowSize is Some _) {
    print_error("Cannot use write-csv on a window or a stream");
    skipExit(23);
  };

  // the tick of the sender that this update takes us in sync to
  checkpoint: ?Int = None();
  // our tick that the sender is in sync with - they applied this
  // change to our snapshot at this time
  snapshot: ?Int = None();
  reset = false;

  vtry<SKFS.ContextOp>(
    () -> {
      loop {
        line = getLine();
        lineNbr.set(lineNbr.get() + 1);
        if (line == "") continue;

        chars: mutable Vector<Char> = mutable Vector[];
        iter = line.getIter();
        (repeat, !reset, !checkpoint, !snapshot) = loop {
          c = iter.next() match {
          | None() ->
            print_error(
              "Error, line " + lineNbr.get() + ": unexpected end of line",
            );
            skipExit(23)
          | Some(':') ->
            ticks = line
              .sub(iter, line.length() - chars.size() - 1)
              .split(" ")
              .map(x -> x.toInt());
            break (None(), reset, ticks.maybeGet(0), ticks.maybeGet(1))
          | Some(x) -> x
          };
          if (c == '\t') {
            if (chars.size() == 0 || chars[0] == '\t') {
              break (None(), true, checkpoint, snapshot)
            } else {
              break (
                Some(String::fromChars(chars.toArray()).toInt()),
                reset,
                checkpoint,
                snapshot,
              )
            }
          };
          if (c < '0' || c > '9') {
            print_error(
              "Error, line " + lineNbr.get() + ": expected an integer",
            );
            skipExit(23)
          };
          chars.push(c);
        };

        if (repeat is Some _) {
          str = line.sub(iter, line.length() - chars.size() - 1);
          values = mutable Vector[];
          strIter = str.getIter();
          next = () -> {
            val = strIter.next();
            val match {
            | None() -> '\n'
            | Some(x) -> x
            }
          };
          for (value in lex(next)) {
            values.push(value);
          };
          cvalues = values.map(SKSQL.parseCSVValue);
          pos = lineNbr.get();
          newRows = SKSQL.computeInsert(
            context,
            false,
            pos,
            None(),
            Array[cvalues.toArray()],
            table,
          );
          userFileOpt match {
          | None() -> void
          | Some(userFile) ->
            SKSQL.checkUserRows(context, userFile, pos, table, newRows)
          };
          buffer.extend(newRows.map(x -> x.setRepeat(repeat.fromSome())));
        };

        checkpoint match {
        | None() -> void
        | Some(_) ->
          rows = buffer.toArray();
          buffer.clear();
          break SKFS.CContinue(
            applyDiffStrategy(
              table,
              identity,
              userFileOpt,
              reset,
              rows,
              checkpoint,
              snapshot,
            ),
          )
        }
      }
    },
    exn -> {
      if (exn is EndOfFile _) {
        rows = buffer.toArray();
        SKFS.CStop(
          applyDiffStrategy(
            table,
            identity,
            userFileOpt,
            reset,
            rows,
            checkpoint,
            snapshot,
          ),
        )
      } else {
        flushStdout();
        SKFS.CContinue(None())
      }
    },
  );
}

fun replayStdin(): Map<String, (Int, Int)> {
  txNbr = 0;
  all = mutable Map<String, (Int, Int)>[];
  tx = mutable Map<String, (Int, Int)>[];
  commit = () -> {
    for (x => y in tx) {
      all![x] = y
    };
    tx.clear();
    !txNbr = txNbr + 1;
  };
  lineNbr = 1;
  loop {
    line = read_line() match {
    | None() -> break all.chill()
    | Some("") -> continue
    | Some(l) -> l
    };
    chars: mutable Vector<Char> = mutable Vector[];
    iter = line.getIter();
    checkpoint = false;
    reset = false;
    loop {
      c = iter.next() match {
      | None() ->
        print_error("Error, line " + lineNbr + ": unexpected end of line");
        skipExit(23)
      | Some(':') ->
        !checkpoint = true;
        break void
      | Some(x) -> x
      };
      if (c == '\t') {
        if (chars.size() == 0 || chars[0] == '\t') {
          !reset = true;
          break void
        } else {
          break void
        }
      };
      if (c < '0' || c > '9') {
        print_error("Error, line " + lineNbr + ": expected an integer key");
        skipExit(23)
      };
      chars.push(c);
    };
    if (reset) {
      all.clear();
      commit();
      continue;
    };
    if (checkpoint) {
      commit();
      continue;
    };
    repeat = String::fromChars(chars.toArray()).toInt();
    value = line.sub(iter, line.length() - chars.size() - 1);
    tx![value] = (txNbr, repeat);
    !lineNbr = lineNbr + 1;
  }
}
