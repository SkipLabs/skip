module SKCSV;

base class Token {
  children =
  | NewLine()
  | Comma()
  | Chars(Array<Char>)
}

@cpp_extern("SKIP_stdin_has_data")
native fun stdinHasData(): Int32;

fun lexRaw(next: () -> Char): mutable Iterator<Token> {
  acc = mutable Vector[];
  lastIsString = false;
  loop {
    next() match {
    | '\n' ->
      if (!lastIsString) {
        str = acc.toArray();
        acc.clear();
        yield Chars(str);
      };
      break void
    | ',' ->
      if (!lastIsString) {
        str = acc.toArray();
        acc.clear();
        yield Chars(str);
      };
      !lastIsString = false;

      yield Comma()
    | '"' ->
      !lastIsString = true;
      acc.push('"');
      loop {
        c = next();
        acc.push(c);
        if (c == '"') {
          break void;
        }
      };
      str = acc.toArray();
      acc.clear();
      yield Chars(str)
    | x ->
      !lastIsString = false;
      acc.push(x)
    }
  }
}

base class CValue {
  children =
  | CInt(Int)
  | CFloat(Float)
  | CString(String)
}

fun trim(chars: Array<Char>): Array<Char> {
  i = 0;
  while (i < chars.size() && chars[i] == ' ') !i = i + 1;
  j = chars.size();
  while (j - 1 >= 0 && chars[j - 1] == ' ') !j = j - 1;
  chars.slice(i, j)
}

fun lex(next: () -> Char): mutable Iterator<(Bool, String)> {
  stringAcc: ?mutable Vector<Char> = None();
  isString: Bool = false;
  for (tok in lexRaw(next)) {
    (tok, stringAcc) match {
    | (Chars(chars), Some(acc)) if (chars.size() > 0 && chars[0] == '"') ->
      !isString = true;
      !chars = trim(chars);
      acc.extend(chars.slice(0, chars.size() - 1))
    | (
      Chars(chars),
      None(),
    ) if (chars.size() > 0 && chars[chars.size() - 1] == '"') ->
      !isString = true;
      !chars = trim(chars);
      !chars = chars.slice(1, chars.size() - 1);
      !stringAcc = Some(Vector::mcreateFromItems(chars))
    | _ ->
      stringAcc match {
      | None() -> void
      | Some(acc) ->
        !stringAcc = None();
        yield (isString, String::fromChars(acc.toArray()))
      };
      !isString = false;
      tok match {
      | Chars(chars) -> yield (false, String::fromChars(trim(chars)))
      | NewLine() -> break void
      | Comma() -> void
      }
    }
  };
  stringAcc match {
  | None() -> void
  | Some(acc) ->
    !stringAcc = None();
    yield (isString, String::fromChars(acc.toArray()))
  }
}

fun parseCsv<T>(
  line: mutable Ref<Int>,
  f: ((Bool, String)) ~> T,
): (Bool, Array<Array<T>>) {
  array = mutable Vector[];
  eof = false;
  try {
    for (_ in Range(0, 1000)) {
      values = mutable Vector[];
      for (value in lex(() -> getChar())) {
        values.push(value);
      };
      cvalues = values.map(f);
      array.push(cvalues.toArray());
      line.set(line.get() + 1);
    }
  } catch {
  | EndOfFile _ ->
    !eof = true;
    void
  | exn ->
    print_error("Error, line " + line.get() + ": " + exn.getMessage());
    skipExit(23)
  };
  (eof, array.toArray())
}

fun insert(
  context: mutable SKFS.Context,
  line: mutable Ref<Int>,
  options: SKSQL.Options,
  table: SKSQL.DirDescr,
  user: ?SKSQL.UserFile,
): SKFS.ContextOp {
  // empty params since no placeholders in input to skdb load-csv
  params: Map<String, SKSQL.Value> = Map[];
  eval = SKSQL.Evaluator{options, user};
  pos = 0;
  inTransaction = false;
  paramsOpt = None();
  (eof, array) = parseCsv(line, SKSQL.parseCSVValue);
  f = eval.insert(
    context,
    params,
    pos,
    None(),
    inTransaction,
    table,
    paramsOpt,
    array,
  );
  if (!eof) return SKFS.CContinue(f);
  SKFS.CStop(f)
}

fun reasonSchemaUnsupported(
  origContext: readonly SKFS.Context,
  tableName: String,
): ?String {
  context = SKFS.Context::fromSaved(origContext.clone());
  SKSQL.getTableDir(context).maybeGet(context, SKFS.SID(tableName)) match {
  | None() -> Some("Table does not exist.")
  | Some(dirDescr) ->
    if (dirDescr.schema.any(x ~> x.unique)) {
      return Some("Cannot mirror tables with unique constraints.")
    };
    None()
  };
}

fun lwwEdits(
  table: SKSQL.DirDescr,
  snapshot: Int,
  writer: SKFS.Path,
  primaryIdxOpt: ?Int,
  context: mutable SKFS.Context,
  dir: SKFS.EagerDir,
  row: SKSQL.RowValues,
): mutable Iterator<(SKFS.BaseName, (SKFS.Path, SKFS.Path, Array<SKFS.File>))> {
  primaryIdx = primaryIdxOpt match {
  | None() -> invariant_violation("Using LWW without a primary key.")
  | Some(p) -> p
  };
  selectAst = SKSQL.Select{
    id => SKSQL.Name::create("SELECT_" + SKFS.genSym(0)),
    pos => 0,
    params => SKSQL.SelectParams(true, Array[]),
    from => Some(
      Array[SKSQL.TableName(SKSQL.FName(table.name), None(), false)],
    ),
    where => Some(
      SKSQL.Binop(
        "=",
        SKSQL.Literal(table.colNames[primaryIdx].origName),
        table.schema[primaryIdx].ty match {
        | SKSQL.INTEGER() -> SKSQL.VInt(row.getInt(primaryIdx).fromSome())
        | SKSQL.FLOAT() -> SKSQL.VFloat(row.getFloat(primaryIdx).fromSome())
        | SKSQL.TEXT() -> SKSQL.VString(row.getString(primaryIdx).fromSome())
        },
      ),
    ),
    groupBy => None(),
    having => None(),
    join => None(),
    kind => SKSQL.SAll(),
    limit => None(),
    orderBy => None(),
    rest => None(),
  };
  options = SKSQL.Options{
    alwaysAllowJoins => false,
    backtrace => false,
    sync => false,
    showUsedIndexes => false,
  };
  // empty params since no placeholders in skdb diff write-csv
  params: Map<String, SKSQL.Value> = Map[];
  compiler = SKSQL.Compiler::create(false, options, selectAst.pos, params);
  selectContext = context.mclone(); // ensure we don't accumulate the select dirs
  select = compiler.compileSelect(selectContext, selectAst, true);
  selectHandle = SKSQL.evalSelect(selectContext, select, None());
  selectDir = selectContext.unsafeGetEagerDir(selectHandle.dirName);

  entries = mutable Vector[];

  keepingCurrent = false;
  selectDir.unsafeIterKeys((key, _tick) -> {
    for ((tick, source, _) in dir.getDataIterWithoutTombs(context, key)) {
      if (
        tick.value < snapshot ||
        source.path() == writer ||
        SKSQL.RowKey::fromFile(key).row < row
      ) {
        entries.push((key, (source.path(), writer, Array<SKFS.File>[])));
      } else {
        !keepingCurrent = true;
        return void;
      }
    };
  });
  if (!keepingCurrent) {
    for (entry in entries) yield entry;
    yield (
      SKSQL.RowKey(row, table.kinds),
      (writer, writer, Array<SKFS.File>[row]),
    );
  }
}

fun applyDiffStrategy(
  table: SKSQL.DirDescr,
  identity: Int,
  userFileOpt: ?SKSQL.UserFile,
  reset: Bool,
  rows: Array<SKSQL.RowValues>,
  checkpoint: ?Int,
  snapshot: ?Int,
): ?((mutable SKFS.Context, mutable SKFS.Context, SKFS.Context) ~> void) {
  writer = SKFS.Path(table.dirName, SKFS.IID(identity));

  shouldShortCircuitUpdate = (context) ~> {
    previouslySeen = SKSQL.getWatermark(
      context,
      table.name.lower,
      Some(identity),
    );
    (checkpoint, previouslySeen) match {
    | (Some(x), Some(y)) if (x <= y.value) -> true
    | _ -> false
    };
  };

  checkpointAndAck = (context, delta) ~> {
    if (checkpoint is Some _) {
      checkpointTick = SKFS.Tick(checkpoint.fromSome());
      SKSQL.setWatermark(context, table.name.lower, identity, checkpointTick);
      delta.setGlobal("Ack", SKSQL.StdoutCheckpointAck(checkpointTick));
    };
  };

  primaryIdx = for ((i, type) in table.schema.items()) {
    if (type.primary) {
      break Some(i)
    }
  } else {
    None()
  };

  // we have several update strategies:

  // assignRows - if there are no constraints on the table then we
  // treat the relations as a multiset CRDT. inserts beat deletes when
  // concurrent.
  assignRows = Some((context, delta, _) ~> {
    if (shouldShortCircuitUpdate(context)) {
      return void;
    };

    dir = context.unsafeGetEagerDir(table.dirName);
    entries = mutable Vector[];
    hasError = false;

    for (row in rows) {
      userFileOpt match {
      | None() -> void
      | Some(user) ->
        SKSQL.checkUserCanWriteRow(context, user, table, row) match {
        | SKSQL.AROK() -> void
        | SKSQL.ARError(err) ->
          !hasError = true;
          print_error("Error: " + err)
        }
      }
    };

    if (!hasError) {
      for (row in rows) {
        key: SKFS.BaseName = SKSQL.RowKey(row.setRepeat(1), table.kinds);
        for ((tick, source, _) in dir.getDataIterWithoutTombs(context, key)) {
          if (tick.value < snapshot.default(0) || source.path() == writer) {
            entries.push((key, (source.path(), writer, Array<SKFS.File>[])));
          }
        }
      }
    };

    if (!entries.isEmpty()) {
      !dir = dir.writeArraySourceManyReturnDir(context, entries.iterator());
    };
    !dir = dir.writeArraySourceManyReturnDir(
      context,
      rows
        .iterator()
        .filter(row -> row.repeat != 0)
        .map(row -> {
          (k, v) = (SKSQL.RowKey(row, table.kinds), Array[row]);
          ((k : SKFS.BaseName), (writer, writer, (v : Array<SKFS.File>)))
        }),
    );

    context.setDir(dir.dirName, dir);
    checkpointAndAck(context, delta);
    context.update()
  });

  // resetRows - if the update is communicating the entire current
  // state (a reset).
  resetRows = Some((context, delta, _) ~> {
    if (shouldShortCircuitUpdate(context)) {
      return void;
    };

    dir = context.unsafeGetEagerDir(table.dirName);
    entries = mutable Vector[];

    // we may only affect rows that have been seen
    isEligibleForTomb = (tick, source) ~>
      tick.value < snapshot.default(0) || source.path() == writer;

    for (row in rows) {
      key: SKFS.BaseName = SKSQL.RowKey(row, table.kinds);
      keyRepeat = row.repeat;
      for ((tick, source, files) in dir.getDataIterWithoutTombs(context, key)) {
        if (!isEligibleForTomb(tick, source)) {
          continue
        };
        srcRepeat = 0;
        for (file in files) {
          !srcRepeat = srcRepeat + SKSQL.RowValues::fromFile(file).repeat
        };

        if (keyRepeat - srcRepeat < 0) {
          entries.push((key, (source.path(), writer, Array<SKFS.File>[])));
        } else {
          !keyRepeat = keyRepeat - srcRepeat;
        }
      };

      if (keyRepeat != 0) {
        entries.push((key, (writer, writer, Array[row.setRepeat(keyRepeat)])));
      }
    };

    if (!entries.isEmpty()) {
      !dir = dir.writeArraySourceManyReturnDir(context, entries.iterator());
    };

    !dir = dir.reset(
      context,
      writer,
      rows
        .iterator()
        .filter(row -> row.repeat != 0)
        .map(x -> SKSQL.RowKey(x.setRepeat(1), table.kinds))
        .collect(SortedSet),
      _context ~> true,
      isEligibleForTomb,
    );

    context.setDir(dir.dirName, dir);
    checkpointAndAck(context, delta);
    context.update()
  });

  // lwwRows - if there is a unique constraint on the table (e.g. a
  // PK) then we resolve this using LWW. the total order is formed
  // using the vector clock. concurrent tiebreaks use the row data.
  lwwRows = Some((context, delta, _) ~> {
    if (shouldShortCircuitUpdate(context)) {
      return void;
    };

    dir = context.unsafeGetEagerDir(table.dirName);
    entries = mutable Vector[];

    for (row in rows) {
      if (row.repeat < 1) {
        key: SKFS.BaseName = SKSQL.RowKey(row.setRepeat(1), table.kinds);
        for ((tick, source, _) in dir.getDataIterWithoutTombs(context, key)) {
          if (tick.value < snapshot.default(0) || source.path() == writer) {
            entries.push((key, (source.path(), writer, Array<SKFS.File>[])));
          }
        };
        continue;
      };

      for (change in lwwEdits(
        table,
        snapshot.default(0),
        writer,
        primaryIdx,
        context,
        dir,
        row,
      )) {
        entries.push(change);
      }
    };

    !dir = dir.writeArraySourceManyReturnDir(context, entries.iterator());
    context.setDir(dir.dirName, dir);
    checkpointAndAck(context, delta);
    context.update()
  });

  // lwwReset - if the update is communicating the entire current
  // state (a reset) on a table where we use LWW.
  lwwReset = Some((context, delta, _) ~> {
    if (shouldShortCircuitUpdate(context)) {
      return void;
    };

    dir = context.unsafeGetEagerDir(table.dirName);
    entries = mutable Vector[];

    for (row in rows) {
      if (row.repeat < 1) {
        continue;
      };

      for (change in lwwEdits(
        table,
        snapshot.default(0),
        writer,
        primaryIdx,
        context,
        dir,
        row,
      )) {
        entries.push(change);
      }
    };
    !dir = dir.writeArraySourceManyReturnDir(context, entries.iterator());

    !dir = dir.reset(
      context,
      writer,
      rows
        .iterator()
        .filter(row -> row.repeat != 0)
        .map(x -> SKSQL.RowKey(x.setRepeat(1), table.kinds))
        .collect(SortedSet),
      _context ~> true,
      (tick, source) ~>
        tick.value < snapshot.default(0) || source.path() == writer
      ,
    );

    context.setDir(dir.dirName, dir);
    checkpointAndAck(context, delta);
    context.update()
  });

  if (primaryIdx is Some _) {
    if (reset) return lwwReset;
    return lwwRows;
  };

  if (reset) return resetRows;

  assignRows
}

fun replayDiff(
  context: mutable SKFS.Context,
  lineNbr: mutable Ref<Int>,
  getLine: () -> String,
  table: SKSQL.DirDescr,
  user: ?String,
  identity: Int,
): SKFS.ContextOp {
  userFileOpt = user.map(x -> SKSQL.UserFile::create(context, x));
  buffer: mutable Vector<SKSQL.RowValues> = mutable Vector[];

  // the tick of the sender that this update takes us in sync to
  checkpoint: ?Int = None();
  // our tick that the sender is in sync with - they applied this
  // change to our snapshot at this time
  snapshot: ?Int = None();
  reset = false;

  try {
    loop {
      line = getLine();
      lineNbr.set(lineNbr.get() + 1);
      if (line == "") continue;

      chars: mutable Vector<Char> = mutable Vector[];
      iter = line.getIter();
      (repeatOpt, !reset, !checkpoint, !snapshot) = loop {
        c = iter.next() match {
        | None() ->
          print_error(
            "Error, line " + lineNbr.get() + ": unexpected end of line",
          );
          skipExit(23)
        | Some(':') ->
          ticks = line
            .sub(iter, line.length() - chars.size() - 1)
            .split(" ")
            .map(x -> x.toInt());
          break (None(), reset, ticks.maybeGet(0), ticks.maybeGet(1))
        | Some(x) -> x
        };
        if (c == '\t') {
          if (chars.size() == 0 || chars[0] == '\t') {
            break (None(), true, checkpoint, snapshot)
          } else {
            break (
              Some(String::fromChars(chars.toArray()).toInt()),
              reset,
              checkpoint,
              snapshot,
            )
          }
        };
        if (c < '0' || c > '9') {
          print_error("Error, line " + lineNbr.get() + ": expected an integer");
          skipExit(23)
        };
        chars.push(c);
      };

      if (repeatOpt is Some _) {
        str = line.sub(iter, line.length() - chars.size() - 1);
        values = mutable Vector[];
        strIter = str.getIter();
        next = () -> {
          val = strIter.next();
          val match {
          | None() -> '\n'
          | Some(x) -> x
          }
        };
        for (value in lex(next)) {
          values.push(value);
        };
        cvalues = values.map(SKSQL.parseCSVValue);
        // empty params since no placeholders in skdb diff write-csv
        params: Map<String, SKSQL.Value> = Map[];
        pos = lineNbr.get();
        newRows = SKSQL.computeInsert(
          context,
          params,
          false,
          pos,
          None(),
          Array[cvalues.toArray()],
          table,
          repeatOpt.fromSome(),
        );
        userFileOpt match {
        | None() -> void
        | Some(userFile) ->
          hasError = false;
          for (row in newRows) {
            SKSQL.checkUserCanWriteRow(context, userFile, table, row) match {
            | SKSQL.AROK() -> void
            | SKSQL.ARError(err) ->
              print_error("Error: " + err.toString());
              !hasError = true
            }
          };
          if (hasError) {
            throw SKSQL.IgnoreAndContinue()
          }
        };
        buffer.extend(newRows);
      };

      checkpoint match {
      | None() -> void
      | Some(_) ->
        rows = buffer.toArray();
        buffer.clear();
        break SKFS.CContinue(
          applyDiffStrategy(
            table,
            identity,
            userFileOpt,
            reset,
            rows,
            checkpoint,
            snapshot,
          ),
        )
      }
    }
  } catch {
  | EndOfFile _ ->
    rows = buffer.toArray();
    SKFS.CStop(
      applyDiffStrategy(
        table,
        identity,
        userFileOpt,
        reset,
        rows,
        checkpoint,
        snapshot,
      ),
    )
  | SKSQL.IgnoreAndContinue _ ->
    flushStdout();
    SKFS.CContinue(None())
  | exn ->
    print_error(exn.getMessage());
    SKFS.CStop(None())
  }
}

fun replayStdin(): Map<String, (Int, Int)> {
  txNbr = 0;
  all = mutable Map<String, (Int, Int)>[];
  tx = mutable Map<String, (Int, Int)>[];
  commit = () -> {
    for (x => y in tx) {
      all![x] = y
    };
    tx.clear();
    !txNbr = txNbr + 1;
  };
  lineNbr = 1;
  loop {
    line = read_line() match {
    | None() -> break all.chill()
    | Some("") -> continue
    | Some(l) -> l
    };
    chars: mutable Vector<Char> = mutable Vector[];
    iter = line.getIter();
    checkpoint = false;
    reset = false;
    loop {
      c = iter.next() match {
      | None() ->
        print_error("Error, line " + lineNbr + ": unexpected end of line");
        skipExit(23)
      | Some(':') ->
        !checkpoint = true;
        break void
      | Some(x) -> x
      };
      if (c == '\t') {
        if (chars.size() == 0 || chars[0] == '\t') {
          !reset = true;
          break void
        } else {
          break void
        }
      };
      if (c < '0' || c > '9') {
        print_error("Error, line " + lineNbr + ": expected an integer key");
        skipExit(23)
      };
      chars.push(c);
    };
    if (reset) {
      all.clear();
      commit();
      continue;
    };
    if (checkpoint) {
      commit();
      continue;
    };
    repeat = String::fromChars(chars.toArray()).toInt();
    value = line.sub(iter, line.length() - chars.size() - 1);
    tx![value] = (txNbr, repeat);
    !lineNbr = lineNbr + 1;
  }
}
