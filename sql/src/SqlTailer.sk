module alias P = SQLParser;

module SKDB;

class TailSpec{
  since: Int,
  filter: ?String,
  columns: ?Array<P.ColumnDefinition>,
  params: Map<String, P.Value>,
}

fun buildTailFilter(
  context: readonly SKStore.Context,
  options: SKDB.Options,
  dirSub: SKStore.DirSub,
  userId: ?String,
  tailSpec: TailSpec,
  sqlTable: SKDB.DirDescr,
): (SKStore.Context, Bool) ~> (SKStore.Key -> Bool) {
  filter = tailSpec.filter match {
  | None() -> dirSub.filter
  | Some(strCond) ->
    compiler = SKDB.Compiler::create(false, options, 0, tailSpec.params);
    ast = P.Parser::create(strCond).parseExpr();
    compilerContext = context.mclone();
    _ = compiler.compileFrom(
      compilerContext,
      Array[P.FromTable{name => sqlTable.name, asName => None()}],
    );
    e = compiler.compileExpr(compilerContext, ast) match {
    | SKDB.CIExpr(x) -> x
    | _ ->
      print_error("Unexpected type for filter expression");
      skipExit(2)
    };
    (context, isReset) ~> {
      mcontext = context.mclone();
      conditionFilter = dirSub.filter(context, isReset);
      baseName -> {
        inputRow = baseName match {
        | rowKey @ SKDB.RowKey _ -> rowKey.getRowValues()
        | _ ->
          print_error("Unexpected table entry type");
          skipExit(2)
        };
        evaluator = SKDB.ExprEvaluator(Array[inputRow], Array[], None());

        evaluator.evalCIExpr(mcontext, e) match {
        | SKDB.ANull()
        | SKDB.ADef(0) ->
          false
        | SKDB.AUndef()
        | SKDB.ADef(_) ->
          conditionFilter(baseName)
        }
      }
    }
  };

  userId match {
  | None() -> filter
  | Some(userID) ->
    (context, isReset) ~> {
      user = SKDB.UserFile::create(context, userID);
      oldFilter = filter(context, isReset);

      baseName -> {
        oldFilter(baseName) &&
          baseName match {
          | rowKey @ SKDB.RowKey _ ->
            row = rowKey.getRowValues();
            SKDB.checkUserCanReadRow(context, user, sqlTable, row) match {
            | SKDB.AROK() -> true
            | _ -> false
            }
          | _ ->
            print_error("Unexpected table entry type");
            skipExit(2)
          };
      }
    }
  };
}

fun buildCSVSchemaTransform(
  dirDescr: SKDB.DirDescr,
  tailSpec: TailSpec,
): SKStore.OutputFormat {
  source = dirDescr.schema;
  target = tailSpec.columns match {
  | None() -> return SKStore.OCSV(None())
  | Some(targetSchema) -> targetSchema
  };

  for (sourceCol in source) {
    if (
      sourceCol.notNull is Some _ &&
      sourceCol.default is None _ &&
      !target.contains(sourceCol)
    ) {
      print_error(
        `Incompatible schema: missing required column ${sourceCol.name}`,
      );
      skipExit(2)
    };
  };

  schemaTransformation = target.map(targetCol -> {
    source.indexOf(targetCol) match {
    | None() ->
      print_error(`Incompatible schema: unknown column ${targetCol.name}`);
      skipExit(2)
    | Some(idx) -> idx
    }
  });

  SKStore.OCSV(Some(schemaTransformation));
}

fun tailShouldWake(
  context: readonly SKStore.Context,
  sub: SKStore.Sub,
  tick: SKStore.Tick,
): Bool {
  SKDB.getFinalState(context, sub.destinationSource) match {
  | Some(SKDB.RSError()) -> return true
  | _ -> void
  };

  for (dirSub in sub.dirSubs) {
    context.unsafeMaybeGetEagerDir(dirSub.dirName) match {
    | None() -> void
    | Some(dir) ->
      (isReset, changes) = dir.getChangesAfter(tick);
      if (isReset || !changes.isEmpty()) {
        return true
      }
    }
  };
  false
}

fun tailFrom(
  spec: (P.Name -> TailSpec),
  dirSub: SKStore.DirSub,
  tailWatermark: ?Int,
): SKStore.Tick {
  tailWatermark match {
  | Some(tick) -> SKStore.Tick(tick)
  | None() ->
    // we haven't caught up yet so honour the requested since value per table
    tableName = P.Name::create(getSqlTableName(dirSub.dirName));
    SKStore.Tick(spec(tableName).since)
  }
}

fun tailSub(
  options: SKDB.Options,
  follow: Bool,
  sessionID: Int,
  userIDOpt: ?String,
  spec: (P.Name -> TailSpec),
): Bool {
  sub = SKStore.withContext(gContext -> {
    // rebuild the sub with extra filtering as supported by tail
    gContext.sessions.maybeGet(sessionID) match {
    | None() ->
      print_error("Error: session not found");
      skipExit(2)
    | Some(sub) ->
      dirDescrs = getDirDescrs(gContext);
      sub with {
        dirSubs => sub.dirSubs.map(dirSub -> {
          table = dirSub.dirName.toString().stripPrefix("/").stripSuffix("/");
          tableName = P.Name::create(table);
          dirDescr = dirDescrs.maybeGet(tableName) match {
          | Some(descr) -> descr
          | None _ ->
            print_error(`Error: '${tableName}' not found`);
            skipExit(2)
          };
          tailSpec = spec(tableName);
          dirSub with {
            filter => buildTailFilter(
              gContext,
              options,
              dirSub,
              userIDOpt,
              tailSpec,
              dirDescr,
            ),
            format => options.format match {
            | SKDB.OFK_CSV() -> buildCSVSchemaTransform(dirDescr, tailSpec)
            | _ -> dirSub.format
            },
          }
        }),
      }
    };
  });

  tailWatermark: ?Int = None();
  init = true;
  forceReset = false;

  loop {
    localObstack = SKStore.newObstack();
    tick = SKStore.withContext<?Int>(context -> {
      context.sessions.maybeGet(sessionID) match {
      | None() ->
        print_error("Error: session not found");
        skipExit(2)
      | Some(_) -> void
      };

      SKDB.getFinalState(context, sub.destinationSource) match {
      | Some(SKDB.RSError()) ->
        print_raw(":reboot\n");
        return None()
      | _ -> void
      };

      writer = mutable Debug.BufferedWriter(print_raw, 4096);

      producedAnyOutput = false; // assume we won't
      couldFollowChanges = true; // assume we can
      chunkingDisabled = false;
      for (dirSub in sub.dirSubs) {
        dirName = dirSub.dirName;
        edir = context.unsafeGetEagerDir(dirName);
        format = options.format match {
        | SKDB.OFK_CSV() ->
          assert(dirSub.format is SKStore.OCSV(_));
          dirSub.format
        | SKDB.OFK_JSON() -> SKStore.OJSON(getFieldNames(context, dirName))
        | SKDB.OFK_SQL() -> SKStore.OSQL()
        | SKDB.OFK_JS() -> SKStore.OJS(getFieldNames(context, dirName))
        | SKDB.OFK_Table() -> SKStore.OTable(getFieldNames(context, dirName))
        };
        since = tailFrom(spec, dirSub, tailWatermark);
        (shouldRebuild, changes) = if (since.value > 0) {
          // we can only chunk while tables are since 0 as we'll emit
          // zero checkpoints. once a nonzero request is handled, we must
          // make sure that it doesn't ultimately get sent back as part of a
          // zero-checkpoint chunk - otherwise it won't be applied
          // TODO: optimisation, request all 0 tables first
          !chunkingDisabled = true;
          (shouldRebuild, changes) = edir.getChangesAfter(since, forceReset);
          (shouldRebuild, changes.iterator())
        } else {
          // if since is zero, the receiver is specifying that they
          // have no data to tail since. to avoid a likely reset and
          // allow chunking, we stream the current state of the table
          // and begin tailing from here.
          (false, edir.unsafeGetFileIterNoReducer(None()).map(pair -> pair.i0))
        };

        // Write checkpoints out at least every `checkpointInterval` rows during
        // initialization, so that the client can start processing without waiting
        // for the full changeset.
        // this value is chosen based on some unscientific local testing
        checkpointInterval = if (since.value == 0 && !chunkingDisabled) {
          512
        } else {
          Int::max
        };

        producedOutput = edir.writeDiff(
          context,
          shouldRebuild,
          changes.iterator(),
          writer,
          dirSub.entity,
          format,
          dirSub.filter,
          dirSub.getDestinationWatermark(context),
          checkpointInterval,
          since.value < 1, // the client has nothing, so send everything
        );
        !producedAnyOutput = producedAnyOutput || producedOutput;
        !couldFollowChanges = couldFollowChanges && !shouldRebuild;
      };

      // produce checkpoint for flushing and committing
      if (init || producedAnyOutput) {
        // always do this on first iteration to ensure we output a
        // checkpoint without delay so that the downstreams knows that
        // it has received everything without waiting for the condvar
        // timeout
        writer.write(":" + context.tick.value.toString() + "\n");
        writer.flush();
        flushStdout();
      };

      if (couldFollowChanges) {
        Some(context.tick.value)
      } else {
        None()
      }
    });

    !tailWatermark = tick match {
    // if we cannot follow changes from here - regardless of whether
    // we want to - this is a failure to honour the request. i.e.
    // the since value is too far in the past. the user should be
    // made aware and take action, probably using the rebuild
    // mechanism.
    | None() -> break false
    | Some(_) -> tick
    };
    !init = false;
    !forceReset = false;
    lock = SKStore.unfreezeLock(sub.lock);
    cond = SKStore.unfreezeCond(sub.cond);
    SKStore.mutexLock(lock);
    while ({
      !forceReset &&
        {
          SKStore.withContext(newContext -> {
            shouldWait =
              follow &&
              !tailShouldWake(
                newContext,
                sub,
                SKStore.Tick(tailWatermark.fromSome()),
              );
            shouldWait
          })
        }
    }) {
      timeoutSecs = 10;
      _ = SKStore.condTimedWait(cond, lock, UInt32::truncate(timeoutSecs));
      print_raw(":" + tailWatermark.fromSome().toString() + "\n");
      flushStdout();
      if (
        SKStore.withContext(privacyContext -> {
          SKDB.userPrivacyChanged(
            privacyContext,
            userIDOpt,
            SKStore.Tick(tailWatermark.fromSome()),
            sub.destinationSource,
          )
        })
      ) {
        !forceReset = true;
      }
    };
    SKStore.mutexUnlock(lock);
    SKStore.destroyObstack(localObstack);
    if (!follow) {
      break true
    }
  }
}

module end;
