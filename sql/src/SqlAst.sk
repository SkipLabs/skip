module SKDB;

value class Name private (
  lower: String,
  origName: String,
) uses Orderable, Hashable, Show {
  static fun create(value: String): this {
    static(value.lowercase(), value)
  }

  fun compare(y: Name): Order {
    this.lower.compare(y.lower)
  }

  fun hash(): Int {
    this.lower.hash()
  }

  fun toString(): String {
    this.origName
  }
}

base class Stmt{pos: Int} uses Equality {
  children =
  | BeginTransaction{kind: TransactionKind}
  | EndTransaction{}
  | CreateView{
    virtual: Bool,
    name: Name,
    ifNotExists: Bool,
    query: Select,
    text: String,
  }
  | CreateIndex{
    ifNotExists: Bool,
    name: Name,
    on: Name,
    columns: Array<IndexedColumn>,
    unique: Bool,
    where: ?Expr,
    text: ?String,
  }
  | DropTable{name: Name, ifExists: Bool}
  | DropView{name: Name, ifExists: Bool}
  | DropIndex{name: Name, ifExists: Bool}
  | Delete{name: Name, alias: ?Name, where: ?Expr, indexed: ?Name}
  | Insert{
    onConflict: ?OnConflict,
    name: Name,
    alias: ?Name,
    paramsOpt: ?Array<Name>,
    values: InsertValues,
  }
  | Update{
    onConflict: ?OnConflict,
    name: Name,
    alias: ?Name,
    indexed: ?Name,
    sets: Array<UpdateSet>,
    where: ?Expr,
  }
  | Pragma{name: TableName, value: ?Value}
}

class UpdateSet(columns: Array<(Int, Name)>, value: Expr) uses Equality

base class CreateTable{ifNotExists: Bool, name: Name} extends Stmt {
  children =
  | CreateTableSchema{schema: TableSchema}
  | CreateTableAs{select: Select}
}

class TableSchema{
  columns: Array<ColumnDefinition>,
  constraints: Array<TableConstraint>,
  withoutRowid: Bool,
  strict: Bool,
} uses Equality

class ColumnDefinition{
  name: Name,
  // TODO: SQLite allows unspecified type.
  ty: Type,
  primary: ?CCPrimaryKey = None(),
  notNull: ?CCNotNull = None(),
  unique: ?CCUnique = None(),
  default: ?CCDefault = None(),
  check: ?CCCheck = None(),
  collate: ?CCCollate = None(),
  foreignKey: ?CCForeignKey = None(),
  generated: ?CCGenerated = None(),
} uses Equality

// TODO: Add `pos` for better error messages.
base class ColumnConstraint{constraintName: ?Name = None()} uses Equality {
  children =
  | CCPrimaryKey{
    order: IKind,
    autoincrement: Bool,
    onConflict: ?OnConflict = None(),
  }
  | CCNotNull{onConflict: ?OnConflict = None()}
  | CCUnique{onConflict: ?OnConflict = None()}
  | CCCheck{expr: Expr}
  | CCDefault{expr: Expr}
  | CCCollate{name: String}
  | CCForeignKey{references: ForeignKeyClause}
  | CCGenerated{expr: Expr, stored: Bool, virtual: Bool}
}

base class TableConstraint{constraintName: ?String} uses Equality {
  children =
  | TCPrimaryKey{columns: Array<IndexedColumn>, onConflict: ?OnConflict}
  | TCUnique{columns: Array<IndexedColumn>, onConflict: ?OnConflict}
  | TCCheck{expr: Expr}
  | TCForeignKey{columns: Array<Name>, references: ?ForeignKeyClause}
}

class IndexedColumn{expr: Expr, collate: ?Name, order: IKind} uses Equality

// TODO
class ForeignKeyClause{} uses Equality

base class OnConflict uses Equality {
  children =
  | OCIgnore()
  | OCReplace()
  | OCUpdate(Update)
}

class TableName(
  name: FromName,
  asName: ?Name,
  indexed: Bool = true,
) uses Equality

base class InsertValues uses Equality {
  children =
  | IValues(Array<Array<Expr>>)
  | IQuery(Select)
  | IDefault()
}

base class IKind uses Orderable {
  children =
  | INONE()
  | IASC()
  | IDESC()
}

base class FromName uses Equality {
  children =
  | FName(Name)
  | FQuery(Select)
}

class Select{
  id: Name,
  distinct: Bool,
  params: Array<SelectResult>,
  from: ?Array<TableName>,
  join: ?Join,
  where: ?Expr,
  groupBy: ?Array<Expr>,
  having: ?Expr,
  orderBy: ?Array<(Expr, IKind)>,
  limit: ?Expr,
  rest: ?(CompoundOperator, Select),
  shouldExpand: Bool = false,
} extends Stmt

base class SelectResult uses Equality {
  children =
  | SelectStar(table: ?Name)
  | SelectExpr(expr: Expr, alias: ?Name)
}

class Join{
  kind: JoinKind,
  names: Array<TableName>,
  on: ?(Expr, Array<Expr>),
} uses Equality

base class JoinKind uses Orderable, Hashable {
  children =
  | JLeft(natural: Bool)
  | JRight(natural: Bool)
  | JFull(natural: Bool)
  | JInner(natural: Bool)
  | JCross()
}

base class CompoundOperator uses Orderable {
  children =
  | COUnion()
  | COUnionAll()
  | COIntersect()
  | COExcept()
}

base class Value extends Expr {
  children =
  | VNull()
  | VInt(Int)
  | VFloat(Float)
  | VString(String)
  | VSeqNum(Bool, ?String)
  | VId(?String)
  | VTime()
  | VParam(String)
  | VPermission(Value)
}

base class Expr uses Equality {
  children =
  | In(Expr, InValues, negated: Bool)
  | Between(Expr, Expr, Expr, negated: Bool)
  | Like(Expr, Expr, escape: ?Expr, negated: Bool)
  | On(JoinKind, Expr)
  | BinOp(BinaryOperator, Expr, Expr)
  | Subquery(Select)
  | Exists(Select, negated: Bool)
  | UnOp(UnaryOperator, Expr)
  | Tuple(Array<Expr>)
  | Case(condOpt: ?Expr, whenCases: Array<(Expr, Expr)>, elseCase: ?Expr)
  | Call(Name, Array<Expr>, distinct: Bool)
  | Cast(Expr, Type)
  | Collate(Expr, Name)
}

class Identifier(
  name: Name,
  table: ?Name = None(),
) extends Expr uses Hashable, Show {
  fun toString(): String {
    this.table match {
    | Some(table) -> `${table}.${this.name}`
    | None() -> this.name.toString()
    }
  }
}

base class UnaryOperator uses Equality {
  children =
  | UnaryNot()
  | UnaryPlus()
  | UnaryMinus()
  | UnaryBitNot()
  | UnaryIsNull(negated: Bool)
}

base class BinaryOperator uses Equality, Show {
  children =
  | OPlus()
  | OMinus()
  | OConcat()
  //  | OArrow() // (->)
  //  | OLongArrow() // (->>)
  | OMul()
  | ODiv()
  | OMod()
  | OBitAnd()
  | OBitOr()
  | OBitShiftLeft()
  | OBitShiftRight()
  | OAnd()
  | OOr()
  | OLt()
  | OLtEq()
  | OGt()
  | OGtEq()
  | OEq()
  | ONeq()
  | OIs(negated: Bool)
  | OGlob(negated: Bool)
  | ORegexp(negated: Bool)
  | OMatch(negated: Bool)

  static fun fromString(str: String): BinaryOperator {
    str match {
    | "+" -> OPlus()
    | "-" -> OMinus()
    | "||" -> OConcat()
    //  | OArrow() // (->)
    //  | OLongArrow() // (->>)
    | "*" -> OMul()
    | "/" -> ODiv()
    | "%" -> OMod()
    | "&" -> OBitAnd()
    | "|" -> OBitOr()
    | "<<" -> OBitShiftLeft()
    | ">>" -> OBitShiftRight()
    | "AND" -> OAnd()
    | "OR" -> OOr()
    | "<" -> OLt()
    | "<=" -> OLtEq()
    | ">" -> OGt()
    | ">=" -> OGtEq()
    | "=" | "==" -> OEq()
    | "!=" | "<>" -> ONeq()
    | "IS NOT" -> OIs(true)
    | "IS" -> OIs(false)
    | "NOT GLOB" -> OGlob(true)
    | "GLOB" -> OGlob(false)
    | "NOT REGEXP" -> ORegexp(true)
    | "REGEXP" -> ORegexp(false)
    | "NOT MATCH" -> OMatch(true)
    | "MATCH" -> OMatch(false)
    | _ -> invariant_violation("Unrecognized binary op: " + str)
    }
  }

  fun toString(): String
  | OPlus() -> "+"
  | OMinus() -> "-"
  | OConcat() -> "||"
  | OMul() -> "*"
  | ODiv() -> "/"
  | OMod() -> "%"
  | OBitAnd() -> "&"
  | OBitOr() -> "|"
  | OBitShiftLeft() -> "<<"
  | OBitShiftRight() -> ">>"
  | OAnd() -> "AND"
  | OOr() -> "OR"
  | OLt() -> "<"
  | OLtEq() -> "<="
  | OGt() -> ">"
  | OGtEq() -> ">="
  | OEq() -> "="
  | ONeq() -> "<>"
  | OIs(negated) -> if (negated) "IS NOT" else "IS"
  | OGlob(negated) -> if (negated) "NOT GLOB" else "GLOB"
  | ORegexp(negated) -> if (negated) "NOT REGEXP" else "REGEXP"
  | OMatch(negated) -> if (negated) "NOT MATCH" else "MATCH"
}

base class InValues uses Equality {
  children =
  | InList(Array<Expr>)
  | InSelect(Select)
}

base class Type uses Orderable {
  children =
  | FLOAT()
  | INTEGER()
  | TEXT()
}

base class TransactionKind uses Equality {
  children =
  | TransactionDeferred()
  | TransactionImmediate()
  | TransactionExclusive()
}

/*****************************************************************************/
/* Looks for an aggregate function. */
/*****************************************************************************/

fun hasAggr(expr: Expr): Bool {
  expr match {
  | Value _ -> false
  | Identifier _ -> false
  | Between(e, _, _, _)
  | UnOp(_, e) ->
    hasAggr(e)
  | In(e, InList(arr), _) ->
    hasAggr(e) ||
      for (x in arr) {
        if (hasAggr(x)) break true;
      } else {
        false
      }
  | In(_, InSelect _, _) -> invariant_violation("IN SELECT not implemented")
  | BinOp(_, e1, e2)
  | Like(e1, e2, _, _) ->
    hasAggr(e1) || hasAggr(e2)
  | On(_, e) -> hasAggr(e)
  | Subquery(_)
  | Exists _ ->
    false
  | Case(condOpt, whenCases, elseCase) ->
    condOpt match {
    | Some(e) if (hasAggr(e)) -> return true
    | _ -> void
    };
    for (kv in whenCases) {
      (e1, e2) = kv;
      if (hasAggr(e1) || hasAggr(e2)) return true;
    };
    elseCase match {
    | Some(e) if (hasAggr(e)) -> true
    | _ -> false
    }
  | Call(fname, args, _) ->
    if (Array["min", "max", "sum", "avg", "count"].contains(fname.lower)) {
      return true
    };
    for (e in args) {
      if (hasAggr(e)) return true
    };
    false
  | Cast(e, _) -> hasAggr(e)
  | Tuple(values) -> values.any(hasAggr)
  | Collate(e, _) -> hasAggr(e)
  }
}

fun selectIsAggr(select: Select): Bool {
  select.groupBy is Some _ ||
    {
      for (param in select.params) {
        param match {
        | SelectExpr(e, _) if (hasAggr(e)) -> return true
        | _ -> void
        }
      };
      false
    }
}

fun selectOrRestIsAggrOrEmptyFrom(select: Select): Bool {
  selectIsAggr(select) ||
    select.from is None() ||
    select.rest match {
    | Some((_, q)) -> selectOrRestIsAggrOrEmptyFrom(q)
    | None() -> false
    }
}
