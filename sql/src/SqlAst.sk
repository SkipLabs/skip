module SKDB;

value class Name private (
  lower: String,
  origName: String,
) uses Orderable, Hashable, Show {
  static fun create(value: String): this {
    static(value.lowercase(), value)
  }

  fun compare(y: Name): Order {
    this.lower.compare(y.lower)
  }

  fun hash(): Int {
    this.lower.hash()
  }

  fun toString(): String {
    this.origName
  }
}

base class Stmt {
  children =
  | CreateTable{
    pos: Int,
    name: Name,
    schema: Array<TypeDescr>,
    ifNotExists: Bool,
  }
  | CreateView{
    pos: Int,
    virtual: Bool,
    name: Name,
    ifNotExists: Bool,
    query: Query,
    text: String,
  }
  | CreateIndex{
    pos: Int,
    ifNotExists: Bool,
    name: Name,
    fields: (Name, Array<(Name, IKind)>),
    unique: Bool,
    primary: Bool,
    text: ?String,
  }
  | DropTable{pos: Int, name: Name}
  | DropView{pos: Int, name: Name}
  | DropIndex{pos: Int, name: Name}
  | Delete{pos: Int, colName: ?Name, name: Name, where: ?Expr}
  | Insert{
    pos: Int,
    onConflict: ?OnConflict,
    name: Name,
    paramsOpt: ?Array<Name>,
    values: InsertValues,
  }
  | Update{pos: Int, name: Name, sets: Array<(Name, Pos, Expr)>, where: ?Expr}
}

base class OnConflict {
  children =
  | OCIgnore()
  | OCReplace()
  | OCUpdate(Update)
}

class TableName(name: FromName, asName: ?Name, indexed: Bool = true)

base class InsertValues {
  children =
  | IValues(Array<Array<Value>>)
  | IQuery(Query)
}

base class IKind uses Orderable {
  children =
  | INONE()
  | IASC()
  | IDESC()
}

base class FromName {
  children =
  | FName(Name)
  | FQuery(Query)
}

base class Query

class SelectParams(isStar: Bool, params: Array<(Expr, ?Name)>)

class Select{
  id: Name,
  pos: Int,
  distinct: Bool,
  params: SelectParams,
  from: ?Array<TableName>,
  join: ?Join,
  where: ?Expr,
  groupBy: ?Array<(Expr, ?Name)>,
  having: ?Expr,
  orderBy: ?Array<(Expr, IKind)>,
  limit: ?Expr,
  rest: ?(QueryKind, Select),
  shouldExpand: Bool = false,
} extends Query, Stmt

class Join{kind: JoinKind, names: Array<TableName>, on: ?(Expr, Array<Expr>)}

base class JoinKind uses Orderable {
  children =
  | JLeft(Bool)
  | JRight(Bool)
  | JCross()
  | JOuter()
  | JInner()
  | JNone()
}

base class QueryKind uses Orderable {
  children =
  | QExcept()
  | QUnion(QUnionKind)
  | QIntersect(Bool)
}

base class QUnionKind uses Orderable {
  children =
  | USingle()
  | UAll()
  | UIntersect()
}

base class Value extends Expr uses Equality {
  children =
  | VNull()
  | VInt(Int)
  | VFloat(Float)
  | VString(String)
  | VId(Bool, ?String)
  | VTime()
  | VParam(String)
}

base class Expr {
  children =
  | Not(Expr)
  | Distinct(Expr)
  | In(Expr, Array<Expr>)
  | Between(Expr)
  | On(JoinKind, Expr)
  | Binop(String, Expr, Expr)
  | EQuery(Query)
  | Exists(Query)
  | UMinus(Expr)
  | UPlus(Expr)
  | Case(condOpt: ?Expr, whenCases: Array<(Expr, Expr)>, elseCase: ?Expr)
  | Call(Name, ?Array<Expr>)
  | Cast(Expr, Type)
}

class Identifier(
  name: Name,
  table: ?Name = None(),
) extends Expr uses Orderable, Hashable, Show {
  fun compare(y: Identifier): Order {
    res = this.table.compare(y.table);
    if (res == EQ()) {
      this.name.compare(y.name)
    } else {
      res
    }
  }

  fun toString(): String {
    this.table match {
    | Some(table) -> `${table}.${this.name}`
    | None() -> this.name.toString()
    }
  }
}

class TypeDescr{
  name: Name,
  ty: Type,
  primary: Bool,
  unique: Bool,
  default: ?Value,
  notNull: Bool,
} uses Equality

base class Type uses Orderable {
  children =
  | FLOAT()
  | INTEGER()
  | TEXT()
}

/*****************************************************************************/
/* Looks for an aggregate function. */
/*****************************************************************************/

fun hasAggr(expr: Expr): Bool {
  expr match {
  | Value _ -> false
  | Identifier _ -> false
  | Not(e)
  | Between(e)
  | UMinus(e)
  | UPlus(e)
  | Distinct(e) ->
    hasAggr(e)
  | In(e, arr) ->
    hasAggr(e) ||
      for (x in arr) {
        if (hasAggr(x)) break true;
      } else {
        false
      }
  | Binop(_, e1, e2) -> hasAggr(e1) || hasAggr(e2)
  | On(_, e) -> hasAggr(e)
  | EQuery(_)
  | Exists(_) ->
    false
  | Case(condOpt, whenCases, elseCase) ->
    condOpt match {
    | Some(e) if (hasAggr(e)) -> return true
    | _ -> void
    };
    for (kv in whenCases) {
      (e1, e2) = kv;
      if (hasAggr(e1) || hasAggr(e2)) return true;
    };
    elseCase match {
    | Some(e) if (hasAggr(e)) -> true
    | _ -> false
    }
  | Call(
    fname,
    _,
  ) if (Array["min", "max", "sum", "avg", "count"].contains(fname.lower)) ->
    true
  | Call(_, None()) -> false
  | Call(_, Some(arr)) ->
    for (e in arr) {
      if (hasAggr(e)) return true
    };
    false
  | Cast(e, _) -> hasAggr(e)
  }
}

fun selectIsAggr(select: Select): Bool {
  select.groupBy is Some _ ||
    {
      for (e in select.params.params) {
        if (hasAggr(e.i0)) return true;
      };
      false
    }
}

fun selectOrRestIsAggrOrEmptyFrom(select: Select): Bool {
  selectIsAggr(select) ||
    select.from is None() ||
    select.rest match {
    | Some((_, q)) -> selectOrRestIsAggrOrEmptyFrom(q)
    | None() -> false
    }
}
