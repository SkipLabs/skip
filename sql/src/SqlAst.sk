module SKDB;

value class Name private (
  lower: String,
  origName: String,
) uses Orderable, Hashable, Show {
  static fun create(value: String): this {
    static(value.lowercase(), value)
  }

  fun compare(y: Name): Order {
    this.lower.compare(y.lower)
  }

  fun hash(): Int {
    this.lower.hash()
  }

  fun toString(): String {
    this.origName
  }
}

base class Stmt {
  children =
  | CreateTable{
    pos: Int,
    name: Name,
    schema: Array<TypeDescr>,
    ifNotExists: Bool,
  }
  | CreateView{
    pos: Int,
    virtual: Bool,
    name: Name,
    ifNotExists: Bool,
    query: Query,
    text: String,
  }
  | CreateIndex{
    pos: Int,
    ifNotExists: Bool,
    name: Name,
    fields: (Name, Array<(Name, IKind)>),
    unique: Bool,
    primary: Bool,
    text: ?String,
  }
  | DropTable{pos: Int, name: Name}
  | DropView{pos: Int, name: Name}
  | DropIndex{pos: Int, name: Name}
  | Delete{pos: Int, colName: ?Name, name: Name, where: ?Expr}
  | Insert{
    pos: Int,
    onConflict: ?OnConflict,
    name: Name,
    paramsOpt: ?Array<Name>,
    values: InsertValues,
  }
  | Update{pos: Int, name: Name, sets: Array<(Name, Pos, Expr)>, where: ?Expr}
}

base class OnConflict {
  children =
  | OCIgnore()
  | OCReplace()
  | OCUpdate(Update)
}

class TableName(name: FromName, asName: ?Name, indexed: Bool = true)

base class InsertValues {
  children =
  | IValues(Array<Array<Value>>)
  | IQuery(Query)
}

base class IKind uses Orderable {
  children =
  | INONE()
  | IASC()
  | IDESC()
}

base class FromName {
  children =
  | FName(Name)
  | FQuery(Query)
}

base class Query

class SelectParams(isStar: Bool, params: Array<(Expr, ?Name)>)

class Select{
  id: Name,
  pos: Int,
  distinct: Bool,
  params: SelectParams,
  from: ?Array<TableName>,
  join: ?Join,
  where: ?Expr,
  groupBy: ?Array<(Expr, ?Name)>,
  having: ?Expr,
  orderBy: ?Array<(Expr, IKind)>,
  limit: ?Expr,
  rest: ?(QueryKind, Select),
  shouldExpand: Bool = false,
} extends Query, Stmt

class Join{kind: JoinKind, names: Array<TableName>, on: ?(Expr, Array<Expr>)}

base class JoinKind uses Orderable {
  children =
  | JLeft(natural: Bool)
  | JRight(natural: Bool)
  | JFull(natural: Bool)
  | JInner(natural: Bool)
  | JCross()
}

base class QueryKind uses Orderable {
  children =
  | QExcept()
  | QUnion(QUnionKind)
  | QIntersect(Bool)
}

base class QUnionKind uses Orderable {
  children =
  | USingle()
  | UAll()
  | UIntersect()
}

base class Value extends Expr uses Equality {
  children =
  | VNull()
  | VInt(Int)
  | VFloat(Float)
  | VString(String)
  | VId(Bool, ?String)
  | VTime()
  | VParam(String)
}

base class Expr {
  children =
  | Not(Expr)
  | In(Expr, InValues, negated: Bool)
  | Between(Expr, Expr, Expr, negated: Bool)
  | Like(Expr, Expr, escape: ?Expr, negated: Bool)
  | On(JoinKind, Expr)
  | BinOp(BinaryOperator, Expr, Expr)
  | Subquery(Query)
  | Exists(Query, negated: Bool)
  | UnOp(UnaryOperator, Expr)
  | Case(condOpt: ?Expr, whenCases: Array<(Expr, Expr)>, elseCase: ?Expr)
  | Call(Name, Array<Expr>, distinct: Bool)
  | Cast(Expr, Type)
}

class Identifier(
  name: Name,
  table: ?Name = None(),
) extends Expr uses Orderable, Hashable, Show {
  fun compare(y: Identifier): Order {
    res = this.table.compare(y.table);
    if (res == EQ()) {
      this.name.compare(y.name)
    } else {
      res
    }
  }

  fun toString(): String {
    this.table match {
    | Some(table) -> `${table}.${this.name}`
    | None() -> this.name.toString()
    }
  }
}

base class UnaryOperator {
  children =
  | UnaryNot()
  | UnaryPlus()
  | UnaryMinus()
  | UnaryBitNot()
  | UnaryIsNull(negated: Bool)
}

base class BinaryOperator uses Show {
  children =
  | OPlus()
  | OMinus()
  | OConcat()
  //  | OArrow() // (->)
  //  | OLongArrow() // (->>)
  | OMul()
  | ODiv()
  | OMod()
  | OBitAnd()
  | OBitOr()
  | OBitShiftLeft()
  | OBitShiftRight()
  | OAnd()
  | OOr()
  | OLt()
  | OLtEq()
  | OGt()
  | OGtEq()
  | OEq()
  | ONeq()
  | OIs(negated: Bool)
  | OGlob(negated: Bool)
  | ORegexp(negated: Bool)
  | OMatch(negated: Bool)

  static fun fromString(str: String): BinaryOperator {
    str match {
    | "+" -> OPlus()
    | "-" -> OMinus()
    | "||" -> OConcat()
    //  | OArrow() // (->)
    //  | OLongArrow() // (->>)
    | "*" -> OMul()
    | "/" -> ODiv()
    | "%" -> OMod()
    | "&" -> OBitAnd()
    | "|" -> OBitOr()
    | "<<" -> OBitShiftLeft()
    | ">>" -> OBitShiftRight()
    | "AND" -> OAnd()
    | "OR" -> OOr()
    | "<" -> OLt()
    | "<=" -> OLtEq()
    | ">" -> OGt()
    | ">=" -> OGtEq()
    | "=" | "==" -> OEq()
    | "!=" | "<>" -> ONeq()
    | "IS NOT" -> OIs(true)
    | "IS" -> OIs(false)
    | "NOT GLOB" -> OGlob(true)
    | "GLOB" -> OGlob(false)
    | "NOT REGEXP" -> ORegexp(true)
    | "REGEXP" -> ORegexp(false)
    | "NOT MATCH" -> OMatch(true)
    | "MATCH" -> OMatch(false)
    | _ -> invariant_violation("Unrecognized binary op: " + str)
    }
  }

  fun toString(): String
  | OPlus() -> "+"
  | OMinus() -> "-"
  | OConcat() -> "||"
  | OMul() -> "*"
  | ODiv() -> "/"
  | OMod() -> "%"
  | OBitAnd() -> "&"
  | OBitOr() -> "|"
  | OBitShiftLeft() -> "<<"
  | OBitShiftRight() -> ">>"
  | OAnd() -> "AND"
  | OOr() -> "OR"
  | OLt() -> "<"
  | OLtEq() -> "<="
  | OGt() -> ">"
  | OGtEq() -> ">="
  | OEq() -> "="
  | ONeq() -> "<>"
  | OIs(negated) -> if (negated) "IS NOT" else "IS"
  | OGlob(negated) -> if (negated) "NOT GLOB" else "GLOB"
  | ORegexp(negated) -> if (negated) "NOT REGEXP" else "REGEXP"
  | OMatch(negated) -> if (negated) "NOT MATCH" else "MATCH"
}

base class InValues {
  children =
  | InList(Array<Expr>)
  | InSelect(Select)
}

class TypeDescr{
  name: Name,
  ty: Type,
  primary: Bool,
  unique: Bool,
  default: ?Value,
  notNull: Bool,
} uses Equality

base class Type uses Orderable {
  children =
  | FLOAT()
  | INTEGER()
  | TEXT()
}

/*****************************************************************************/
/* Looks for an aggregate function. */
/*****************************************************************************/

fun hasAggr(expr: Expr): Bool {
  expr match {
  | Value _ -> false
  | Identifier _ -> false
  | Not(e)
  | Between(e, _, _, _)
  | UnOp(_, e) ->
    hasAggr(e)
  | In(e, InList(arr), _) ->
    hasAggr(e) ||
      for (x in arr) {
        if (hasAggr(x)) break true;
      } else {
        false
      }
  | In(_, InSelect _, _) -> invariant_violation("IN SELECT not implemented")
  | BinOp(_, e1, e2)
  | Like(e1, e2, _, _) ->
    hasAggr(e1) || hasAggr(e2)
  | On(_, e) -> hasAggr(e)
  | Subquery(_)
  | Exists _ ->
    false
  | Case(condOpt, whenCases, elseCase) ->
    condOpt match {
    | Some(e) if (hasAggr(e)) -> return true
    | _ -> void
    };
    for (kv in whenCases) {
      (e1, e2) = kv;
      if (hasAggr(e1) || hasAggr(e2)) return true;
    };
    elseCase match {
    | Some(e) if (hasAggr(e)) -> true
    | _ -> false
    }
  | Call(fname, args, _) ->
    if (Array["min", "max", "sum", "avg", "count"].contains(fname.lower)) {
      return true
    };
    for (e in args) {
      if (hasAggr(e)) return true
    };
    false
  | Cast(e, _) -> hasAggr(e)
  }
}

fun selectIsAggr(select: Select): Bool {
  select.groupBy is Some _ ||
    {
      for (e in select.params.params) {
        if (hasAggr(e.i0)) return true;
      };
      false
    }
}

fun selectOrRestIsAggrOrEmptyFrom(select: Select): Bool {
  selectIsAggr(select) ||
    select.from is None() ||
    select.rest match {
    | Some((_, q)) -> selectOrRestIsAggrOrEmptyFrom(q)
    | None() -> false
    }
}
