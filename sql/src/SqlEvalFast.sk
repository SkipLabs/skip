module SKSQL;

/*****************************************************************************/
/* Function evaluating a select when we are not in a transaction.
 * Because we don't have to maintain those kind of queries incrementally we
 * can affort to be much faster.
 *
 * Because not all constructions are supported (joins/group by), the function
 * returns a boolean specifying if it was successful or not.
 */
/*****************************************************************************/

mutable class SelectFast{
  context: mutable SKFS.Context,
  compiler: mutable Compiler,
  lex: Lexer,
} {
  static fun run(
    options: Options,
    origContext: readonly SKFS.Context,
    lex: Lexer,
    pos: Int,
  ): Bool {
    context = origContext.mclone();
    result = (mutable static{
      context,
      compiler => Compiler::create(true, options, pos),
      lex,
    }).select(pos);
    result
  }

  private mutable fun getFrom(pos: Int): ?(Int, Array<DirDescr>) {
    if (this.lex.isEqUpper(pos, "FROM")) {
      !pos = this.lex.expectUpper(pos, "FROM");
    } else {
      return None();
    };
    tableNames = if (this.lex.isEq(pos, "(")) {
      return None();
    } else {
      (!pos, tableNames) = parseTableNames(this.lex, pos);
      if (tableNames.size() != 1) return None();
      tableNames
    };
    from = this.compiler.compileFrom(this.context, Some(tableNames));
    Some((pos, from))
  }

  private mutable fun getWhere(pos: Int): (Int, ?Expr) {
    whereAst = if (this.lex.isEqUpper(pos, "WHERE")) {
      !pos = this.lex.expectUpper(pos, "WHERE");
      (!pos, e) = parseExpr(this.lex, pos);
      Some(e)
    } else {
      None()
    };
    (pos, whereAst)
  }

  private mutable fun getLimit(pos: Int): ?(Int, ?Int) {
    limit = if (this.lex.isEqUpper(pos, "LIMIT")) {
      !pos = this.lex.expectUpper(pos, "LIMIT");
      (!pos, limit) = this.lex.nextWord(pos);
      limit.toIntOption() match {
      | None() -> return None()
      | x -> x
      }
    } else {
      None()
    };
    Some((pos, limit))
  }

  private mutable fun selectLoop(
    fromRanges: Array<(DirDescr, ?Array<SKFS.KeyRange>)>,
    cparams: ?Array<CGExpr>,
    where: ?CExpr<Int>,
    limitOpt: ?Int,
    f: RowValues -> void,
  ): void {
    limit = limitOpt match {
    | None() -> Int::max
    | Some(x) -> x
    };
    dir = this.context.unsafeGetEagerDir(fromRanges[0].i0.dirName);
    (start, end) = fromRanges[0].i1 match {
    | Some(keyRanges) if (keyRanges.size() == 1) ->
      (Some(keyRanges[0].start), Some(keyRanges[0].end))
    | _ -> (None(), None())
    };
    iter = dir.unsafeGetFileIter(start);
    i = 0;
    loop {
      iter.next() match {
      | None() -> return void
      | Some((_, files)) ->
        for (file in files) {
          row = RowValues::fromFile(file);
          end match {
          | Some(endRow @ RowKey(RowValues _, kinds)) ->
            if (RowKey(row, kinds) > endRow) {
              return void
            }
          | _ -> void
          };
          evaluator = ExprEvaluator(None(), Array[row], fromRanges, None());
          whereVal = evaluator.evalWhere(this.context, where);
          whereVal match {
          | ANull()
          | ADef(0) ->
            continue
          | _ ->
            cparams match {
            | None() ->
              for (_ in Range(0, row.repeat)) {
                if (i >= limit) return void;
                f(row);
                !i = i + 1;
              }
            | Some(cp) ->
              !row = SelectEvaluator::evalRow(
                this.context,
                evaluator,
                cp,
                row.repeat,
              );
              for (_ in Range(0, row.repeat)) {
                if (i >= limit) return void;
                f(row);
                !i = i + 1;
              }
            }
          }
        }
      }
    };
  }

  mutable private fun select(pos: Int): Bool {
    !pos = this.lex.expectUpper(pos, "SELECT");
    if (this.lex.isEqUpper(pos, "ALL")) {
      !pos = this.lex.expectUpper(pos, "ALL");
    } else if (this.lex.isEqUpper(pos, "DISTINCT")) {
      return false
    };
    (!pos, params) = parseSelectParams(this.lex, pos);
    (!pos, from) = this.getFrom(pos) match {
    | None() -> return false
    | Some(x) -> x
    };
    (!pos, whereAst) = this.getWhere(pos);
    orderByAst = if (this.lex.isEqUpper(pos, "ORDER")) {
      (!pos, orderBy) = parseOrderBy(this.lex, pos);
      Some(orderBy)
    } else {
      None()
    };
    (!pos, limitOpt) = this.getLimit(pos) match {
    | None() -> return false
    | Some(x) -> x
    };
    if (this.lex.isEq(pos, ";")) {
      !pos = this.lex.expect(pos, ";");
    } else {
      if (!isEOF(this.lex, pos)) {
        return false;
      }
    };
    cparams = if (params.isStar && params.params.isEmpty()) None() else {
      Some(this.compiler.compileParams(this.context, params, from))
    };
    (!whereAst, fromRanges) = this.compiler.compileJoin(
      this.context,
      from,
      whereAst,
    );
    whereOpt = this.compiler.compileWhere(this.context, whereAst);
    orderBy = this.compiler.compileOrderBy(
      params,
      from.map(x -> (x, None())),
      orderByAst,
    );
    table = from[0];
    format = this.compiler.options.format match {
    | OFK_CSV() -> SKFS.OCSV()
    | OFK_JSON() ->
      fieldNames = table.schema.map(x -> x.name.origName);
      SKFS.OJSON(fieldNames)
    | OFK_SQL() -> SKFS.OSQL()
    };
    if (this.compiler.aggrVars.isEmpty()) {
      orderBy match {
      | None() ->
        this.selectLoop(fromRanges, cparams, whereOpt, limitOpt, row ~>
          print_string(row.toStringSingle(format))
        )
      | Some(userOrder) ->
        order = userOrder.map(x -> (x.i0 - 1, x.i1));
        limitOpt match {
        | None() ->
          acc = mutable Vector[];
          this.selectLoop(fromRanges, cparams, whereOpt, None(), row ->
            acc.push(row)
          );
          acc.sortBy(x ~> x, (x, y) ~> compareRowsFast(order, x, y));
          for (row in acc) {
            for (_ in Range(0, row.repeat)) {
              print_string(row.toStringSingle(format));
            }
          }
        | Some(limit) ->
          acc = mutable FastOrder{capacity => limit, kinds => order};
          this.selectLoop(fromRanges, cparams, whereOpt, None(), row ->
            acc.push(row)
          );
          acc.data.sortBy(x ~> x, (x, y) ~> compareRowsFast(order, x, y));
          for (row in acc.data) {
            for (_ in Range(0, row.repeat)) {
              print_string(row.toStringSingle(format));
            }
          }
        }
      }
    } else {
      state = mutable Vector<Int>[];
      for (aggrVar in this.compiler.aggrVars) {
        aggrVar.i1 match {
        | CIExpr(SKSQL.CIGetFrom(0, _))
        | SKSQL.CIExpr(SKSQL.CILiteral(1)) ->
          void
        | _ -> return false
        };
        aggrVar.i0 match {
        | Count(_) -> state.push(0)
        | _ -> return false
        }
      };
      this.selectLoop(fromRanges, cparams, whereOpt, limitOpt, row -> {
        for (i => aggrVar in this.compiler.aggrVars) {
          aggrVar.i1 match {
          | CIExpr(SKSQL.CIGetFrom(0, n)) ->
            row.getInt(n) match {
            | None() -> void
            | Some(_) -> state![i] = state[i] + 1
            }
          | SKSQL.CIExpr(SKSQL.CILiteral(1)) -> state![i] = state[i] + 1
          | _ -> invariant_violation("Unsupported operation")
          }
        }
      });
      print_string(
        RowValues::create(
          state.toArray().map(x -> Some(CInt(x))),
        ).toStringSingle(format),
      )
    };
    true
  }
}

fun compareRowsFast(
  kinds: Array<(Int, IKind)>,
  x: RowValues,
  y: RowValues,
): Order {
  xsize = x.size();
  ysize = y.size();
  for (i in Range(0, kinds.size())) {
    if (i >= xsize) return LT();
    if (i >= ysize) return GT();
    (idx, direction) = kinds[i];
    value1 = x.getValue(idx);
    value2 = y.getValue(idx);
    (value1, value2) match {
    | (None(), None()) -> continue
    | (None(), _) ->
      return direction match {
      | IDESC() -> GT()
      | _ -> LT()
      }
    | (_, None()) ->
      return direction match {
      | IDESC() -> LT()
      | _ -> GT()
      }
    | (Some(v1), Some(v2)) ->
      cmp = direction match {
      | INONE()
      | IASC() ->
        v1.compare(v2)
      | IDESC() -> v2.compare(v1)
      };
      if (cmp != EQ()) return cmp
    }
  };
  EQ()
}

/*****************************************************************************/
/* Fast order of a fixed capacity. */
/*****************************************************************************/

mutable class FastOrder{
  capacity: Int,
  kinds: Array<(Int, IKind)>,
  data: mutable Vector<RowValues> = mutable Vector[],
} {
  mutable fun push(row: RowValues): void {
    if (this.data.size() < this.capacity) {
      this.data.push(row);
      if (this.data.size() == this.capacity) {
        kinds = this.kinds;
        sortKinds = kinds.map(x ->
          (
            x.i0,
            x.i1 match {
            | INONE()
            | IASC() ->
              IDESC()
            | IDESC() -> IASC()
            },
          )
        );
        this.data.sortBy(x ~> x, (x, y) ~> compareRowsFast(sortKinds, x, y));
      }
    } else {
      this.insert(row)
    }
  }

  mutable private fun heapify(i: Int): void {
    if (i >= this.capacity) return void;
    current = this.data[i];
    if (2 * i >= this.capacity) return void;
    childIdx = 2 * i;
    child = this.data[childIdx];
    if (2 * i + 1 < this.capacity) {
      otherChild = this.data[2 * i + 1];
      compareRowsFast(this.kinds, child, otherChild) match {
      | EQ() -> void
      | LT() ->
        !childIdx = 2 * i + 1;
        !child = otherChild
      | GT() -> void
      }
    };
    compareRowsFast(this.kinds, current, child) match {
    | EQ() -> void
    | LT() ->
      this.data![childIdx] = current;
      this.data![i] = child;
      this.heapify(childIdx)
    | GT() -> void
    }
  }

  mutable private fun insert(row: RowValues): void {
    invariant(this.capacity > 0);
    this.data![0] = row;
    this.heapify(0)
  }
}
