module SKSQL;

/*****************************************************************************/
/* Function evaluating a select when we are not in a transaction.
 * Because we don't have to maintain those kind of queries incrementally we
 * can affort to be much faster.
 *
 * Because not all constructions are supported (joins/group by), the function
 * returns a boolean specifying if it was successful or not.
 */
/*****************************************************************************/

value class SelectOutput<T>{format: SKFS.OutputFormat, items: T}

mutable class SelectFast{
  context: mutable SKFS.Context,
  compiler: mutable Compiler,
  lex: Lexer,
} {
  static fun run(
    options: Options,
    origContext: readonly SKFS.Context,
    lex: Lexer,
    pos: Int,
  ): Bool {
    context = origContext.mclone();
    (mutable static{
      context,
      compiler => Compiler::create(true, options, pos),
      lex,
    }).select(pos) match {
    | None() -> return false
    | Some(selectOutput) ->
      format = selectOutput.format;
      RowValues::printHeader(format);
      for (row in selectOutput.items) {
        RowValues::printItem(format, row);
      }
    };
    true
  }

  private mutable fun getFrom(pos: Int): ?(Int, Array<DirDescr>) {
    if (this.lex.isEqUpper(pos, "FROM")) {
      !pos = this.lex.expectUpper(pos, "FROM");
    } else {
      return None();
    };
    tableNames = if (this.lex.isEq(pos, "(")) {
      return None();
    } else {
      (!pos, tableNames) = parseTableNames(this.lex, pos);
      if (tableNames.size() != 1) return None();
      tableNames
    };
    from = this.compiler.compileFrom(this.context, Some(tableNames));
    Some((pos, from))
  }

  private mutable fun getWhere(pos: Int): (Int, ?Expr) {
    whereAst = if (this.lex.isEqUpper(pos, "WHERE")) {
      !pos = this.lex.expectUpper(pos, "WHERE");
      (!pos, e) = parseExpr(this.lex, pos);
      Some(e)
    } else {
      None()
    };
    (pos, whereAst)
  }

  private mutable fun getLimit(pos: Int): ?(Int, ?Int) {
    limit = if (this.lex.isEqUpper(pos, "LIMIT")) {
      !pos = this.lex.expectUpper(pos, "LIMIT");
      (!pos, limit) = this.lex.nextWord(pos);
      limit.toIntOption() match {
      | None() -> return None()
      | x -> x
      }
    } else {
      None()
    };
    Some((pos, limit))
  }

  private mutable fun selectLoop(
    fromRanges: Array<(DirDescr, ?Array<SKFS.KeyRange>)>,
    cparams: ?Array<CGExpr>,
    where: ?CExpr<Int>,
    limitOpt: ?Int,
  ): mutable Iterator<RowValues> {
    limit = limitOpt match {
    | None() -> Int::max
    | Some(x) -> x
    };
    dir = this.context.unsafeGetEagerDir(fromRanges[0].i0.dirName);
    (start, end) = fromRanges[0].i1 match {
    | Some(keyRanges) if (keyRanges.size() == 1) ->
      (Some(keyRanges[0].start), Some(keyRanges[0].end))
    | _ -> (None(), None())
    };
    iter = dir.unsafeGetFileIter(start);
    i = 0;
    loop {
      iter.next() match {
      | None() -> break void
      | Some((_, files)) ->
        shouldBreak = for (file in files) {
          row = RowValues::fromFile(file);
          end match {
          | Some(endRow @ RowKey(RowValues _, kinds)) ->
            if (RowKey(row, kinds) > endRow) {
              break true
            }
          | _ -> void
          };
          evaluator = ExprEvaluator(None(), Array[row], fromRanges, None());
          whereVal = evaluator.evalWhere(this.context, where);
          whereVal match {
          | ANull()
          | ADef(0) ->
            continue
          | _ ->
            cparams match {
            | None() ->
              shouldBreak = for (_ in Range(0, row.repeat)) {
                if (i >= limit) break true;
                yield row;
                !i = i + 1;
              } else {
                false
              };
              if (shouldBreak) break true
            | Some(cp) ->
              !row = SelectEvaluator::evalRow(
                this.context,
                evaluator,
                cp,
                row.repeat,
              );
              shouldBreak = for (_ in Range(0, row.repeat)) {
                if (i >= limit) break true;
                yield row;
                !i = i + 1;
              } else {
                false
              };
              if (shouldBreak) break true
            }
          }
        } else {
          false
        };
        if (shouldBreak) break void
      }
    }
  }

  static fun printLoop(
    format: SKFS.OutputFormat,
    iter: readonly Sequence<RowValues>,
  ): void {
    RowValues::printHeader(format);
    for (row in iter) {
      RowValues::printItem(format, row);
    }
  }

  static private fun selectNoAggr(
    limitOpt: ?Int,
    orderBy: ?Array<(Int, SKSQL.IKind)>,
    iter: mutable Iterator<RowValues>,
  ): mutable Iterator<RowValues> {
    orderBy match {
    | None() -> iter
    | Some(userOrder) ->
      order = userOrder.map(x -> (x.i0 - 1, x.i1));
      limitOpt match {
      | None() ->
        acc = mutable Vector[];
        for (row in iter) {
          acc.push(row)
        };
        acc.sortBy(x ~> x, (x, y) ~> compareRowsFast(order, x, y));
        acc.iterator()
      | Some(limit) ->
        acc = mutable FastOrder{capacity => limit, kinds => order};
        for (row in iter) {
          acc.push(row)
        };
        acc.data.sortBy(x ~> x, (x, y) ~> compareRowsFast(order, x, y));
        acc.data.iterator()
      }
    }
  }

  mutable private fun selectAggr(
    limitOpt: ?Int,
    iter: mutable Iterator<RowValues>,
  ): ?mutable Iterator<RowValues> {
    limitOpt match {
    | Some(limit) if (limit < 1) -> return Some(Array[].iterator())
    | _ -> void
    };
    state = mutable Vector<Int>[];
    for (aggrVar in this.compiler.aggrVars) {
      aggrVar.i1 match {
      | CIExpr(SKSQL.CIGetFrom(0, _))
      | SKSQL.CIExpr(SKSQL.CILiteral(1)) ->
        void
      | _ -> return None()
      };
      aggrVar.i0 match {
      | Count(_) -> state.push(0)
      | _ -> return None()
      }
    };
    for (row in iter) {
      for (i => aggrVar in this.compiler.aggrVars) {
        aggrVar.i1 match {
        | CIExpr(SKSQL.CIGetFrom(0, n)) ->
          row.getInt(n) match {
          | None() -> void
          | Some(_) -> state![i] = state[i] + 1
          }
        | SKSQL.CIExpr(SKSQL.CILiteral(1)) -> state![i] = state[i] + 1
        | _ -> invariant_violation("Unsupported operation")
        }
      }
    };
    Some(
      Array[
        RowValues::create(state.toArray().map(x -> Some(CInt(x)))),
      ].iterator(),
    )
  }

  mutable private fun select(
    pos: Int,
  ): ?SelectOutput<mutable Iterator<RowValues>> {
    !pos = this.lex.expectUpper(pos, "SELECT");
    if (this.lex.isEqUpper(pos, "ALL")) {
      !pos = this.lex.expectUpper(pos, "ALL");
    } else if (this.lex.isEqUpper(pos, "DISTINCT")) {
      return None()
    };
    (!pos, params) = parseSelectParams(this.lex, pos);
    (!pos, from) = this.getFrom(pos) match {
    | None() -> return None()
    | Some(x) -> x
    };
    (!pos, whereAst) = this.getWhere(pos);
    orderByAst = if (this.lex.isEqUpper(pos, "ORDER")) {
      (!pos, orderBy) = parseOrderBy(this.lex, pos);
      Some(orderBy)
    } else {
      None()
    };
    (!pos, limitOpt) = this.getLimit(pos) match {
    | None() -> return None()
    | Some(x) -> x
    };
    if (this.lex.isEq(pos, ";")) {
      !pos = this.lex.expect(pos, ";");
    } else {
      if (!isEOF(this.lex, pos)) {
        return None();
      }
    };
    cparams = if (params.isStar && params.params.isEmpty()) None() else {
      Some(this.compiler.compileParams(this.context, params, from))
    };
    (!whereAst, fromRanges) = this.compiler.compileJoin(
      this.context,
      from,
      whereAst,
    );
    whereOpt = this.compiler.compileWhere(this.context, whereAst);
    orderBy = this.compiler.compileOrderBy(
      params,
      from.map(x -> (x, None())),
      orderByAst,
    );
    table = from[0];
    format = this.compiler.options.format match {
    | OFK_CSV() -> SKFS.OCSV()
    | OFK_JSON() ->
      fieldNames = table.schema.map(x -> x.name.origName);
      SKFS.OJSON(fieldNames)
    | OFK_SQL() -> SKFS.OSQL()
    | OFK_JS() ->
      fieldNames = table.schema.map(x -> x.name.origName);
      SKFS.OJS(fieldNames)
    };
    isAggr = !this.compiler.aggrVars.isEmpty();
    iter = this.selectLoop(
      fromRanges,
      cparams,
      whereOpt,
      if (isAggr) None() else limitOpt,
    );
    Some(
      SelectOutput{
        format,
        items => if (isAggr) {
          this.selectAggr(limitOpt, iter) match {
          | None() -> return None()
          | Some(x) -> x
          }
        } else {
          static::selectNoAggr(limitOpt, orderBy, iter)
        },
      },
    )
  }
}

fun compareRowsFast(
  kinds: Array<(Int, IKind)>,
  x: RowValues,
  y: RowValues,
): Order {
  xsize = x.size();
  ysize = y.size();
  for (i in Range(0, kinds.size())) {
    if (i >= xsize) return LT();
    if (i >= ysize) return GT();
    (idx, direction) = kinds[i];
    value1 = x.getValue(idx);
    value2 = y.getValue(idx);
    (value1, value2) match {
    | (None(), None()) -> continue
    | (None(), _) ->
      return direction match {
      | IDESC() -> GT()
      | _ -> LT()
      }
    | (_, None()) ->
      return direction match {
      | IDESC() -> LT()
      | _ -> GT()
      }
    | (Some(v1), Some(v2)) ->
      cmp = direction match {
      | INONE()
      | IASC() ->
        v1.compare(v2)
      | IDESC() -> v2.compare(v1)
      };
      if (cmp != EQ()) return cmp
    }
  };
  EQ()
}

/*****************************************************************************/
/* Fast order of a fixed capacity. */
/*****************************************************************************/

mutable class FastOrder{
  capacity: Int,
  kinds: Array<(Int, IKind)>,
  data: mutable Vector<RowValues> = mutable Vector[],
} {
  mutable fun push(row: RowValues): void {
    if (this.data.size() < this.capacity) {
      this.data.push(row);
      if (this.data.size() == this.capacity) {
        kinds = this.kinds;
        sortKinds = kinds.map(x ->
          (
            x.i0,
            x.i1 match {
            | INONE()
            | IASC() ->
              IDESC()
            | IDESC() -> IASC()
            },
          )
        );
        this.data.sortBy(x ~> x, (x, y) ~> compareRowsFast(sortKinds, x, y));
      }
    } else {
      this.insert(row)
    }
  }

  mutable private fun heapify(i: Int): void {
    if (i >= this.capacity) return void;
    current = this.data[i];
    if (2 * i >= this.capacity) return void;
    childIdx = 2 * i;
    child = this.data[childIdx];
    if (2 * i + 1 < this.capacity) {
      otherChild = this.data[2 * i + 1];
      compareRowsFast(this.kinds, child, otherChild) match {
      | EQ() -> void
      | LT() ->
        !childIdx = 2 * i + 1;
        !child = otherChild
      | GT() -> void
      }
    };
    compareRowsFast(this.kinds, current, child) match {
    | EQ() -> void
    | LT() ->
      this.data![childIdx] = current;
      this.data![i] = child;
      this.heapify(childIdx)
    | GT() -> void
    }
  }

  mutable private fun insert(row: RowValues): void {
    invariant(this.capacity > 0);
    this.data![0] = row;
    this.heapify(0)
  }
}
