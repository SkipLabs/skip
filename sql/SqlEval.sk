module SKSQL;

/*****************************************************************************/
/* Functions evaluating SQL. */
/*****************************************************************************/

fun checkUserRows(
  user: UserFile,
  pos: Int,
  table: DirDescr,
  rows: Array<RowValues>,
): void {
  table.cols.maybeGet("skdb_owner") match {
  | None() ->
    error(
      pos,
      "You cannot write into the table " +
        table.name +
        " because you are connected as user " +
        user.name +
        ".\n" +
        "You can only write into tables that define the column skdb_owner",
    )
  | Some(colNbr) ->
    for (row in rows) {
      row.getValue(colNbr) match {
      | None() ->
        error(
          pos,
          "The field skdb_owner can only be set to the userID " +
            "of the connected user (in this case " +
            user.id +
            ")",
        )
      | Some(CInt(n)) ->
        if (n != user.id) {
          error(
            pos,
            "skdb_owner is set to the wrong id for user " +
              user.name +
              " expected " +
              user.id +
              " (found " +
              n +
              ")",
          );
        }
      | Some _ -> error(pos, "skdb_owner should be of type INTEGER")
      };
    }
  }
}

fun computeTableDescr(
  name: String,
  schema: Array<TypeDescr>,
  windowSize: ?Int,
): DirDescr {
  dirNameStr = "/" + name + "/";
  dirName = SKFS.DirName::create(dirNameStr);
  colVec = mutable Vector[];
  for (i in Range(0, schema.size())) {
    colVec.push((schema[i].name, i));
  };
  DirDescr::create{
    name,
    schema,
    dirName,
    alias => None(),
    windowSize,
    isInput => true,
  }
}

fun computeInsert(
  context: mutable SKFS.Context,
  inTransaction: Bool,
  pos: Int,
  paramsOpt: ?Array<String>,
  valuesArray: Array<Array<Value>>,
  table: DirDescr,
): Array<RowValues> {
  valuesArray.map(vals -> {
    values = vals.mapWithIndex((idx, val) -> {
      valueToCValue(context, inTransaction, pos, table.schema, idx, val)
    });
    schema = table.schema;
    schemaSize = schema.size();
    valueSize = values.size();
    cvalues = paramsOpt match {
    | None() ->
      if (valueSize != schemaSize) {
        error(pos, "Value size mismatch with table schema");
      };
      values
    | Some(params) ->
      paramSize = params.size();
      if (
        values.size() == paramSize &&
        paramSize == schemaSize - 1 &&
        schema.any(ty -> ty.primary)
      ) {
        (primaryColName, primaryIndex) = for (i => ty in schema) {
          if (ty.primary) break (ty.name, i)
        } else {
          invariant_violation("Internal error")
        };
        newParams = mutable Vector[];
        newValues = mutable Vector[];
        for (i in Range(0, primaryIndex)) {
          newParams.push(params[i]);
          newValues.push(values[i]);
        };
        newParams.push(primaryColName);
        newValues.push(Some(CInt(SKFS.genSym(0))));
        for (i in Range(primaryIndex, params.size())) {
          newParams.push(params[i]);
          newValues.push(values[i]);
        };
        !params = newParams.toArray();
        !values = newValues.toArray();
        !paramSize = params.size();
        !valueSize = values.size();
      };
      if (paramSize != valueSize) {
        error(pos, "Value size mismatch");
      };
      if (paramSize != schemaSize) {
        error(pos, "Value size mismatch with table schema");
      };
      size = schemaSize;
      cols = table.cols;
      result = Array<?CValue>::mfill(params.size(), None());
      for (i in Range(0, size)) {
        colName = params[i];
        if (!cols.containsKey(colName)) {
          error(pos, "Column not found: " + colName);
        };
        result![cols[colName]] = values[i];
      };
      unsafe_chill_trust_me(result)
    };
    RowValues::create(cvalues)
  })
}

fun valueToCValue(
  context: mutable SKFS.Context,
  inTransaction: Bool,
  pos: Int,
  schema: Array<TypeDescr>,
  idx: Int,
  val: Value,
): ?CValue {
  if (idx >= schema.size()) {
    error(pos, "Too many columns defined");
  };
  if (val is VNull _) {
    if (schema[idx].notNull) {
      error(pos, "cannot insert NULL in column declared as NOT NULL")
    } else {
      return (None() : ?CValue)
    }
  };
  schema[idx].ty match {
  | INTEGER() ->
    val match {
    | VId(isPositive, Some(varName)) ->
      if (!inTransaction) {
        error(pos, "named id can only be used in a transaction");
      };
      globals = context.getGlobal(GLOBALS) match {
      | None() -> Globals()
      | Some(file) -> Globals::fromFile(file)
      };
      globals.maybeGet(varName) match {
      | None() ->
        id = SKFS.genSym(0);
        if (!isPositive) !id = -id;
        !globals = globals.set(varName, id);
        context.setGlobal(GLOBALS, globals);
        Some(CInt(id))
      | Some(id) -> Some(CInt(id))
      }
    | VId(isPositive, None()) ->
      if (isPositive) {
        Some(CInt(SKFS.genSym(0)))
      } else {
        Some(CInt(-SKFS.genSym(0)))
      }
    | VUid() ->
      context.getGlobal("USER") match {
      | None() ->
        error(pos, "Cannot use a the function uid() if not connected as a user")
      | Some(user) -> Some(CInt(UserFile::fromFile(user).id))
      }
    | VTime() ->
      if (inTransaction) {
        error(pos, "time can not be used in a transaction");
      };
      time = getUnixTime();
      Some(CInt(time))
    | VInt(n) ->
      if (schema[idx].primary) {
        _ = SKFS.genSym(n);
      };
      Some(CInt(n))
    | VLShift(n1, n2) -> Some(CInt(n1.shl(n2)))
    | v ->
      error(
        pos,
        "Type mismatch on column " +
          (idx + 1) +
          " expected type INTEGER (found " +
          inspect(v).toString() +
          ")",
      )
    }
  | FLOAT() ->
    val match {
    | VFloat(f) -> Some(CFloat(f))
    | VInt(i) -> Some(CFloat(i.toFloat()))
    | v ->
      error(
        pos,
        "Type mismatch on column " +
          (idx + 1) +
          " expected type FLOAT (found " +
          inspect(v).toString() +
          ")",
      )
    }
  | TEXT() ->
    val match {
    | VString(str) -> Some(CString(str))
    | v ->
      error(
        pos,
        "Type mismatch on column " +
          (idx + 1) +
          " expected type STRING (found " +
          inspect(v).toString() +
          ")",
      )
    }
  }
}

fun computeKinds(
  params: Array<CGExpr>,
  ekinds: Array<(Int, IKind)>,
): Array<(Int, IKind, Type)> {
  size = params.size();
  paramTypes = params.map(x -> x.getType());
  colSet = mutable Set[];
  ikinds = ekinds.map(eik -> {
    (colNumber, kind) = eik;
    !colNumber = colNumber - 1;
    if (colNumber < 0 || colNumber >= size) {
      errorEval("ORDER BY out of bounds");
    };
    if (colSet.contains(colNumber)) {
      errorEval("invalid ORDER by");
    };
    colSet.add(colNumber);
    (colNumber, kind)
  });
  computeOrder(paramTypes, ikinds)
}

fun computeOrder(
  paramTypes: Array<Type>,
  ikinds: Array<(Int, IKind)>,
): Array<(Int, IKind, Type)> {
  size = paramTypes.size();
  defaultKinds = Array<?(Int, SKSQL.IKind, SKSQL.Type)>::mfillBy(size, i ->
    Some((i, (INONE() : IKind), paramTypes[i]))
  );
  kinds = mutable Vector[];
  for (ik in ikinds) {
    (colNumber, kind) = ik;
    defaultKinds![colNumber] = None();
    kinds.push((colNumber, kind, paramTypes[colNumber]))
  };
  for (defaultKind in defaultKinds) {
    defaultKind match {
    | None() -> void
    | Some(k) -> kinds.push(k)
    }
  };
  kinds.toArray()
}

class SelectFile(
  tick: Int,
  virtual: Bool,
  text: String,
  value: Select,
) extends SKFS.File

class Evaluator{options: Options, user: ?UserFile} {
  fun write(
    context: mutable SKFS.Context,
    dirName: SKFS.DirName,
    key: SKFS.BaseName,
    value: SKFS.File,
  ): void {
    context.getEagerDir(dirName).write(context, key, value);
  }

  fun writeArray(
    context: mutable SKFS.Context,
    dirName: SKFS.DirName,
    key: SKFS.BaseName,
    values: Array<SKFS.File>,
  ): void {
    context.getEagerDir(dirName).writeArray(context, key, values);
  }

  fun stmt(
    context: mutable SKFS.Context,
    stmt: Stmt,
    inTransaction: Bool,
  ): ?((mutable SKFS.Context, mutable SKFS.Context, SKFS.Context) ~> void) {
    stmt match {
    | Table{pos, name, schema, windowSize} ->
      if (inTransaction) {
        error(pos, "Cannot create a table in a transaction");
      };
      Some((context, _, _) ~> {
        dirDescr = computeTableDescr(name, schema, windowSize);
        windowSize match {
        | Some(x) if (x < 0) ->
          print_error("Invalid WINDOW size");
          skipExit(23)
        | _ -> void
        };
        reallyRemove = windowSize match {
        | Some(0) -> false
        | Some(_) -> true
        | None() -> false
        };
        this.createTable(context, pos, name, dirDescr, reallyRemove);
      })
    | Insert{pos, name, paramsOpt, values} ->
      baseName = SKFS.SID::create(name);
      if (getTableDir(context).maybeGet(context, baseName) is None()) {
        error(pos, "Table not found: " + name);
      };
      values match {
      | IQuery(selectAst @ Select _) ->
        !selectAst.id = selectAst.id + "_" + SKFS.genSym(0);
        compiler = SKSQL.Compiler::create(this.options, selectAst.pos);
        select = compiler.compileSelect(context, selectAst, true);
        selectDir = evalSelect(context, select, None());
        updateTableMap(context);
        table = getTable(this.options, context, pos, baseName);
        dir = getDir(table);
        sinkName = "/sinks/sink" + SKFS.genSym(0) + "/";
        sinkDirName = SKFS.DirName::create(sinkName);
        kinds = table.schema.mapWithIndex((idx, x) -> (idx, IASC(), x.ty));
        if (select.params.size() != kinds.size()) {
          error(pos, "Incompatible select size")
        };
        for (i => param in select.params) {
          (kinds[i].i2, param.getType()) match {
          | (INTEGER(), INTEGER())
          | (FLOAT(), FLOAT())
          | (TEXT(), TEXT()) ->
            void
          | _ -> error(pos, "Incompatible select type")
          }
        };
        _ = SKFS.EagerDir::apply(
          context,
          selectDir.dirName,
          sinkDirName,
          (context, _writer, key, valueIter) ~> {
            entries = Vector[
              (
                key,
                (
                  SKFS.Path::create(selectDir.dirName, key),
                  valueIter.collect(Array),
                ),
              ),
            ];
            inputDir = context.unsafeGetEagerDir(dir.dirName);
            inputDir.writeArraySourceMany(context, entries.iterator());
          },
        );
        None()

      | IValues(vals) ->
        table = getTable(this.options, context, pos, baseName);
        this.insert(context, pos, inTransaction, table, paramsOpt, vals)
      }
    | selectAst @ Select{} ->
      compiler = SKSQL.Compiler::create(this.options, selectAst.pos);
      select = compiler.compileSelect(context, selectAst, true);
      selectDir = evalSelect(context, select, None());
      stdout = context.getGlobal("Stdout") match {
      | Some(StdoutFile(_, l)) -> l
      | Some(_) -> invariant_violation("Wrong type for global stdout")
      | None() -> List[]
      };
      !stdout = List.Cons(selectDir, stdout);
      format = this.options.format match {
      | OFK_CSV() -> SKFS.OCSV()
      | OFK_JSON() ->
        dirDescr = Compiler::getDirDescr(
          selectAst.params,
          select.from,
          select.params,
          selectDir.dirName.toString(),
          selectDir.dirName,
        );
        fieldNames = dirDescr.schema.map(x -> x.name);
        SKFS.OJSON(fieldNames)
      | OFK_SQL() -> SKFS.OSQL()
      };
      context.setGlobal("Stdout", StdoutFile(format, stdout));
      None()

    | index @ Index _ ->
      Some((context, _, _) ~> {
        this.makeIndex(context, index)
      })
    | View{
      pos,
      name => viewName,
      query => origSelectAst @ Select _,
      virtual,
      text,
    } ->
      if (inTransaction) {
        error(pos, "Cannot create a view in a transaction");
      };
      selectAst = origSelectAst with {id => viewName};
      views = getViewsDir(context);
      viewsDir = context.unsafeGetEagerDir(views.dirName);
      key = SKFS.SID(viewName);
      if (viewsDir.getArrayRaw(key).size() != 0) {
        error(pos, "VIEW " + viewName + " already exists");
      };
      viewsDir.write(
        context,
        key,
        SelectFile(context.tick.value, virtual, text, selectAst),
      );
      if (virtual) {
        if (inTransaction) {
          error(pos, "Cannot create a virtual view in a transaction");
        };
        startTick = context.tick;
        // This phase just populates the data.
        compiler1 = SKSQL.Compiler::create(
          this.options with {virtual => true},
          selectAst.pos,
        );
        cselect1 = compiler1.compileSelect(context, selectAst, true);
        _ = SKSQL.evalSelect(context, cselect1, None());
        Some((context, delta, _) ~> {
          sameDeps = unsafeCompareSets(context.deps.data, delta.deps.data);
          // If the deps haven't changed, that means we can reuse
          // the pre-computed data.
          if (sameDeps != 0) {
            changedDirNames = delta.dirs.state.getChangesAfter(startTick);
            for (changedDirName in changedDirNames) {
              if (!context.dirs.state.containsKey(changedDirName)) {
                context.setGlobal(
                  "PRE_COMPUTED_" + changedDirName,
                  delta.unsafeGetDir(changedDirName),
                );
              }
            }
          };
          compiler = SKSQL.Compiler::create(
            this.options with {virtual => true},
            selectAst.pos,
          );
          cselect = compiler.compileSelect(context, selectAst, true);
          dirName = SKFS.DirName::create("/" + selectAst.id + "/");
          dirDescr = SKSQL.Compiler::getDirDescr(
            selectAst.params,
            cselect.from,
            cselect.params,
            cselect.id,
            dirName,
          );
          _selectDir = SKSQL.evalSelect(context, cselect, None());
          tableDir = getTableDir(context);
          fileName = SKFS.SID::create(viewName);
          tableDir.writeArray(context, fileName, Array[dirDescr]);
        })
      } else {
        None()
      }
    | Drop{pos, kind => TView(), name => viewName} ->
      if (inTransaction) {
        error(pos, "Cannot drop a view in a transaction");
      };
      Some((context, _, _) ~> {
        views = getViewsDir(context);
        viewsDir = context.unsafeGetEagerDir(views.dirName);
        key = SKFS.SID(viewName);
        files = viewsDir.getArrayRaw(key);
        if (files.size() == 0) {
          error(pos, "VIEW " + viewName + " does not exist");
        };
        selectFile = SelectFile::fromFile(files[0]);
        if (selectFile.virtual) {
          error(pos, "Cannot drop a virtual view");
        } else {
          viewsDir.writeArray(context, key, Array[]);
        }
      })

    | Drop{pos, kind => TIndex(), name => _} ->
      error(pos, "Drop index not supported")
    | Drop{kind => TTable(), name} ->
      Some((context, _, _) ~> {
        dirNameStr = "/" + name + "/";
        dirName = SKFS.DirName::create(dirNameStr);
        context.removeDir(dirName);
        context.setDir(
          dirName,
          SKFS.DeletedDir{dirName, time => context.timeStamp()},
        )
      })
    | Delete{pos, colName => None(), name, where} ->
      _ = this.delete(context, pos, name, where, Array[]);
      None()
    | Delete{pos, colName => Some _} ->
      error(pos, "DELETE colName not supported")

    | Update{pos, name, sets, where} ->
      baseName = SKFS.SID::create(name);
      if (getTableDir(context).maybeGet(context, baseName) is None()) {
        error(pos, "Table not found: " + name);
      };
      deleteDir = this.delete(context, pos, name, where, sets);
      updateTableMap(context);
      table = getTable(this.options, context, pos, baseName);
      dir = getDir(table);
      sinkName = "/sinks/sink" + SKFS.genSym(0) + "/";
      sinkDirName = SKFS.DirName::create(sinkName);
      _ = SKFS.EagerDir::apply(
        context,
        deleteDir,
        sinkDirName,
        (context, _writer, key, valueIter) ~> {
          entries = Vector[
            (
              key,
              (SKFS.Path::create(deleteDir, key), valueIter.collect(Array)),
            ),
          ];
          inputDir = context.unsafeGetEagerDir(dir.dirName);
          inputDir.writeArraySourceMany(context, entries.iterator());
        },
      );
      None()
    };
  }

  fun makeIndex(context: mutable SKFS.Context, index: Index): void {
    input = getIndexInputDir(context);
    key = SKFS.SID::create(index.name);
    size = (context.unsafeGetEagerDir(input.dirName)).getArrayRaw(key).size();
    if (size != 0) {
      error(index.pos, "INDEX " + index.name + " already exists");
    };
    this.write(context, input.dirName, key, index);
    _ = getIndexOutputDir(this.options, context);
  }

  fun delete(
    context: mutable SKFS.Context,
    pos: Int,
    name: String,
    where: ?Expr,
    sets: Array<(String, Pos, Expr)>,
  ): SKFS.DirName {
    sinkName = "/sinks/sink" + SKFS.genSym(0) + "/";
    sinkDirName = SKFS.DirName::create(sinkName);
    from = Some(Array[TableName(FName(name), None(), false)]);
    selectAst = Select{
      id => "SELECT_" + SKFS.genSym(pos),
      pos => pos,
      params => None(),
      from,
      where,
      groupBy => None(),
      having => None(),
      join => None(),
      kind => SAll(),
      limit => None(),
      orderBy => None(),
      rest => None(),
    };
    compiler = SKSQL.Compiler::create(this.options, selectAst.pos);
    select = compiler.compileSelect(context, selectAst, true, sets);
    selectHandle = evalSelect(context, select, None());
    selectDir = context.unsafeGetEagerDir(selectHandle.dirName);
    updateTableMap(context);
    baseName = SKFS.SID::create(name);
    table = getTable(this.options, context, pos, baseName);
    inputDir = getDir(table);
    if (table.windowSize is Some _) {
      print_error("Error: cannot delete from a window");
      skipExit(23);
    };
    SKFS.EagerDir::apply(
      context,
      selectDir.dirName,
      sinkDirName,
      (context, writer, key, rowIter) ~> {
        entries = mutable Vector[];
        dir = context.unsafeGetEagerDir(inputDir.dirName);
        for ((source, _) in dir.getDataIter(context, key)) {
          entries.push((key, (source.value, Array<SKFS.File>[])));
        };
        dir.writeArraySourceMany(context, entries.iterator());
        if (select.sets.isEmpty()) return void;

        row = rowIter.next() match {
        | None() -> return void
        | Some(x @ RowValues _) -> x
        | Some(_) -> invariant_violation("Unexpected row type")
        };

        repeat = row.repeat;

        for (ir in rowIter) {
          ir match {
          | RowValues(_, r) -> !repeat = repeat + r
          | _ -> invariant_violation("Unexpected Row type")
          }
        };

        if (repeat != row.repeat) {
          !row = row.setRepeat(repeat);
        };

        evaluator = ExprEvaluator(None(), Array[row], Array[], None());

        values = Array::mcreateFromItems(row.values);

        for (set in select.sets) {
          (idx, e) = set;
          values![idx] = evaluator.evalCGExpr(context, e) match {
          | ADef(x) -> Some(x)
          | ANull() -> None()
          | AUndef _ -> invariant_violation("Undefined set value")
          };
        };
        !row = RowValues::create(values.chill(), row.repeat);
        kinds = key match {
        | RowKey(_, kinds) -> kinds
        | _ -> invariant_violation("Unexpected row kind")
        };

        writer.write(RowKey(row, kinds), row);
      },
    );
    sinkDir = context.unsafeGetEagerDir(sinkDirName);
    !sinkDir.time.value = Int::max - sinkDir.time.value;
    context.setDir(sinkDir.dirName, sinkDir);
    updateTableMap(context);
    sinkDirName
  }

  fun insert(
    context: mutable SKFS.Context,
    pos: Int,
    inTransaction: Bool,
    table: DirDescr,
    paramsOpt: ?Array<String>,
    values: Array<Array<Value>>,
  ): ?((mutable SKFS.Context, mutable SKFS.Context, SKFS.Context) ~> void) {
    rows = computeInsert(context, inTransaction, pos, paramsOpt, values, table);
    this.user match {
    | None() -> void
    | Some(user) -> checkUserRows(user, pos, table, rows)
    };
    table.windowSize match {
    | None() if (inTransaction) ->
      this.insertTable(context, table, rows);
      None()
    | None() ->
      Some((context, _, _) ~> {
        this.insertTable(context, table, rows);
        context.update();
      })

    | Some(ws) ->
      if (inTransaction) {
        print_error("Error: cannot insert into a window within a transaction");
        skipExit(23);
      };
      if (ws == 0) {
        this.insertStream(context, rows, table);
        Some((_, _, _) ~> {
          void
        })
      } else {
        Some((context, _, _) ~> {
          this.insertWindow(context, ws, rows, table);
        })
      }
    }
  }

  fun insertTable(
    context: mutable SKFS.Context,
    table: DirDescr,
    rows: Array<RowValues>,
  ): void {
    dir = getDir(table);
    newDir = context.unsafeGetEagerDir(dir.dirName);
    kinds = table.schema.mapWithIndex((idx, x) -> (idx, IASC(), x.ty));
    for (row in rows) {
      key = RowKey(row, kinds);
      source = SKFS.Path(dir.dirName, SKFS.IID(SKFS.genSym(0)));
      !newDir = newDir.writeEntry(context, source, key, Array[row]);
    };
    context.setDir(newDir.dirName, newDir);
  }

  fun insertStream(
    context: mutable SKFS.Context,
    rows: Array<RowValues>,
    table: DirDescr,
  ): void {
    dir = getDir(table);
    newDir = context.unsafeGetEagerDir(dir.dirName);
    key = SKFS.IID(SKFS.genSym(0));
    source = SKFS.Path(dir.dirName, key);
    for (row in rows) {
      start = context.tick;
      vcontext = context.mclone();
      !newDir = newDir.writeEntry(vcontext, source, key, Array[row]);
      vcontext.setDir(newDir.dirName, newDir);
      vcontext.update();
      vcontext.notifyAll(start);
    }
  }

  fun insertWindow(
    context: mutable SKFS.Context,
    ws: Int,
    rows: Array<RowValues>,
    table: DirDescr,
  ): void {
    dir = getDir(table);
    newDir = context.unsafeGetEagerDir(dir.dirName);

    kinds = table.schema.mapWithIndex((idx, tyDescr) ->
      (idx, IASC(), tyDescr.ty)
    );

    rowsIter = rows.iterator();
    row1 = rowsIter.next();
    row2 = rowsIter.next();
    i = 0;

    loop {
      row = row1 match {
      | None() -> break void
      | Some(x) -> x
      };
      key = RowKey(row, kinds);
      source = SKFS.Path(dir.dirName, key);
      !newDir = newDir.writeEntry(context, source, key, Array[row]);
      time = row.getInt(0).fromSome();

      for (kv in newDir.unsafeGetFileIter()) {
        (minKey, minFile) = kv;
        minValues = minFile.map(x -> RowValues::fromFile(x)).collect(Array);
        if (minValues.size() == 0) continue;
        minValue = minValues[0];
        if (minValue.getInt(0).fromSome() + ws > time) {
          break void;
        };
        minSource = SKFS.Path(dir.dirName, minKey);
        !newDir = newDir.writeEntry(context, minSource, minKey, Array[]);
        void
      };

      !row1 = row2;

      if (row1 is None()) {
        context.setDir(dir.dirName, newDir);
        context.update();
      };

      !i = i + 1;
      !row2 = rowsIter.next();
    }
  }

  fun createTable(
    context: mutable SKFS.Context,
    pos: Int,
    name: String,
    dirDescr: DirDescr,
    reallyRemove: Bool,
    init: Array<RowValues> = Array[],
  ): void {
    dirName = dirDescr.dirName;
    kinds = dirDescr.schema.mapWithIndex((idx, x) -> (idx, IASC(), x.ty));
    tag = SKFS.TickRange::create(context.tick);
    dir = context.mkdirCompressed(
      RowValues::fromFile,
      dirName,
      init,
      row ~> {
        file: SKFS.File = row;
        key = RowKey(row, kinds);
        path = SKFS.Path::create(dirName, key);
        SKFS.FixedRow(key, (SKFS.Source::create(path), Array[file]), tag)
      },
      reallyRemove,
    );

    getTableDir(context).writeArray(
      context,
      SKFS.SID::create(name),
      Array[dirDescr],
    );

    hasPrimary = false;
    dirDescr.windowSize match {
    | Some(0) -> void
    | Some(_) ->
      if (!(dirDescr.schema[0].ty is INTEGER())) {
        error(pos, "WINDOW expects a first column of type INTEGER")
      }
    | _ -> void
    };

    for (tyDescr in dirDescr.schema) {
      if (tyDescr.primary) {
        if (hasPrimary) {
          error(pos, "multiple primary keys detected");
        };
        if (!(tyDescr.ty is INTEGER())) {
          error(pos, "primary keys are expected to be integers");
        };
        !hasPrimary = true;
      };
      if (tyDescr.unique || tyDescr.primary) {
        this.makeIndex(
          context,
          Index{
            pos => pos,
            name => name + "_" + tyDescr.name,
            fields => (name, Array[(tyDescr.name, IASC())]),
            unique => true,
          },
        );
      }
    };
    if (context.debugMode) {
      print_string("CREATED: " + name);
    };

    if (name == "skdb_groups") {
      this.createGroupsReaders(context, pos, dir);
    };
  }

  fun createGroupsReaders(
    context: mutable SKFS.Context,
    pos: Int,
    usersDir: SKFS.EHandle<RowValues>,
  ): void {
    groupsReadersName = "skdb_groups_readers";
    groupsReadersDirName = SKFS.DirName::create("/" + groupsReadersName + "/");
    dirDescr = DirDescr::create{
      name => groupsReadersName,
      schema => Array[
        TypeDescr{
          name => "groupid",
          ty => INTEGER(),
          primary => false,
          unique => false,
          notNull => true,
        },
        TypeDescr{
          name => "readerid",
          ty => INTEGER(),
          primary => false,
          unique => false,
          notNull => true,
        },
      ],
      dirName => groupsReadersDirName,
      alias => None(),
      windowSize => None(),
      isInput => false,
    };
    kinds = dirDescr.schema.mapWithIndex((idx, ty) -> (idx, IASC(), ty.ty));
    _ = usersDir.contextWriterKeyValues(
      RowValues::fromFile,
      context,
      groupsReadersDirName,
      (context, writer, _key, values) ~> {
        invariant(values.size() == 1);
        groupName = values[0].getString(1).fromSome().lowercase();
        if (groupName.startsWith("blacklist")) {
          if (values[0].getInt(0).fromSome() >= 0) {
            error(pos, "blacklists are expected to have negative identifiers");
          }
        } else if (groupName.startsWith("whitelist")) {
          if (values[0].getInt(0).fromSome() < 0) {
            error(pos, "whitelistss are expected to have positive identifiers");
          }
        } else {
          error(
            pos,
            "Group names should start with 'whitelist' or 'blacklist'",
          );
        };
        groupDirName = SKFS.DirName::create("/" + groupName + "/");
        groupDirNameProj = SKFS.DirName::create("/" + groupName + "/proj/");
        dir = SKFS.EHandle(RowValues::fromFile, groupDirName);
        projDir = dir.contextWriterKeyValues(
          RowValues::fromFile,
          context,
          groupDirNameProj,
          (_context, writer, _key, values) ~> {
            writer.writeArray(SKFS.IID(0), values)
          },
        );
        for (row in projDir.getArray(context, SKFS.IID(0))) {
          newRow = RowValues::create(
            Array[values[0].getValue(0), row.getValue(0)],
          );
          writer.write(RowKey(newRow, kinds), newRow);
        }
      },
    );
    tableDir = getTableDir(context);
    fileName = SKFS.SID::create(groupsReadersName);
    tableDir.writeArray(context, fileName, Array[dirDescr]);
  }
}

@cpp_extern("SKIP_String_concatN")
native fun concatArray(Array<String>): String;

@cpp_extern("SKIP_isatty")
native fun isATTY(): UInt32;

@cpp_extern("SKIP_unsafe_compare_sets")
native fun unsafeCompareSets(
  SortedMap<SKFS.Path, SortedSet<SKFS.ArrowKey>>,
  SortedMap<SKFS.Path, SortedSet<SKFS.ArrowKey>>,
): Int32;

fun read(line: Int): (Int, String) {
  lineStart = line;
  i = 0;
  chars = mutable Vector[];
  hasData = false;
  vtry(
    () ->
      loop {
        c = getChar();
        isWhiteSpace = c == ' ' || c == '\n' || c == '\t' || c == '\r';
        !hasData = !isWhiteSpace;

        !i = i + 1;

        if (c == '\'') {
          chars.push(c);
          loop {
            c2 = getChar();
            chars.push(c2);
            if (c2 == '\'') break void;
          };
          continue;
        };

        if (c == '-') {
          c2 = getChar();
          !i = i + 1;
          if (c2 == '-') {
            while (getChar() != '\n') {
              !i = i + 1;
            };
            continue
          } else {
            chars.push(c);
            chars.push(c2);
          }
        } else if (c == '/') {
          c2 = getChar();
          !i = i + 1;
          if (c2 == '*') {
            last = getChar();
            !i = i + 1;
            loop {
              c3 = getChar();
              !i = i + 1;
              if (last == '*' && c3 == '/') break void;
              !last = c3;
            };
            continue
          } else {
            chars.push(c);
            chars.push(c2);
          }
        } else {
          chars.push(c);
        };

        if (c == '\n') !line = line + 1;
        if (c == ';') return (line, String::fromChars(chars.toArray()));
      },
    _endOfFile -> {
      if (hasData) {
        print_error("Error, line " + lineStart + ": unfinished statement");
        skipExit(23);
      };
      (line, "")
    },
  )
}

fun getLine(buffer: Buffer, pos: Int): Int {
  line = 1;
  for (i in Range(0, pos)) {
    if (buffer[i] == '\n') {
      !line = line + 1;
    }
  };
  line
}

fun printErrorAndExit(
  lineOffset: Int,
  buffer: Buffer,
  pos: Int,
  msg: String,
): void {
  leftSpaces = 0;
  cursor = 0;
  line = 0;
  !pos = min(buffer.size() - 1, pos);
  while (pos - cursor > 0) {
    if (buffer[pos - cursor] == '\n') {
      !line = line + 1;
      if (line == 1) {
        !leftSpaces = cursor;
      };
      if (line == 5) break void;
    };
    !cursor = cursor + 1
  };
  if (pos - leftSpaces < 0) {
    !leftSpaces = pos;
  };
  right = 0;
  while (pos + right < buffer.size() && buffer[pos + right] != '\n') {
    !right = right + 1
  };
  txtBegin = max(0, pos - cursor);
  txtEnd = min(buffer.size(), pos + right);
  print_error(buffer.slice(txtBegin, txtEnd));
  spaceBuffer = mutable Vector[];
  for (_ in Range(0, leftSpaces - 1)) spaceBuffer.push(' ');
  margin = String::fromChars(spaceBuffer.toArray());
  print_error(margin + "^");
  print_error(margin + "|");
  print_error(margin + " ----- ERROR");
  errLine = lineOffset + getLine(buffer, pos);
  charPos = `characters ${leftSpaces}-${leftSpaces}`;
  print_error(`Error: line ${errLine}, ${charPos}:`);
  print_error(msg);
  skipExit(2)
}

fun printRow(format: SKFS.OutputFormat, row: SKSQL.Row): void {
  row match {
  | rvalues @ RowValues(_, r) ->
    for (_ in Range(0, r)) {
      print_string(rvalues.toStringSingle(format))
    }
  | RowKind _ -> invariant_violation("Cannot print a RowKind")
  }
}

fun evalWithContext(
  options: Options,
  context: mutable SKFS.Context,
  stmt: Stmt,
  inTransaction: Bool,
): ?((mutable SKFS.Context, mutable SKFS.Context, SKFS.Context) ~> void) {
  user = context.getGlobal("USER").map(UserFile::fromFile);
  evaluator = Evaluator{options, user};
  evaluator.stmt(context, stmt, inTransaction);
}

value class Version(value: Int) uses Orderable

class TableMap{
  startTick: SKFS.Tick,
  version: Version,
  map: SortedMap<SKFS.BaseName, (Version, DirDescr)>,
} extends SKFS.File

fun extractSql(chars: Buffer): void {
  lex = Lexer(0, chars);
  pos = 0;
  while (!isEOF(lex, pos)) {
    (!pos, test) = parseTest(lex, pos);
    test match {
    | TestStmt{posBegin, posEnd}
    | TestQuery{posBegin, posEnd} ->
      print_string(chars.slice(posBegin, posEnd));
      print_string(";\n")
    | _ -> void
    }
  };
}

fun makeSqlContext(): mutable SKFS.Context {
  gcontext = mutable SKFS.Context{
    unsafeReuse => true,
    failOnExn => true,
    removeSubDirs => false,
  };
  gcontext.setGlobal("Line", SKFS.IntFile(0));
  gcontext
}

fun doOnError(options: Options, f: () -> void, error: Exception -> void): void {
  if (options.backtrace) f() else vtry(f, error)
}

class StmtFile(stmt: Stmt) extends SKFS.File
class TickFile(tick: SKFS.Tick) extends SKFS.File

base class OutputFormatKind {
  children =
  | OFK_CSV()
  | OFK_JSON()
  | OFK_SQL()
}

class Options{
  alwaysAllowJoins: Bool,
  backtrace: Bool,
  sync: Bool,
  virtual: Bool = false,
  showUsedIndexes: Bool,
  format: OutputFormatKind = OFK_SQL(),
} extends SKFS.File

fun evalQuery(context: mutable SKFS.Context, query: String): Array<RowValues> {
  lexer = SKSQL.Lexer(0, SKSQL.Buffer(query));
  selectAst = SKSQL.parseQuery(lexer, 0).i1 match {
  | x @ Select _ -> x
  };
  skOptions = SKSQL.Options{
    alwaysAllowJoins => false,
    backtrace => false,
    sync => false,
    virtual => false,
    showUsedIndexes => false,
  };
  compiler = SKSQL.Compiler::create(skOptions, 0);
  cselect = compiler.compileSelect(context, selectAst, true);
  selectDir = SKSQL.evalSelect(context, cselect, None());
  dirName = selectDir.dirName;
  dir = context.unsafeGetEagerDir(dirName);
  result = mutable Vector[];
  dir.onFiles(files -> {
    for (kv in files) {
      (_key, rows) = kv;
      for (row in rows) {
        result.push(RowValues::fromFile(row))
      }
    }
  });
  result.toArray()
}

base class GroupKind {
  children =
  | WhiteList()
  | BlackList()
}

class UserFile(id: Int, name: String) extends SKFS.File {
  const fields: Array<(Int, IASC, Type)> = Array[
    (0, IASC(), INTEGER()),
    (1, IASC(), INTEGER()),
  ];
  const dirName: SKFS.DirName = SKFS.DirName::create("/skdb_groups_readers/");

  fun contains(context: readonly SKFS.Context, groupID: Int): Bool {
    readers = context.unsafeGetEagerDir(static::dirName);
    size = readers
      .getArrayRaw(
        RowKey(
          RowValues::create(Array[Some(CInt(groupID)), Some(CInt(this.id))]),
          static::fields,
        ),
      )
      .size();
    if (groupID > 0) size != 0 else size == 0
  }
}

fun makeUserFile(context: mutable SKFS.Context, userName: String): UserFile {
  if (userName.contains("'")) {
    print_error("Invalid user name");
    skipExit(2);
  };
  userRows = evalQuery(
    context,
    "select userID from skdb_users where userName = '" + userName + "';",
  );
  if (userRows.size() == 0) {
    print_error("Could not find user: " + userName);
    skipExit(2)
  };
  userID = userRows[0].getInt(0).fromSome();
  UserFile(userID, userName);
}

fun connectUser(context: mutable SKFS.Context, userName: String): UserFile {
  context.getGlobal("USER") match {
  | None() ->
    userFile = makeUserFile(context, userName);
    context.setGlobal("USER", userFile);
    userFile
  | Some(x) -> UserFile::fromFile(x)
  }
}

fun eval(options: Options, userOpt: ?String): void {
  runSql(options, context ~> {
    if (isATTY() != 0) {
      print_raw("skdb> ");
    };
    lineFile = SKFS.IntFile::fromFile(context.getGlobal("Line").fromSome());
    context.!globals = SortedMap[];
    userOpt.each(user -> _ = connectUser(context, user));
    context.setGlobal("Line", lineFile);
    context.removeGlobal("TableMap");

    gline = lineFile.value;

    line = 0;
    lineStr = "";
    buffer = Buffer(lineStr);
    lex = Lexer(0, buffer);
    pos = 0;
    shouldContinue = false;
    underLockF: ?((
      mutable SKFS.Context,
      mutable SKFS.Context,
      SKFS.Context,
    ) ~> void) = None();

    doOnError(
      options,
      () -> {
        !shouldContinue = true;
        isTransaction = false;

        loop {
          !underLockF = None();
          (!line, !lineStr) = read(gline);
          !buffer = Buffer(lineStr);
          !lex = Lexer(0, buffer);
          !pos = 0;

          if (isEOF(lex, pos)) {
            !shouldContinue = false;
            if (isTransaction) {
              printErrorAndExit(line, buffer, pos, "Unfinished transaction");
            };
            return void;
          };

          if (lex.isEqUpper(pos, "BEGIN")) {
            !pos = lex.expectUpper(pos, "BEGIN");
            !pos = lex.expectUpper(pos, "TRANSACTION");
            !pos = lex.expect(pos, ";");

            if (isTransaction) {
              printErrorAndExit(line, buffer, pos, "Nested transaction");
            };
            !isTransaction = true;
            continue;
          };

          if (lex.isEqUpper(pos, "COMMIT")) {
            !pos = lex.expectUpper(pos, "COMMIT");
            !pos = lex.expect(pos, ";");
            context.getGlobal("GLOBALS") match {
            | None() -> void
            | Some(_) -> context.removeGlobal(GLOBALS)
            };
            break void;
          };

          (!pos, stmtOpt) = parseStmt(lex, pos);
          stmt = stmtOpt match {
          | None() -> break void
          | Some(x) -> x
          };
          markIfRead(context, stmt);

          lastStmtOpt = context.getGlobal("LastStmtOpt").map(file ->
            StmtFile::fromFile(file).stmt
          );

          (lastStmtOpt, stmt) match {
          | (Some(Select _), Drop _)
          | (Some(Select _), Delete _)
          | (Some(Select _), Insert _)
          | (Some(View _), Drop _)
          | (Some(View _), Delete _)
          | (Some(View _), Insert _) ->
            updateTableMap(context)

          | _ -> void
          };

          !underLockF = evalWithContext(options, context, stmt, isTransaction);

          context.setGlobal("LastStmt", StmtFile(stmt));

          if (!isTransaction) break void;
        };
      },
      err -> {
        err match {
        | Error(posError, str) ->
          printErrorAndExit(gline, buffer, posError, str)
        | exn ->
          print_error(exn.getMessage());
          skipExit(44)
        }
      },
    );

    !gline = line;
    context.setGlobal("Line", SKFS.IntFile(gline));

    if (shouldContinue) {
      SKFS.CContinue(underLockF)
    } else {
      SKFS.CStop(underLockF)
    }
  })
}

fun runSql(options: Options, f: mutable SKFS.Context ~> SKFS.ContextOp): void {
  doOnError(
    options,
    () ->
      SKFS.runWithGc(
        SKSQL.makeSqlContext().clone(),
        f,
        Some(SKFS.Synchronizer(importFromRoot, exportToRoot, printContext)),
        options.sync,
      ),
    err -> {
      print_error(err.getMessage());
      skipExit(45);
    },
  )
}

fun runLockedSql(options: Options, f: mutable SKFS.Context ~> void): void {
  doOnError(
    options,
    () -> {
      SKFS.runLocked(SKSQL.makeSqlContext().clone(), f, options.sync)
    },
    err -> {
      print_error(err.getMessage());
      skipExit(45);
    },
  )
}

fun importFromRoot(
  delta: mutable SKFS.Context,
  tick: SKFS.Tick,
  root: readonly SKFS.Context,
): void {
  vtry(
    () -> {
      shouldImport = delta.getGlobal("TableMap") match {
      | None() ->
        delta.getGlobal("IsRead") match {
        | None() -> false
        | Some(_) -> true
        }
      | Some(_tableMapFile) -> true
      };
      if (shouldImport) {
        SKFS.import(delta, tick, root);
        delta.update();
      }
    },
    (err -> {
      line = delta.getGlobal("Line") match {
      | None() -> -1
      | Some(x) -> SKFS.IntFile::fromFile(x).value
      };
      print_error("Error, line " + line + ": " + err.getMessage());
      skipExit(2);
    }),
  )
}

fun makeInputDirName(dirName: SKFS.DirName): (SKFS.DirName, Int) {
  dirNameStr = dirName.toString();
  if (dirNameStr.startsWith("/next/")) {
    !dirNameStr = dirNameStr.stripPrefix("/next/");
    iter = dirNameStr.getIter();
    i = 0;
    for (c in iter) {
      if (c == '/') break void;
      !i = i + 1;
    };
    nbr = mutable Vector[];
    for (c in iter) {
      if (c == '/') break void;
      nbr.push(c);
    };
    !dirNameStr = "/" + dirNameStr.sub(dirNameStr.getIter(), i) + "/";
    (SKFS.DirName::create(dirNameStr), String::fromChars(nbr.toArray()).toInt())
  } else {
    (dirName, 0)
  }
}

fun importNext(
  targetCtx: mutable SKFS.Context,
  tick: SKFS.Tick,
  sourceCtx: readonly SKFS.Context,
): Bool {
  changedDirNames = sourceCtx.dirs.state.getChangesAfter(tick);
  updates = mutable Map[];
  hasMultipleVersions = false;
  for (dirName in changedDirNames) {
    sourceCtx.unsafeMaybeGetDir(dirName) match {
    | Some(SKFS.DeletedDir{}) -> targetCtx.removeDir(dirName)
    | Some(dir @ SKFS.EagerDir{input => true}) ->
      (targetDirName, version) = makeInputDirName(dirName);
      !hasMultipleVersions = hasMultipleVersions || version != 0;
      updates.maybeGet(targetDirName) match {
      | Some((_, iversion, _)) if (iversion > version) -> void
      | _ ->
        changedKeys = dir.getChangesAfter(tick);
        targetCtx.unsafeMaybeGetDir(targetDirName) match {
        | None() ->
          time = targetCtx.timeStamp();
          targetDir = SKFS.EagerDir{
            time,
            input => true,
            dirName => targetDirName,
            fixedData => SKFS.FixedDir::create(mutable Vector[]),
            totalSize => 0,
            creator => None(),
            reallyRemove => false,
          };
          targetCtx.setDir(targetDir.dirName, targetDir)
        | Some(_) -> void
        };
        entries = mutable Vector[];
        for (key in changedKeys) {
          for (srcValue in dir.unsafeGetDataIter(key)) {
            (source, values) = srcValue;
            entries.push((key, (source.value, values)));
          }
        };
        updates![targetDirName] = (dir, version, entries)
      }
    | _ -> void
    }
  };
  for (targetDirName => src in updates) {
    (_dir, _, entries) = src;
    targetCtx.unsafeMaybeGetEagerDir(targetDirName) match {
    | None() -> invariant_violation("Directory should have been created")
    | Some(inputDir) ->
      inputDir.writeArraySourceMany(targetCtx, entries.iterator())
    }
  };
  hasMultipleVersions
}

fun exportToRoot(
  root: mutable SKFS.Context,
  tick: SKFS.Tick,
  delta: readonly SKFS.Context,
): Bool {
  rootCopy = root.clone();
  vtry(
    () -> {
      hasVersioning = importNext(root, tick, delta);
      root.update();
      hasVersioning
    },
    (err -> {
      line = delta.getGlobal("Line") match {
      | None() -> -1
      | Some(x) -> SKFS.IntFile::fromFile(x).value
      };
      root.replaceFromSaved(rootCopy);
      print_error("Error, line " + line + ": " + err.getMessage());
      skipExit(2);
    }),
  )
}

fun updateTableMap(context: mutable SKFS.Context): void {
  tableMap = context.getGlobal("TableMap") match {
  | None() ->
    TableMap{
      version => Version(SKFS.genSym(0)),
      startTick => context.tick,
      map => SortedMap[],
    }
  | Some(file) -> TableMap::fromFile(file)
  };
  !tableMap.version.value = SKFS.genSym(tableMap.version.value);
  context.setGlobal("TableMap", tableMap)
}

class StdoutFile(
  format: SKFS.OutputFormat,
  value: List<SelectDir>,
) extends SKFS.File
class StdoutDiff(
  format: SKFS.OutputFormat,
  dirName: SKFS.DirName,
  time: SKFS.Tick,
) extends SKFS.File

fun showSelect(
  context: mutable SKFS.Context,
  format: SKFS.OutputFormat,
  sdir: SelectDir,
): void {
  dirName = sdir.dirName;
  dir = context.unsafeGetEagerDir(dirName);
  dir.onFiles(files ~> {
    for (kv in files) {
      (_key, rows) = kv;
      rowArray = rows.collect(Array);
      for (row in rowArray) {
        printRow(format, RowValues::fromFile(row));
      }
    }
  })
}

fun printContext(context: mutable SKFS.Context): void {
  context.globals.maybeGet("Stdout") match {
  | None() -> void
  | Some(StdoutFile(format, stdout)) ->
    for (selectDir in stdout.toArray().reversed()) {
      showSelect(context, format, selectDir)
    }
  | Some(StdoutDiff(format, dirName, time)) ->
    edir = context.unsafeGetEagerDir(dirName);
    print_string("Time: " + (context.tick.value + 1));
    for (key in edir.getChangesAfter(time)) {
      values = edir.getArrayRaw(key);
      for (value in values) {
        print_raw(value.toKVString(format, key))
      };
    }
  | Some _ -> invariant_violation("Unexpected Stdout type")
  };
  flushStdout();
}

fun markIfRead(context: mutable SKFS.Context, stmt: Stmt): void {
  stmt match {
  | Insert{values => IQuery _}
  | Update _
  | Select _ ->
    context.setGlobal("IsRead", SKFS.BoolFile(true))
  | Table _
  | View _
  | Drop _
  | Delete _
  | Index _
  | Insert _ ->
    void
  }
}
