/*****************************************************************************/
/* Compiles Sql queries from SqlAst to SqlCAst (for "compiled" Ast). */
/*****************************************************************************/

module SKSQL;

/*****************************************************************************/
/* Determines smallest window. */
/*****************************************************************************/

fun minWindowSize(x: ?Int, y: ?Int): ?Int {
  (x, y) match {
  | (Some(n1), Some(n2)) -> Some(min(n1, n2))
  | (r @ Some _, _)
  | (_, r @ Some _) ->
    r
  | (None(), None()) -> None()
  }
}

/*****************************************************************************/
/* Helper functions/types for merge joins. */
/*****************************************************************************/

class JTable{
  name: String,
  dirName: SKFS.DirName,
  ranges: ?Array<SKFS.KeyRange>,
  schema: Array<SKSQL.TypeDescr>,
  alias: ?String,
  windowSize: ?Int,
} {
  static fun fromDirDescr(
    dirDescr: DirDescr,
    ranges: ?Array<SKFS.KeyRange>,
  ): this {
    JTable{
      name => dirDescr.name,
      dirName => dirDescr.dirName,
      ranges,
      schema => dirDescr.schema,
      alias => dirDescr.alias,
      windowSize => dirDescr.windowSize,
    }
  }
}

value class TableProj(tableNbr: Int, col: (Int, IKind, Type), isUnique: Bool)
value class EqJoin(left: TableProj, right: TableProj)

fun isUnique(tyDescr: TypeDescr): Bool {
  tyDescr.primary || tyDescr.unique
}

const crossJoinMsg: String = `
This will be interpreted as a cross-join, which is almost
certainly not what you want.
If you are absolutely sure that's what you want to do, you can pass
the option '--always-allow-joins' to make this error go away.`;

const multipleTablesNoUniqueMsg: String = `
SELECT involves multiple tables but none of them defines a unique column.
`;

const multipleTablesNoClauseMsg: String = `
SELECT involves multiple tables but no appropriate join clause was found.
`;

fun errorNoMergeClause(pos: Int): void {
  errorNbr(
    1,
    pos,
    multipleTablesNoClauseMsg +
      "Was expecting to find a clause of the form:\n" +
      "... AND colName1 = colName2 AND ...\n" +
      "\n" +
      crossJoinMsg,
  )
}

/*****************************************************************************/
/* Finds table */
/*****************************************************************************/

mutable class Compiler{
  options: Options,
  pos: Int,
  mutable subst: mutable Map<String, CGExpr> = mutable Map[],
  mutable paramsNbr: mutable Map<String, Int> = mutable Map[],
  mutable ambiguous: mutable Set<String> = mutable Set[],
  mutable isAggr: Bool = false,
  mutable aggrVars: mutable Vector<(AggrKind, CGExpr)> = mutable Vector[],
  mutable needUp: Bool = false,
  mutable needGetParam: Bool = false,
  mutable other: mutable Vector<SubSelectTask> = mutable Vector[],
} {
  static fun create(options: Options, pos: Int): mutable this {
    mutable static{options, pos}
  }

  mutable fun expandGroupBy(select: Select): Select {
    // Tranforms:
    // 'select ... from ... group by ...'
    // ==> 'select * from (select ... from ... group by ...)'

    Select{
      pos => select.pos,
      id => select.id,
      kind => select.kind,
      params => None(),
      from => Some(
        Array[
          TableName(
            FQuery(
              select with {
                id => select.id + "-groupBy",
                kind => SNone(),
                orderBy => None(),
                limit => None(),
                rest => None(),
                shouldExpand => false,
              },
            ),
            None(),
            false,
          ),
        ],
      ),
      where => None(),
      groupBy => None(),
      having => None(),
      join => None(),
      orderBy => select.orderBy,
      limit => select.limit,
      shouldExpand => false,
      rest => select.rest.map(x -> (x.i0, x.i1 with {shouldExpand => true})),
    }
  }

  mutable fun compileSelect(
    context: mutable SKFS.Context,
    select: Select,
    toplevel: Bool,
    sets: Array<(String, Pos, Expr)> = Array[],
  ): CSelect {
    if (
      select.kind is SDistinct _ ||
      select.shouldExpand ||
      toplevel &&
        (select.orderBy is Some _ || select.limit is Some _) &&
        (select.groupBy is Some _) ||
      (select.rest is Some _ || toplevel) &&
        selectOrRestIsAggrOrEmptyFrom(select)
    ) {
      !select = this.expandGroupBy(select);
    };

    !select = this.expandJoins(context, select.join, select);

    substCopy = this.subst;
    paramsNbrCopy = this.paramsNbr;
    ambiguousCopy = this.ambiguous;
    aggrVarsCopy = this.aggrVars;
    needUpCopy = this.needUp;
    isAggrCopy = this.isAggr;
    otherCopy = this.other;

    isAggr = selectIsAggr(select);
    this.!isAggr = isAggr;

    newSubst = mutable Map[];
    for (key => value in this.subst) {
      if (key.contains(".")) {
        newSubst![key] = value.up();
      }
    };

    newAmbiguous = mutable Set[];
    for (key in this.ambiguous) {
      if (key.contains(".")) {
        newAmbiguous.add(key);
      }
    };

    this.!subst = newSubst;
    this.!paramsNbr = mutable Map[];
    this.!ambiguous = newAmbiguous;
    this.!aggrVars = mutable Vector[];
    this.!needUp = false;
    this.!other = mutable Vector[];

    origFrom = this.compileFrom(context, select.from);
    (cond, from) = this.compileJoin(context, origFrom, select);
    !select.where = cond;
    sparams = select.params match {
    | None() ->
      params = mutable Vector[];
      for (dirDescr in origFrom) {
        tableName = dirDescr.alias match {
        | None() -> dirDescr.name
        | Some(x) -> x
        };
        for (varName in dirDescr.colNames) {
          params.push((Literal(tableName + "." + varName, false), None()))
        }
      };
      params.toArray()
    | Some(params) -> params
    };
    params = this.compileParams(context, sparams);
    where = this.compileWhere(context, select.where);
    groupBy = this.compileGroupBy(context, select.groupBy, params);
    having = this.compileHaving(context, select.having);

    orderBy = this.compileOrderBy(select.params, from, select.orderBy);
    limit = this.compileLimit(context, select.limit);
    rest = this.compileRest(context, params, select.rest);
    aggr: ?Array<(AggrKind, CGExpr)> = None();
    if (this.aggrVars.size() != 0) {
      !aggr = Some(this.aggrVars.toArray());
    };

    kinds = orderBy match {
    | None() ->
      i = 0;
      params.map(param -> {
        result = (i, IASC(), param.getType());
        !i = i + 1;
        result
      })
    | Some(ekinds) -> computeKinds(params, ekinds)
    };

    for (dirDescrAndRange in from) {
      (dirDescr, _) = dirDescrAndRange;
      if (dirDescr.windowSize == Some(0) && isAggr) {
        error(
          this.pos,
          "Cannot use a stream for aggregates, use a window instead",
        );
      };
      if (dirDescr.windowSize == Some(0) && from.size() > 1) {
        error(this.pos, "Cannot use multiple streams at the same time");
      }
    };

    cselect = CSelect{
      id => select.id +
        context.getGlobal("TableMap") match {
        | None() -> ""
        | Some(file) -> "_V" + TableMap::fromFile(file).version.value.toString()
        },
      kind => select.kind,
      params,
      sets => this.compileSets(context, sets),
      aggr,
      from,
      kinds,
      where,
      groupBy,
      having,
      orderBy,
      limit,
      rest,
      needUp => this.needUp,
      needGetParam => this.needGetParam,
      other => this.other.toArray(),
    };

    this.!subst = substCopy;
    this.!paramsNbr = paramsNbrCopy;
    this.!ambiguous = ambiguousCopy;
    this.!aggrVars = aggrVarsCopy;
    this.!needUp = needUpCopy;
    this.!isAggr = isAggrCopy;
    this.!other = otherCopy;

    cselect
  }

  mutable fun compileSets(
    context: mutable SKFS.Context,
    params: Array<(String, Pos, Expr)>,
  ): Array<(Int, CGExpr)> {
    this.noAggr(() -> {
      params.map(set -> {
        (colName, pos, e) = set;
        this.compileExpr(context, Literal(colName, false)) match {
        | (CIExpr(CIGetFrom(0, n))) ->
          this.compileExpr(context, e) match {
          | CGNull() -> (n, CGNull())
          | v @ CIExpr(_) -> (n, v)
          | _ -> errorNbr(2, pos.value, "Incompatible types for set")
          }
        | (CFExpr(CFGetFrom(0, n))) ->
          this.compileExpr(context, e) match {
          | CGNull() -> (n, CGNull())
          | v @ CFExpr(_) -> (n, v)
          | _ -> errorNbr(2, pos.value, "Incompatible types for set")
          }
        | (CSExpr(CSGetFrom(0, n))) ->
          this.compileExpr(context, e) match {
          | CGNull() -> (n, CGNull())
          | v @ CSExpr(_) -> (n, v)
          | _ -> errorNbr(2, pos.value, "Incompatible types for set")
          }
        | _ -> errorNbr(3, pos.value, "Invalid set")
        };
      })
    })
  }

  mutable fun compileParams(
    context: mutable SKFS.Context,
    params: Array<(Expr, ?String)>,
  ): Array<CGExpr> {
    cparams = params.map(param -> {
      (expr, asName) = param;
      (this.compileExpr(context, expr), asName)
    });
    for (i => cparam in cparams) {
      (typedExpr, asNameOpt) = cparam;
      asNameOpt match {
      | Some(asName) if (!this.subst.containsKey(asName)) ->
        this.!needGetParam = true;
        this.paramsNbr![asName] = i;
        this.subst![asName] = typedExpr match {
        | CGNull _ -> CGNull()
        | CIExpr _ -> CIExpr(CIGetParam(i))
        | CSExpr _ -> CSExpr(CSGetParam(i))
        | CFExpr _ -> CFExpr(CFGetParam(i))
        }
      | _ -> continue
      };
    };
    cparams.map(x -> x.i0)
  }

  mutable fun compileFrom(
    context: mutable SKFS.Context,
    from: ?Array<TableName>,
  ): Array<SKSQL.DirDescr> {
    from match {
    | None() -> Array[]
    | Some(fromTables) ->
      tableNbr = 0;

      tables = fromTables.map(fromTable -> {
        table = this.getFromDirDescr(context, fromTable.name);
        tableAlias = fromTable.asName match {
        | Some(x) -> x
        | None() -> table.name
        };
        !table.alias = Some(tableAlias);
        table
      });

      for (i => fromName in fromTables) {
        table = tables[i];
        tableName = table.name;

        for (colName => colNbr in table.cols) {
          this.addGetFrom(tableNbr, table.schema, colName, colNbr);
        };
        fromName.asName match {
        | None() ->
          for (colName => colNbr in table.cols) {
            dotName = tableName + "." + colName;
            this.addGetFrom(tableNbr, table.schema, dotName, colNbr)
          }
        | Some(asName) ->
          for (colName => colNbr in table.cols) {
            dotName = asName + "." + colName;
            this.addGetFrom(tableNbr, table.schema, dotName, colNbr)
          }
        };

        !tableNbr = tableNbr + 1;
      };

      !tableNbr = 0;

      for (i => fromName in fromTables) {
        table = tables[i];
        tableName = table.name;

        fromName.asName match {
        | None() -> void
        | Some(_) ->
          for (colName => colNbr in table.cols) {
            dotName = tableName + "." + colName;
            if (!this.subst.containsKey(dotName)) {
              this.addGetFrom(tableNbr, table.schema, dotName, colNbr)
            }
          }
        };

        !tableNbr = tableNbr + 1;
      };

      tables
    }
  }

  mutable fun addGetFrom(
    tableNbr: Int,
    schema: Array<TypeDescr>,
    colName: String,
    colNbr: Int,
  ): void {
    if (this.subst.containsKey(colName)) {
      this.ambiguous.insert(colName);
    } else {
      this.subst![colName] = schema[colNbr].ty match {
      | FLOAT() -> CFExpr(CFGetFrom(tableNbr, colNbr))
      | INTEGER() -> CIExpr(CIGetFrom(tableNbr, colNbr))
      | TEXT() -> CSExpr(CSGetFrom(tableNbr, colNbr))
      }
    }
  }

  mutable fun getFromDirDescr(
    context: mutable SKFS.Context,
    name: FromName,
  ): DirDescr {
    name match {
    | FName(tableName) ->
      tableSID = SKFS.SID::create(tableName);
      getTable(this.options, context, this.pos, tableSID)

    | FQuery(select @ Select _) ->
      cselect = this.compileSelect(context, select, false);
      selectDir = evalSelect(context, cselect, None());
      static::getDirDescr(
        select.params,
        cselect.from,
        cselect.params,
        selectDir.dirName.toString(),
        selectDir.dirName,
      )
    }
  }

  static fun getCols(
    paramsOpt: ?Array<(Expr, ?String)>,
    from: Array<(DirDescr, ?Array<SKFS.KeyRange>)>,
  ): (SortedMap<String, Int>, readonly Map<Int, String>) {
    cols = SortedMap[];
    invCols = mutable Map[];
    paramsOpt match {
    | None() ->
      slot = 0;
      for (dirDescr in from) {
        for (tyName in dirDescr.i0.colNames) {
          if (!cols.containsKey(tyName)) {
            !cols[tyName] = slot;
            invCols![slot] = tyName;
          };
          !slot = slot + 1;
        }
      }

    | Some(params) ->
      for (idx => param in params) {
        param match {
        | (_, Some(colName)) ->
          if (cols.containsKey(colName)) continue;
          !cols[colName] = idx;
          invCols![idx] = colName
        | (Literal(colName, _), _) ->
          if (cols.containsKey(colName)) continue;
          iter = colName.getIter();
          first = iter.next().fromSome();
          if (!Chars.isDigit(first)) {
            !cols[colName] = idx;
            invCols![idx] = colName;
          }
        | (Binop(".", _, Literal(colName, _)), _) ->
          if (cols.containsKey(colName)) continue;
          !cols[colName] = idx;
          invCols![idx] = colName
        | _ -> void
        }
      }
    };
    (cols, invCols)
  }

  static fun getDirDescr(
    paramsOpt: ?Array<(Expr, ?String)>,
    from: Array<(DirDescr, ?Array<SKFS.KeyRange>)>,
    cparams: Array<CGExpr>,
    selectId: String,
    dirName: SKFS.DirName,
  ): DirDescr {
    (cols, invCols) = static::getCols(paramsOpt, from);
    schema = cparams.mapWithIndex((idx, param) -> {
      ty = TypeDescr{
        name => invCols.maybeGet(idx) match {
        | None() ->
          col = "col<" + idx + ">";
          !cols[col] = idx;
          col
        | Some(x) -> x
        },
        ty => param.getType(),
        unique => false,
        primary => false,
        notNull => false,
      };
      ty
    });
    windowSize: ?Int = None();
    for (kv in from) {
      (kv.i0.windowSize, windowSize) match {
      | (Some(v), Some(ws)) if (v < ws) -> !windowSize = Some(v)
      | _ -> void
      }
    };
    DirDescr{
      name => selectId,
      colNames => schema.map(ty -> ty.name),
      schema,
      cols,
      dirName,
      alias => Some(selectId),
      windowSize,
      isInput => false,
    }
  }

  mutable fun expandJoins(
    _context: mutable SKFS.Context,
    joinOpt: ?Join,
    select: Select,
  ): Select {
    joinOpt match {
    | None() -> select
    | Some(join) ->
      join.kind match {
      | JCross() ->
        !select.from = select.from match {
        | None() -> Some(join.names)
        | Some(names) -> Some(names.concat(join.names))
        };
        !select.join = None();
        select
      | _ ->
        !select.from = select.from match {
        | None() -> Some(join.names)
        | Some(names) -> Some(names.concat(join.names))
        };
        !select.join = None();
        join.on match {
        | None() -> errorNbr(4, this.pos, "Expected ON after JOIN")
        | Some((onClause, clauses)) ->
          clauseIter = clauses.iterator();

          for (clause in clauseIter) {
            !onClause = Binop("AND", onClause, clause);
          };
          !select.where = select.where match {
          | None() -> Some(On(join.kind, onClause))
          | Some(where) -> Some(Binop("AND", On(join.kind, onClause), where))
          };
          select
        }
      }
    }
  }

  mutable fun compileWhere(
    context: mutable SKFS.Context,
    whereOpt: ?Expr,
  ): ?CExpr<Int> {
    this.noAggr(() -> {
      whereOpt match {
      | None() -> None()
      | Some(expr) ->
        this.compileExpr(context, expr) match {
        | CGNull() -> Some(CNull())
        | CIExpr(x) -> Some(x)
        | CFExpr _ -> errorNbr(5, this.pos, "A where clause cannot be a FLOAT")
        | CSExpr _ -> errorNbr(5, this.pos, "A where clause cannot be a STRING")
        }
      }
    })
  }

  mutable fun compileGroupBy(
    context: mutable SKFS.Context,
    groupByOpt: ?Array<(Expr, ?String)>,
    params: Array<CGExpr>,
  ): ?Array<CGroupByElt> {
    groupByOpt match {
    | None() -> None()
    | Some(groupBy) ->
      Some(
        groupBy.map(kv -> {
          (group, _) = kv;
          this.compileExpr(context, group) match {
          | CIExpr(CILiteral(nIndexedAt1)) ->
            n = nIndexedAt1 - 1;
            if (n < 0 || n >= params.size()) {
              errorNbr(6, this.pos, "GROUP BY out of bounds");
            };
            e = params[n];
            CGBExpr(e, e.getType())
          | e -> CGBExpr(e, e.getType())
          }
        }),
      )
    }
  }

  mutable fun compileHaving(
    context: mutable SKFS.Context,
    havingOpt: ?Expr,
  ): ?CExpr<Int> {
    havingOpt.map(e ->
      this.compileExpr(context, e) match {
      | CGNull() -> CILiteral(0)
      | CIExpr(x) -> x
      | _ -> errorNbr(7, this.pos, "Invalid type for HAVING clause")
      }
    )
  }

  mutable fun compileRest(
    context: mutable SKFS.Context,
    cparams: Array<CGExpr>,
    rest: ?(QueryKind, Select),
  ): ?(QueryKind, CSelect) {
    crest = rest.map(x -> (x.i0, this.compileSelect(context, x.i1, false)));
    crest match {
    | None() -> void
    | Some((_, query)) ->
      qparams = query.params;
      if (cparams.size() != qparams.size()) {
        errorNbr(8, this.pos, "Incompatible select width for union");
      };
      for (i in Range(0, qparams.size())) {
        if (qparams[i].getType() != cparams[i].getType()) {
          errorNbr(9, this.pos, "Incompatible types for union");
        }
      }
    };
    crest
  }

  mutable fun compileOrderBy(
    params: ?Array<(SKSQL.Expr, ?String)>,
    from: Array<(SKSQL.DirDescr, ?Array<SKFS.KeyRange>)>,
    orderByOpt: ?Array<(Expr, IKind)>,
  ): ?Array<(Int, IKind)> {
    orderByOpt match {
    | None() -> None()
    | Some(orderBy) ->
      (cols, _) = static::getCols(params, from);
      Some(
        orderBy.map(kv -> {
          (order, kind) = kv;
          order match {
          | Literal(n, false) ->
            first = n.getIter().next().fromSome();
            if (Chars.isDigit(first)) {
              for (c in n) {
                if (Chars.isDigit(c)) continue;
                errorNbr(11, this.pos, "invalid ORDER BY")
              };
              (n.toInt(), kind)
            } else {
              if (cols.containsKey(n)) {
                (cols[n] + 1, kind)
              } else {
                errorNbr(10, this.pos, "invalid ORDER BY, unbound name " + n)
              }
            }

          | _ -> errorNbr(11, this.pos, "invalid ORDER BY")
          }
        }),
      )
    }
  }

  mutable fun compileLimit(
    context: mutable SKFS.Context,
    limit: ?Expr,
  ): ?CExpr<Int> {
    limit match {
    | None() -> None()
    | Some(e) ->
      if (this.options.virtual) {
        errorNbr(12, this.pos, "Cannot use LIMIT in a virtual view")
      };
      this.compileExpr(context, e) match {
      | CIExpr(i) -> Some(i)
      | _ -> errorNbr(13, this.pos, "Invalid limit")
      }
    }
  }

  mutable fun compileExpr(context: mutable SKFS.Context, expr: Expr): CGExpr {
    expr match {
    | Literal("null", _) -> CGNull()
    | Literal(str, isString) ->
      if (isString) return CSExpr(CSLiteral(str));
      str.getIter().next() match {
      | None() -> invariant_violation("Empty literal")
      | Some(c) if (Chars.isDigit(c) || c == '.') ->
        if (
          str.contains(".") ||
          str.contains("e") ||
          str.contains("E") ||
          str.contains("p") ||
          str.contains("P")
        ) {
          CFExpr(CFLiteral(str.toFloat()))
        } else {
          CIExpr(CILiteral(str.toInt()))
        }
      | _ ->
        if (this.ambiguous.contains(str)) {
          error(this.pos, "Ambiguous name: " + str);
        };
        this.subst.maybeGet(str) match {
        | None() -> error(this.pos, "Unbound name: " + str)
        | Some(e) ->
          e match {
          | CIExpr(CUp _)
          | CFExpr(CUp _)
          | CSExpr(CUp _) ->
            this.!needUp = true
          | _ -> void
          };
          if (this.isAggr) {
            slot = this.aggrVars.size();
            this.aggrVars.push((Noop(), e));
            e.getType() match {
            | INTEGER() -> CIExpr(CIGetFrom(0, slot))
            | FLOAT() -> CFExpr(CFGetFrom(0, slot))
            | TEXT() -> CSExpr(CSGetFrom(0, slot))
            }
          } else {
            e
          }
        }
      }
    | Binop(".", Literal(ge1, _), Literal(ge2, _)) ->
      this.compileExpr(context, Literal(ge1 + "." + ge2, false))

    | Binop("IS", e, Literal("null", _)) ->
      CIExpr(
        this.compileExpr(context, e) match {
        | CGNull() -> CILiteral(1)
        | CIExpr(i) -> CIIsNull(i)
        | CFExpr(f) -> CFIsNull(f)
        | CSExpr(s) -> CSIsNull(s)
        },
      )

    | Binop("IS", e, Not(Literal("null", _))) ->
      CIExpr(
        CNot(
          this.compileExpr(context, e) match {
          | CGNull() -> CILiteral(1)
          | CIExpr(i) -> CIIsNull(i)
          | CFExpr(f) -> CFIsNull(f)
          | CSExpr(s) -> CSIsNull(s)
          },
        ),
      )

    | Binop("BETWEEN", e1, Binop("AND", e2, e3)) ->
      (
        this.compileExpr(context, e1),
        this.compileExpr(context, e2),
        this.compileExpr(context, e3),
      ) match {
      | (CGNull(), _, _) -> CGNull()
      | (_, CGNull(), CGNull()) -> CGNull()

      | (CIExpr(i1), CIExpr(i2), CIExpr(i3)) -> CIExpr(CIBetween(i1, i2, i3))
      | (CIExpr(i1), CGNull(), CIExpr(i3)) -> CIExpr(CIBetween(i1, CNull(), i3))
      | (CIExpr(i1), CIExpr(i2), CGNull()) -> CIExpr(CIBetween(i1, i2, CNull()))

      | (CFExpr(f1), CFExpr(f2), CFExpr(f3)) -> CIExpr(CFBetween(f1, f2, f3))
      | (CFExpr(f1), CGNull(), CFExpr(f3)) -> CIExpr(CFBetween(f1, CNull(), f3))
      | (CFExpr(f1), CFExpr(f2), CGNull()) -> CIExpr(CFBetween(f1, f2, CNull()))

      | (CSExpr(s1), CSExpr(s2), CSExpr(s3)) -> CIExpr(CSBetween(s1, s2, s3))
      | (CSExpr(s1), CGNull(), CSExpr(s3)) -> CIExpr(CSBetween(s1, CNull(), s3))
      | (CSExpr(s1), CSExpr(s2), CGNull()) -> CIExpr(CSBetween(s1, s2, CNull()))

      | _ -> error(this.pos, "Type error: BETWEEN")
      }

    | Binop("BETWEEN", _, _) -> invariant_violation("Invalid between")

    | Binop("NOT BETWEEN", e1, Binop("AND", e2, e3)) ->
      (
        this.compileExpr(context, e1),
        this.compileExpr(context, e2),
        this.compileExpr(context, e3),
      ) match {
      | (CGNull(), _, _) -> CGNull()
      | (_, CGNull(), CGNull()) -> CGNull()

      | (CIExpr(i1), CIExpr(i2), CIExpr(i3)) -> CIExpr(CINotBetween(i1, i2, i3))
      | (CIExpr(i1), CGNull(), CIExpr(i3)) ->
        CIExpr(CINotBetween(i1, CNull(), i3))
      | (CIExpr(i1), CIExpr(i2), CGNull()) ->
        CIExpr(CINotBetween(i1, i2, CNull()))

      | (CFExpr(f1), CFExpr(f2), CFExpr(f3)) -> CIExpr(CFNotBetween(f1, f2, f3))
      | (CFExpr(f1), CGNull(), CFExpr(f3)) ->
        CIExpr(CFNotBetween(f1, CNull(), f3))
      | (CFExpr(f1), CFExpr(f2), CGNull()) ->
        CIExpr(CFNotBetween(f1, f2, CNull()))

      | (CSExpr(s1), CSExpr(s2), CSExpr(s3)) -> CIExpr(CSNotBetween(s1, s2, s3))
      | (CSExpr(s1), CGNull(), CSExpr(s3)) ->
        CIExpr(CSNotBetween(s1, CNull(), s3))
      | (CSExpr(s1), CSExpr(s2), CGNull()) ->
        CIExpr(CSNotBetween(s1, s2, CNull()))

      | _ -> error(this.pos, "Type error: NOT BETWEEN")
      }

    | Binop("NOT BETWEEN", _, _) -> invariant_violation("Invalid between")

    | Binop("NOT LIKE", ge1, ge2) ->
      this.compileExpr(context, Not(Binop("LIKE", ge1, ge2)))

    | Binop("LIKE", ge1, ge2) ->
      pattern = ge2 match {
      | Literal(str, true) -> str
      | _ -> error(this.pos, "Invalid LIKE, expected a pattern")
      };

      this.compileExpr(context, ge1) match {
      | CSExpr(e1) -> CIExpr(CSLike(e1, parsePattern(pattern.chars())))
      | _ -> error(this.pos, "Invalid LIKE, expected a string")
      }

    | Binop(bop, ge1, ge2) ->
      cge1 = this.compileExpr(context, ge1);
      cge2 = this.compileExpr(context, ge2);
      this.compileBinop(cge1, cge2, bop)

    | Not(e) ->
      this.compileExpr(context, e) match {
      | CGNull() -> CGNull()
      | CIExpr(b) -> CIExpr(CNot(b))
      | _ ->
        debug(e);
        error(this.pos, "Invalid type for NOT")
      }
    | Case(None(), whenCases, Some(last)) ->
      result = this.compileExpr(context, last);
      for (whenCase in whenCases.reversed()) {
        (cond, action) = whenCase;
        !result = this.makeIf(
          this.compileExpr(context, cond),
          this.compileExpr(context, action),
          result,
        );
      };
      result
    | Case(Some(value), whenCases, Some(last)) ->
      result = this.compileExpr(context, last);
      for (whenCase in whenCases.reversed()) {
        (matchValue, action) = whenCase;
        !result = this.makeIf(
          this.compileExpr(context, Binop("=", value, matchValue)),
          this.compileExpr(context, action),
          result,
        );
      };
      result
    | EQuery(select @ Select _) ->
      cselect = this.compileSelect(context, select, false);
      if (cselect.params.size() != 1) {
        error(this.pos, "Invalid type for inner SELECT");
      };
      cselect.params[0].getType() match {
      | INTEGER() -> CIExpr(CIQuery(cselect))
      | FLOAT() -> CFExpr(CFQuery(cselect))
      | TEXT() -> CSExpr(CSQuery(cselect))
      }
    | Exists(select @ Select _) ->
      CIExpr(CExists(this.compileSelect(context, select, false)))
    | SKSQL.Call("coalesce", None()) ->
      error(this.pos, "Missing arguments for COALESCE")
    | Call("id", None()) -> error(this.pos, "id expects one argument")
    | Call("id", Some(args)) ->
      if (args.size() != 1) {
        error(this.pos, "id expects one argument")
      };
      args[0] match {
      | Literal(varName, true) ->
        globals = context.getGlobal(GLOBALS) match {
        | None() -> error(this.pos, "Unknown id " + varName)
        | Some(file) -> Globals::fromFile(file)
        };
        if (!globals.containsKey(varName)) {
          error(this.pos, "Unknown id " + varName)
        };
        CIExpr(CILiteral(globals[varName]))
      | _ -> error(this.pos, "id expects a string literal")
      }
    | Call("upper", None()) -> error(this.pos, "upper expects one argument")
    | Call("lower", None()) -> error(this.pos, "lower expects one argument")
    | Call("upper", Some(values)) ->
      if (values.size() != 1) {
        error(this.pos, "upper expects one argument")
      };
      this.compileExpr(context, values[0]) match {
      | CGNull _ -> CGNull()
      | CSExpr(e) -> CSExpr(CSUpper(e))
      | _ -> error(this.pos, "upper expects a string")
      }
    | Call("lower", Some(values)) ->
      if (values.size() != 1) {
        error(this.pos, "lower expects one argument")
      };
      this.compileExpr(context, values[0]) match {
      | CGNull _ -> CGNull()
      | CSExpr(e) -> CSExpr(CSLower(e))
      | _ -> error(this.pos, "lower expects a string")
      }
    | Call("coalesce", Some(values)) ->
      tvalues = values.map(x -> this.compileExpr(context, x));
      ty = for (val in tvalues) {
        val match {
        | CGNull _ -> continue
        | CIExpr _ -> break Some(INTEGER())
        | CFExpr _ -> break Some(FLOAT())
        | CSExpr _ -> break Some(TEXT())
        }
      } else {
        None()
      };
      ty match {
      | None() -> CGNull()
      | Some(INTEGER()) ->
        CIExpr(
          CCoalesce(
            tvalues.map(tvalue ->
              tvalue match {
              | CGNull() -> CNull()
              | CIExpr(e) -> e
              | _ -> error(this.pos, "Inconsistent types in coalesce")
              }
            ),
          ),
        )
      | Some(FLOAT()) ->
        CFExpr(
          CCoalesce(
            tvalues.map(tvalue ->
              tvalue match {
              | CGNull() -> CNull()
              | CFExpr(e) -> e
              | _ -> error(this.pos, "Inconsistent types in coalesce")
              }
            ),
          ),
        )
      | Some(TEXT()) ->
        CSExpr(
          CCoalesce(
            tvalues.map(tvalue ->
              tvalue match {
              | CGNull() -> CNull()
              | CSExpr(e) -> e
              | _ -> error(this.pos, "Inconsistent types in coalesce")
              }
            ),
          ),
        )
      }

    | SKSQL.Call("sum", Some(values)) ->
      this.noAggr(() -> {
        if (values.size() != 1) {
          error(this.pos, "Invalid number of arguments for sum")
        };
        (skind, value) = values[0] match {
        | Distinct(e) -> (SDistinct(), e)
        | All(e) -> (SAll(), e)
        | e -> (SNone(), e)
        };
        this.compileExpr(context, value) match {
        | e @ CIExpr(_) ->
          slot = this.aggrVars.size();
          this.aggrVars.push((Sum(skind), e));
          CIExpr(CIGetFrom(0, slot))
        | e @ CFExpr(_) ->
          slot = this.aggrVars.size();
          this.aggrVars.push((Sum(skind), e));
          CFExpr(CFGetFrom(0, slot))
        | CSExpr _ -> error(this.pos, "Cannot call sum on a string")
        | CGNull _ -> CGNull()
        }
      })

    | SKSQL.Call("min", Some(values)) ->
      this.noAggr(() -> {
        if (values.size() != 1) {
          error(this.pos, "Invalid number of arguments for min")
        };
        value = values[0];
        this.compileExpr(context, value) match {
        | e @ CIExpr(_) ->
          slot = this.aggrVars.size();
          this.aggrVars.push((Min(), e));
          CIExpr(CIGetFrom(0, slot))
        | e @ CFExpr(_) ->
          slot = this.aggrVars.size();
          this.aggrVars.push((Min(), e));
          CFExpr(CFGetFrom(0, slot))
        | e @ CSExpr(_) ->
          slot = this.aggrVars.size();
          this.aggrVars.push((Min(), e));
          CSExpr(CSGetFrom(0, slot))
        | CGNull _ -> CGNull()
        }
      })

    | SKSQL.Call("max", Some(values)) ->
      this.noAggr(() -> {
        if (values.size() != 1) {
          error(this.pos, "Invalid number of arguments for max")
        };
        value = values[0];
        this.compileExpr(context, value) match {
        | e @ CIExpr(_) ->
          slot = this.aggrVars.size();
          this.aggrVars.push((Max(), e));
          CIExpr(CIGetFrom(0, slot))
        | e @ CFExpr(_) ->
          slot = this.aggrVars.size();
          this.aggrVars.push((Max(), e));
          CFExpr(CFGetFrom(0, slot))
        | e @ CSExpr(_) ->
          slot = this.aggrVars.size();
          this.aggrVars.push((Max(), e));
          CSExpr(CSGetFrom(0, slot))
        | CGNull _ -> CGNull()
        }
      })

    | SKSQL.Call("count", arg) ->
      this.noAggr(() -> {
        value = arg match {
        | None() -> Literal("1", false)
        | Some(values) ->
          if (values.size() != 1) {
            error(this.pos, "Invalid number of arguments for sum")
          };
          values[0]
        };
        (skind, !value) = value match {
        | Distinct(e) -> (SDistinct(), e)
        | All(e) -> (SAll(), e)
        | e -> (SNone(), e)
        };
        this.compileExpr(context, value) match {
        | e @ CIExpr(_) ->
          slot = this.aggrVars.size();
          this.aggrVars.push((Count(skind), e));
          CIExpr(CIGetFrom(0, slot))
        | e @ CFExpr(_) ->
          slot = this.aggrVars.size();
          this.aggrVars.push((Count(skind), e));
          CFExpr(CFGetFrom(0, slot))
        | CSExpr _ -> error(this.pos, "Cannot call count on a string")
        | CGNull _ -> CGNull()
        }
      })

    | SKSQL.Call("avg", Some(values)) ->
      this.noAggr(() -> {
        if (values.size() != 1) {
          error(this.pos, "Invalid number of arguments for avg")
        };
        (skind, value) = values[0] match {
        | Distinct(e) -> (SDistinct(), e)
        | All(e) -> (SAll(), e)
        | e -> (SNone(), e)
        };
        this.compileExpr(context, value) match {
        | e @ CIExpr(_) ->
          sumSlot = this.aggrVars.size();
          this.aggrVars.push((Sum(skind), e));
          countSlot = this.aggrVars.size();
          this.aggrVars.push((Count(skind), e));
          CFExpr(
            CDiv(
              CFICast(CIGetFrom(0, sumSlot)),
              CFICast(CIGetFrom(0, countSlot)),
            ),
          )
        | e @ CFExpr(_) ->
          sumSlot = this.aggrVars.size();
          this.aggrVars.push((Sum(skind), e));
          countSlot = this.aggrVars.size();
          this.aggrVars.push((Count(skind), e));
          CFExpr(CDiv(CFGetFrom(0, sumSlot), CFICast(CIGetFrom(0, countSlot))))
        | CSExpr _ -> error(this.pos, "Cannot call avg on a string")
        | CGNull _ -> CGNull()
        }
      })

    | SKSQL.Call("abs", Some(values)) ->
      if (values.size() != 1) {
        error(this.pos, "Invalid number of arguments for abs")
      };
      this.compileExpr(context, values[0]) match {
      | CIExpr(n) -> CIExpr(CIAbs(n))
      | CFExpr(f) -> CFExpr(CFAbs(f))
      | _ ->
        error(
          this.pos,
          "Invalid arguments for abs, expected an integer or a float",
        )
      }

    | In(e, arr) ->
      this.compileExpr(context, e) match {
      | CGNull() -> CGNull()
      | CIExpr(i) ->
        set = arr.map(x ->
          this.compileExpr(context, x) match {
          | CIExpr(n) -> n
          | _ -> error(this.pos, "Incompatible types: IN")
          }
        );
        CIExpr(CIIn(i, set))

      | CFExpr(f) ->
        set = arr.map(x ->
          this.compileExpr(context, x) match {
          | CFExpr(n) -> n
          | _ -> error(this.pos, "Incompatible types: IN")
          }
        );
        CIExpr(CFIn(f, set))

      | CSExpr(s) ->
        set = arr.map(x ->
          this.compileExpr(context, x) match {
          | CSExpr(n) -> n
          | _ -> error(this.pos, "Incompatible types: IN")
          }
        );
        CIExpr(CSIn(s, set))
      }

    | UMinus(e) ->
      val = this.compileExpr(context, e);
      val match {
      | CGNull() -> CGNull()
      | CIExpr(i) -> CIExpr(CSub(CILiteral(0), i))
      | CFExpr(f) -> CFExpr(CSub(CFLiteral(0.0), f))
      | CSExpr _ -> error(this.pos, "cannot apply - on a string")
      }

    | UPlus(e) ->
      val = this.compileExpr(context, e);
      val match {
      | CSExpr _ -> error(this.pos, "cannot apply + on a string")
      | x -> x
      }

    | Call("date", Some(args)) ->
      if (args.size() < 1) {
        error(this.pos, "Missing arguments");
      };
      this.compileExpr(
        context,
        Call("strftime", Some(Array[Literal("%Y-%m-%d", true)].concat(args))),
      )

    | Call("time", Some(args)) ->
      if (args.size() < 1) {
        error(this.pos, "Missing arguments");
      };
      this.compileExpr(
        context,
        Call("strftime", Some(Array[Literal("%H:%M:%S", true)].concat(args))),
      )

    | Call("datetime", Some(args)) ->
      if (args.size() < 1) {
        error(this.pos, "Missing arguments");
      };
      this.compileExpr(
        context,
        Call(
          "strftime",
          Some(Array[Literal("%Y-%m-%d %H:%M:%S", true)].concat(args)),
        ),
      )

    | Call("julianday", _) -> error(this.pos, "julianday not supported")

    | Call("strftime", Some(args)) ->
      if (args.size() < 2) {
        error(this.pos, "Missing arguments strftime");
      };

      isStatic = for (arg in args) {
        arg match {
        | Literal(_, true) -> void
        | _ -> break false
        }
      } else {
        true
      };

      if (isStatic) {
        sargs = args.map(x ->
          x match {
          | Literal(v, true) -> v
          | _ -> error(this.pos, "only static dates are supported")
          }
        );

        CSExpr(CSLiteral(callStrftime(this.pos, context, sargs)))
      } else {
        sargs = args.map(arg ->
          this.compileExpr(context, arg) match {
          | CSExpr(x) -> x
          | _ -> error(this.pos, "Expected a string")
          }
        );
        CSExpr(CStrftime(sargs[0], sargs[1], sargs.slice(2, sargs.size())))
      }

    | SKSQL.Call("nullif", Some(args)) ->
      if (args.size() != 2) {
        error(this.pos, "NULLIF expects 2 arguments");
      };
      (
        this.compileExpr(context, args[0]),
        this.compileExpr(context, args[1]),
      ) match {
      | (CGNull(), CGNull()) -> CGNull()
      | (CIExpr(e1), CIExpr(e2)) -> CIExpr(CNullIf(e1, e2))
      | (CFExpr(e1), CFExpr(e2)) -> CFExpr(CNullIf(e1, e2))
      | (CSExpr(e1), CSExpr(e2)) -> CSExpr(CNullIf(e1, e2))
      | (x, _) -> x
      }

    | SKSQL.Case(condOpt, cases, defaultOpt) ->
      acc = defaultOpt match {
      | None() -> CGNull()
      | Some(d) -> this.compileExpr(context, d)
      };
      for (case in cases.reversed()) {
        (pat, action) = case;
        cond = condOpt match {
        | None() -> this.compileExpr(context, pat)
        | Some(v) -> this.compileExpr(context, Binop("=", v, pat))
        };
        !acc = this.makeIf(cond, this.compileExpr(context, action), acc);
      };
      acc

    | Cast(e1, ty) ->
      (this.compileExpr(context, e1), ty) match {
      | (CGNull(), _) -> CGNull()
      | (CIExpr(i), FLOAT()) -> CFExpr(CFICast(i))
      | (CFExpr(f), INTEGER()) -> CIExpr(CIFCast(f))
      | (CSExpr(s), INTEGER()) -> CIExpr(CISCast(s))
      | (CIExpr(i), TEXT()) -> CSExpr(CSICast(i))
      | (CFExpr(f), TEXT()) -> CSExpr(CSFCast(f))
      | (CSExpr(s), FLOAT()) -> CFExpr(CFSCast(s))
      | (ci @ CIExpr _, INTEGER()) -> ci
      | (cf @ CFExpr _, FLOAT()) -> cf
      | (cs @ CSExpr _, TEXT()) -> cs
      }

    | On(k, e) ->
      this.compileExpr(context, e) match {
      | CGNull _ -> CIExpr(CNull())
      | CIExpr(ie) -> CIExpr(COn(k, ie))
      | _ -> error(this.pos, "Unexpected type for ON")
      }

    | All _ -> error(this.pos, "Unexpected ALL")
    | Distinct _ -> error(this.pos, "Unexpected Distinct")
    | Between _ -> error(this.pos, "Unexpected BETWEEN")
    | Call(fname, _) -> error(this.pos, "Unknown function: " + fname)
    }
  }

  mutable fun noAggr<T>(f: () -> T): T {
    this.!isAggr = false;
    result = f();
    this.!isAggr = true;
    result
  }

  mutable fun compileBinop(cge1: CGExpr, cge2: CGExpr, op: String): CGExpr {
    (cge1, cge2, op) match {
    | (CGNull(), CGNull(), _) -> CGNull()

    | (CIExpr(e1), CIExpr(e2), "OR") -> CIExpr(COr(e1, e2))
    | (CGNull(), CIExpr(e2), "OR") -> CIExpr(COr(CNull(), e2))
    | (CIExpr(e1), CGNull(), "OR") -> CIExpr(COr(e1, CNull()))

    | (CGNull(), _, _)
    | (_, CGNull(), _) ->
      CGNull()

    | (CIExpr(e1), CIExpr(e2), "<") -> CIExpr(CILt(e1, e2))
    | (CIExpr(e1), CIExpr(e2), "<=") -> CIExpr(CILte(e1, e2))
    | (CIExpr(e1), CIExpr(e2), ">=") -> CIExpr(CIGte(e1, e2))
    | (CIExpr(e1), CIExpr(e2), ">") -> CIExpr(CIGt(e1, e2))
    | (CIExpr(e1), CIExpr(e2), "=") -> CIExpr(CIEq(e1, e2))
    | (CIExpr(e1), CIExpr(e2), "<>") -> CIExpr(CIDiff(e1, e2))

    | (CFExpr(e1), CFExpr(e2), "<") -> CIExpr(CFLt(e1, e2))
    | (CFExpr(e1), CFExpr(e2), "<=") -> CIExpr(CFLte(e1, e2))
    | (CFExpr(e1), CFExpr(e2), ">=") -> CIExpr(CFGte(e1, e2))
    | (CFExpr(e1), CFExpr(e2), ">") -> CIExpr(CFGt(e1, e2))
    | (CFExpr(e1), CFExpr(e2), "=") -> CIExpr(CFEq(e1, e2))
    | (CFExpr(e1), CFExpr(e2), "<>") -> CIExpr(CFDiff(e1, e2))

    | (CSExpr(e1), CSExpr(e2), "<") -> CIExpr(CSLt(e1, e2))
    | (CSExpr(e1), CSExpr(e2), "<=") -> CIExpr(CSLte(e1, e2))
    | (CSExpr(e1), CSExpr(e2), ">=") -> CIExpr(CSGte(e1, e2))
    | (CSExpr(e1), CSExpr(e2), ">") -> CIExpr(CSGt(e1, e2))
    | (CSExpr(e1), CSExpr(e2), "=") -> CIExpr(CSEq(e1, e2))
    | (CSExpr(e1), CSExpr(e2), "<>") -> CIExpr(CSDiff(e1, e2))

    | (CIExpr(e1), CIExpr(e2), "+") -> CIExpr(CAdd(e1, e2))
    | (CIExpr(e1), CIExpr(e2), "-") -> CIExpr(CSub(e1, e2))
    | (CIExpr(e1), CIExpr(e2), "*") -> CIExpr(CMul(e1, e2))
    | (CIExpr(e1), CIExpr(e2), "/") -> CIExpr(CDiv(e1, e2))
    | (CIExpr(e1), CIExpr(e2), "%") -> CIExpr(CMod(e1, e2))

    | (CFExpr(e1), CFExpr(e2), "+") -> CFExpr(CAdd(e1, e2))
    | (CFExpr(e1), CFExpr(e2), "-") -> CFExpr(CSub(e1, e2))
    | (CFExpr(e1), CFExpr(e2), "*") -> CFExpr(CMul(e1, e2))
    | (CFExpr(e1), CFExpr(e2), "/") -> CFExpr(CDiv(e1, e2))

    | (CIExpr(e1), CIExpr(e2), "AND") -> CIExpr(CAnd(e1, e2))
    | (CSExpr(e1), CSExpr(e2), "||") -> CSExpr(CSConcat(e1, e2))

    | _ -> error(this.pos, "Incompatible types: " + op)
    }
  }

  mutable fun makeIf(cond: CGExpr, branch1: CGExpr, branch2: CGExpr): CGExpr {
    cond match {
    | CGNull() -> branch2
    | CIExpr(icond) ->
      (branch1, branch2) match {
      | (CIExpr(e1), CIExpr(e2)) -> CIExpr(CIf(icond, e1, e2))
      | (CFExpr(e1), CFExpr(e2)) -> CFExpr(CIf(icond, e1, e2))
      | (CSExpr(e1), CSExpr(e2)) -> CSExpr(CIf(icond, e1, e2))
      | (CGNull(), CGNull()) -> CGNull()
      | (CGNull(), CIExpr(e2)) -> CIExpr(CIf(icond, CNull(), e2))
      | (CGNull(), CFExpr(e2)) -> CFExpr(CIf(icond, CNull(), e2))
      | (CGNull(), CSExpr(e2)) -> CSExpr(CIf(icond, CNull(), e2))
      | (CIExpr(e1), CGNull()) -> CIExpr(CIf(icond, e1, CNull()))
      | (CFExpr(e1), CGNull()) -> CFExpr(CIf(icond, e1, CNull()))
      | (CSExpr(e1), CGNull()) -> CSExpr(CIf(icond, e1, CNull()))
      | _ ->
        debug((branch1, branch2));
        error(this.pos, "Branch have different types")
      }
    | CFExpr(_) ->
      error(
        this.pos,
        "Unexpected if condition type, expected INTEGER, not FLOAT",
      )
    | CSExpr(_) ->
      error(
        this.pos,
        "Unexpected if condition type, expected INTEGER, not TEXT",
      )
    }
  }

  readonly fun findJoin(
    tables: readonly Vector<?JTable>,
    cond: Expr,
  ): (Expr, JoinKind, ?EqJoin) {
    cond match {
    | On(jk, e) ->
      (!e, _, eqJoin) = this.findJoin(tables, e);
      jk match {
      | JLeft(_)
      | JRight(_)
      | JOuter() ->
        if (eqJoin is None()) {
          error(this.pos, "Invalid ON expression for JOIN");
        }
      | JCross()
      | JInner()
      | JNone() ->
        void
      };
      (e, jk, eqJoin)

    | Binop("AND", e1, e2) ->
      (!e1, jk1, join1) = this.findJoin(tables, e1);
      join1 match {
      | None() ->
        (!e2, jk2, join2) = this.findJoin(tables, e2);
        join2 match {
        | None() -> (cond, JNone(), None())
        | Some(_) ->
          (
            if (e2 is Literal("1", false)) e1 else Binop("AND", e1, e2),
            jk2,
            join2,
          )
        }
      | Some(_) ->
        (
          if (e1 is Literal("1", false)) e2 else Binop("AND", e1, e2),
          jk1,
          join1,
        )
      }
    | Binop("=", Binop(".", Literal(tname1, _), Literal(cname1, _)), e2) ->
      this.findJoin(
        tables,
        Binop("=", Literal(tname1 + "." + cname1, false), e2),
      )

    | Binop("=", e1, Binop(".", Literal(tname2, _), Literal(cname2, _))) ->
      this.findJoin(
        tables,
        Binop("=", e1, Literal(tname2 + "." + cname2, false)),
      )

    | Binop(
      "=",
      Literal(name1, _),
      Literal(name2, _),
    ) if (this.subst.containsKey(name1) && this.subst.containsKey(name2)) ->
      (this.subst[name1], this.subst[name2]) match {
      | (CIExpr(CIGetFrom(tableNbr1, col1)), CIExpr(CIGetFrom(tableNbr2, col2)))
      | (CFExpr(CFGetFrom(tableNbr1, col1)), CFExpr(CFGetFrom(tableNbr2, col2)))
      | (
        CSExpr(CSGetFrom(tableNbr1, col1)),
        CSExpr(CSGetFrom(tableNbr2, col2)),
      ) if (
        tables[tableNbr1] is Some _ &&
        tables[tableNbr2] is Some _ &&
        tableNbr1 != tableNbr2
      ) ->
        if (tableNbr1 > tableNbr2) {
          (!tableNbr1, !col1, !tableNbr2, !col2) = (
            tableNbr2,
            col2,
            tableNbr1,
            col1,
          );
        };
        table1 = tables[tableNbr1].fromSome();
        table2 = tables[tableNbr2].fromSome();
        col1IsUnique = isUnique(table1.schema[col1]);
        col2IsUnique = isUnique(table2.schema[col2]);
        col1Name = (col1, IASC(), table1.schema[col1].ty);
        proj1 = TableProj(tableNbr1, col1Name, col1IsUnique);
        col2Name = (col2, IASC(), table2.schema[col2].ty);
        proj2 = TableProj(tableNbr2, col2Name, col2IsUnique);
        (Literal("1", false), JInner(), Some(EqJoin(proj1, proj2)))
      | _ -> (cond, JNone(), None())
      }
    | _ -> (cond, JNone(), None())
    }
  }

  mutable fun compileJoin(
    context: mutable SKFS.Context,
    origFrom: Array<DirDescr>,
    select: Select,
  ): (?Expr, Array<(SKSQL.DirDescr, ?Array<SKFS.KeyRange>)>) {
    select.where match {
    | None() ->
      if (origFrom.size() > 1) {
        if (this.options.virtual) {
          error(
            this.pos,
            "Cross joins not supported in virtual views (regardless of option --always-allow-joins)",
          );
        };
        if (!this.options.alwaysAllowJoins) {
          errorNoMergeClause(this.pos);
        }
      };
      (None(), origFrom.map(x -> (x, None())))
    | Some(cond) ->
      from = this.compileIndexes(context, origFrom, cond);
      (!cond, !from) = this.compileMerge(from, cond);

      tablesLeft = from.filter(x ->
        x.i1 match {
        | None() -> true
        | Some(_) -> false
        }
      );
      if (tablesLeft.size() >= 2 && !this.options.alwaysAllowJoins) {
        errorNoMergeClause(this.pos);
      };
      (Some(cond), from)
    }
  }

  mutable fun compileMerge(
    from: Array<(SKSQL.DirDescr, ?Array<SKFS.KeyRange>)>,
    cond: Expr,
  ): (Expr, Array<(SKSQL.DirDescr, ?Array<SKFS.KeyRange>)>) {
    tables = mutable Vector<?JTable>[];
    newFrom = mutable Vector[];
    moveMap = mutable Map[];

    for (tableRange in from) {
      tables.push(Some(JTable::fromDirDescr(tableRange.i0, tableRange.i1)))
    };

    loop {
      (!cond, joinKind, joinOpt) = this.findJoin(tables, cond);
      join = joinOpt match {
      | None() ->
        for (tableNbr => tableOpt in tables) {
          tableOpt match {
          | None() -> void
          | Some(table) ->
            moveMap![tableNbr] = newFrom.size();
            dirDescr = DirDescr{
              name => table.dirName.toString(),
              colNames => from.map(x -> x.i0.colNames).flatten(),
              dirName => table.dirName,
              schema => table.schema.map(x ->
                if (x.primary) x with {unique => true} else x
              ),
              alias => table.alias,
              cols => SortedMap[],
              windowSize => table.windowSize,
              isInput => false,
            };
            newFrom.push((dirDescr, table.ranges))
          }
        };

        for (name => cexpr in this.subst.clone()) {
          cexpr match {
          | SKSQL.CIExpr(
            SKSQL.CIGetFrom(tableNbr, colNbr),
          ) if (moveMap.containsKey(tableNbr)) ->
            this.subst![name] = SKSQL.CIExpr(
              SKSQL.CIGetFrom(moveMap[tableNbr], colNbr),
            )
          | SKSQL.CFExpr(
            SKSQL.CFGetFrom(tableNbr, colNbr),
          ) if (moveMap.containsKey(tableNbr)) ->
            this.subst![name] = SKSQL.CFExpr(
              SKSQL.CFGetFrom(moveMap[tableNbr], colNbr),
            )
          | SKSQL.CSExpr(
            SKSQL.CSGetFrom(tableNbr, colNbr),
          ) if (moveMap.containsKey(tableNbr)) ->
            this.subst![name] = SKSQL.CSExpr(
              SKSQL.CSGetFrom(moveMap[tableNbr], colNbr),
            )
          | _ -> void
          }
        };

        return (cond, newFrom.toArray())
      | Some(x) -> x
      };
      leftTable = tables[join.left.tableNbr].fromSome();
      rightTable = tables[join.right.tableNbr].fromSome();
      viewName = leftTable.name + "_" + rightTable.name;
      if (!this.options.virtual && !this.options.alwaysAllowJoins) {
        leftSchema = tables[join.left.tableNbr].fromSome().schema;
        col1 = leftSchema[join.left.col.i0].name;
        rightSchema = tables[join.right.tableNbr].fromSome().schema;
        col2 = rightSchema[join.right.col.i0].name;
        msg =
          "Joins outside of virtual views are considered bad practice in skdb.\n" +
          "You should first create a virtual view joining " +
          leftTable.name +
          " and " +
          rightTable.name +
          " with a query of the form:\n\n" +
          "create virtual view " +
          viewName +
          " as select * from " +
          leftTable.name +
          ", " +
          rightTable.name +
          " where " +
          col1 +
          " = " +
          col2 +
          ";\n\n" +
          "And then use " +
          viewName +
          " directly.\n" +
          "PS: You can ignore this error message with " +
          "--always-allow-joins (not recommended).\n" +
          if (tables.size() == 2) {
            "PS2: don't forget you can add indexes to virtual views."
          } else {
            ""
          };
        error(this.pos, msg)
      };
      childName = SKFS.DirName::create(
        "/merge/left" +
          leftTable.dirName +
          join.left.col.i0 +
          "-" +
          hash(leftTable.ranges) +
          "/right" +
          rightTable.dirName +
          join.right.col.i0 +
          "-" +
          hash(rightTable.ranges) +
          "/",
      );
      leftKinds = tables[join.left.tableNbr]
        .fromSome()
        .schema.mapWithIndex((idx, tyDescr) -> (idx, IASC(), tyDescr.ty));
      rightKinds = tables[join.right.tableNbr]
        .fromSome()
        .schema.mapWithIndex((idx, tyDescr) -> (idx, IASC(), tyDescr.ty));
      this.other.push(
        SubMerge{
          leftDirName => leftTable.dirName,
          leftColNbr => join.left.col.i0,
          leftIsUnique => join.left.isUnique,
          leftRanges => leftTable.ranges,
          rightDirName => rightTable.dirName,
          rightColNbr => join.right.col.i0,
          rightIsUnique => join.right.isUnique,
          rightRanges => rightTable.ranges,
          childName,
          kinds => leftKinds.concat(
            rightKinds.map(x -> (leftKinds.size() + x.i0, x.i1, x.i2)),
          ),
          joinKind,
          windowSize => minWindowSize(
            leftTable.windowSize,
            rightTable.windowSize,
          ),
        },
      );

      for (name => cexpr in this.subst.clone()) {
        cexpr match {
        | SKSQL.CIExpr(
          SKSQL.CIGetFrom(tableNbr, colNbr),
        ) if (tableNbr == join.right.tableNbr) ->
          leftSize = tables[join.left.tableNbr].fromSome().schema.size();
          this.subst![name] = SKSQL.CIExpr(
            SKSQL.CIGetFrom(join.left.tableNbr, leftSize + colNbr),
          )
        | SKSQL.CFExpr(
          SKSQL.CFGetFrom(tableNbr, colNbr),
        ) if (tableNbr == join.right.tableNbr) ->
          leftSize = tables[join.left.tableNbr].fromSome().schema.size();
          this.subst![name] = SKSQL.CFExpr(
            SKSQL.CFGetFrom(join.left.tableNbr, leftSize + colNbr),
          )
        | SKSQL.CSExpr(
          SKSQL.CSGetFrom(tableNbr, colNbr),
        ) if (tableNbr == join.right.tableNbr) ->
          leftSize = tables[join.left.tableNbr].fromSome().schema.size();
          this.subst![name] = SKSQL.CSExpr(
            SKSQL.CSGetFrom(join.left.tableNbr, leftSize + colNbr),
          )
        | _ -> void
        }
      };
      newSchema = tables[join.left.tableNbr]
        .fromSome()
        .schema.concat(tables[join.right.tableNbr].fromSome().schema);
      tables![join.right.tableNbr] = None();
      tables![join.left.tableNbr] = Some(
        JTable{
          name => viewName,
          dirName => childName,
          ranges => None(),
          schema => newSchema,
          alias => None(),
          windowSize => None(),
        },
      );
    }
  }

  mutable fun compileIndexes(
    context: mutable SKFS.Context,
    from: Array<DirDescr>,
    cond: Expr,
  ): Array<(SKSQL.DirDescr, ?Array<SKFS.KeyRange>)> {
    tables = mutable Vector[];
    for (dirDescr in from) {
      tables.push(JTable::fromDirDescr(dirDescr, None()));
    };
    killed = mutable Set[];
    rangeMap = mutable Map[];

    loop {
      this.findLookUps(context, killed, tables, cond).select() match {
      | None() ->
        result = from.mapWithIndex((idx, table) -> {
          rangeMap.maybeGet(idx) match {
          | None() -> (table, None())
          | Some((indexDirName, ranges)) ->
            (table with {dirName => indexDirName}, Some(ranges))
          }
        });
        return result
      | Some((index, tableNbr, ranges)) ->
        for (range in ranges) {
          (low, high) = range;
          if (low > high) {
            error(
              this.pos,
              "contradictory inequalities, result will always be empty",
            );
          };
        };
        if (this.options.showUsedIndexes) {
          print_string("USING INDEX: " + index.name);
        };
        killed.add(index.tableName);
        rowRanges = ranges.map(range -> {
          (minKeyValues, maxKeyValues) = range;
          kinds = index.fields.mapWithIndex((idx, field) -> {
            (idx, IASC(), field.i2)
          });
          maxValues = kinds.mapWithIndex((idx, kind) -> {
            if (idx < maxKeyValues.size()) {
              Some(maxKeyValues[idx])
            } else {
              Some(
                kind.i2 match {
                | INTEGER() -> CInt(Int::max)
                | FLOAT() -> CFloat(Float::inf)
                | TEXT() -> CString(largestString())
                },
              )
            }
          });
          minKey = RowKey(
            RowValues::create(minKeyValues.map(x -> Some(x))),
            kinds,
          );
          maxKey = RowKey(RowValues::create(maxValues), kinds);
          SKFS.KeyRange(minKey, maxKey)
        });
        rangeMap![tableNbr] = (index.dirName, rowRanges)
      }
    }
  }

  readonly fun isVar(name: String): Bool {
    this.subst.containsKey(name)
  }

  mutable fun findLookUps(
    context: mutable SKFS.Context,
    killed: readonly Set<SKFS.DirName>,
    tables: readonly Vector<JTable>,
    cond: Expr,
  ): LookUps {
    cond match {
    | Binop(
      op,
      Call("strftime", Some(args)),
      e2,
    ) if (args.all(x -> x is Literal(_, true))) ->
      sargs = args.map(x ->
        x match {
        | Literal(str, _) -> str
        | _ -> invariant_violation("Unexpected type")
        }
      );
      this.findLookUps(
        context,
        killed,
        tables,
        Binop(op, Literal(callStrftime(this.pos, context, sargs), true), e2),
      )

    | Binop(
      op,
      e1,
      Call("strftime", Some(args)),
    ) if (args.all(x -> x is Literal(_, true))) ->
      sargs = args.map(x ->
        x match {
        | Literal(str, _) -> str
        | _ -> invariant_violation("Unexpected type")
        }
      );
      this.findLookUps(
        context,
        killed,
        tables,
        Binop(op, e1, Literal(callStrftime(this.pos, context, sargs), true)),
      )

    | Binop(op, Call("date", Some(args)), e2) ->
      if (args.size() < 1) {
        error(this.pos, "Missing arguments");
      };
      this.findLookUps(
        context,
        killed,
        tables,
        Binop(
          op,
          Call("strftime", Some(Array[Literal("%Y-%m-%d", true)].concat(args))),
          e2,
        ),
      )

    | Binop(op, Call("time", Some(args)), e2) ->
      if (args.size() < 1) {
        error(this.pos, "Missing arguments");
      };
      this.findLookUps(
        context,
        killed,
        tables,
        Binop(
          op,
          Call("strftime", Some(Array[Literal("%H:%M:%S", true)].concat(args))),
          e2,
        ),
      )

    | Binop(op, Call("datetime", Some(args)), e2) ->
      if (args.size() < 1) {
        error(this.pos, "Missing arguments");
      };
      this.findLookUps(
        context,
        killed,
        tables,
        Binop(
          op,
          Call(
            "strftime",
            Some(Array[Literal("%Y-%m-%d %H:%M:%S", true)].concat(args)),
          ),
          e2,
        ),
      )

    | Binop(op, e1, Call("date", Some(args))) ->
      if (args.size() < 1) {
        error(this.pos, "Missing arguments");
      };
      this.findLookUps(
        context,
        killed,
        tables,
        Binop(
          op,
          e1,
          Call("strftime", Some(Array[Literal("%Y-%m-%d", true)].concat(args))),
        ),
      )

    | Binop(op, e1, Call("time", Some(args))) ->
      if (args.size() < 1) {
        error(this.pos, "Missing arguments");
      };
      this.findLookUps(
        context,
        killed,
        tables,
        Binop(
          op,
          e1,
          Call("strftime", Some(Array[Literal("%H:%M:%S", true)].concat(args))),
        ),
      )

    | Binop(op, e1, Call("datetime", Some(args))) ->
      if (args.size() < 1) {
        error(this.pos, "Missing arguments");
      };
      this.findLookUps(
        context,
        killed,
        tables,
        Binop(
          op,
          e1,
          Call(
            "strftime",
            Some(Array[Literal("%Y-%m-%d %H:%M:%S", true)].concat(args)),
          ),
        ),
      )

    | Binop(op, Binop(".", Literal(tname1, _), Literal(cname1, _)), e2) ->
      this.findLookUps(
        context,
        killed,
        tables,
        Binop(op, Literal(tname1 + "." + cname1, false), e2),
      )

    | Binop(op, e1, Binop(".", Literal(tname2, _), Literal(cname2, _))) ->
      this.findLookUps(
        context,
        killed,
        tables,
        Binop(op, e1, Literal(tname2 + "." + cname2, false)),
      )

    | Binop("AND", e1, e2) ->
      this.findLookUps(context, killed, tables, e1).and(
        this.findLookUps(context, killed, tables, e2),
      )
    | Binop("OR", e1, e2) ->
      this.findLookUps(context, killed, tables, e1).or(
        this.findLookUps(context, killed, tables, e2),
      )

    | Binop(
      _,
      Literal(name1, _),
      Literal(name2, _),
    ) if (this.isVar(name1) && this.isVar(name2)) ->
      LookUps[]

    | In(e, values) ->
      if (values.size() == 0) {
        error(this.pos, "Invalid IN")
      };
      acc = Binop("=", e, values[0]);
      for (i in Range(1, values.size())) {
        !acc = Binop("OR", acc, Binop("=", e, values[i]))
      };
      this.findLookUps(context, killed, tables, acc)

    | Binop(
      op,
      e1 @ Literal _,
      e2 @ Literal(name2, _),
    ) if (this.isVar(name2)) ->
      !op = op match {
      | "=" -> op
      | "<" -> ">"
      | "<=" -> ">="
      | ">" -> "<"
      | ">=" -> "<="
      | _ -> return LookUps[]
      };
      this.findLookUps(context, killed, tables, Binop(op, e2, e1))

    | Binop(op, Literal(name1, _), e @ Literal _) if (this.isVar(name1)) ->
      op match {
      | "=" | "<" | "<=" | ">" | ">=" -> void
      | _ -> return LookUps[]
      };
      (tableNbr, colNbr) = this.subst[name1] match {
      | (CIExpr(CIGetFrom(x, y))) -> (x, y)
      | (CFExpr(CFGetFrom(x, y))) -> (x, y)
      | (CSExpr(CSGetFrom(x, y))) -> (x, y)
      | _ -> return LookUps[]
      };
      table = tables[tableNbr];
      indexEntry = makeIndexEntry(table.dirName, colNbr);
      indexTable = getIndexByColNbr(this.options, context);
      indexes = indexTable.getArray(context, indexEntry);
      !indexes = indexes.filter(index -> !killed.contains(index.tableName));
      ce = this.compileExpr(context, e);
      if (ce.getType() != table.schema[colNbr].ty) {
        error(this.pos, "Incompatible types");
      };
      value = ce match {
      | CIExpr(CILiteral(v)) -> CInt(v)
      | CFExpr(CFLiteral(f)) -> CFloat(f)
      | CSExpr(CSLiteral(s)) -> CString(s)
      | _ -> return LookUps[]
      };
      lookUps = indexes.map(index -> {
        (lookUpColNbr, unique) = for (slot => field in index.fields) {
          if (field.i0 == colNbr) break (slot, isUnique(table.schema[colNbr]))
        } else {
          invariant_violation("Could not find column: " + colNbr)
        };
        cols = SortedA[
          Col(lookUpColNbr, Array[(ColOp::create(op, value))], unique),
        ];
        LookUp{index, tableNbr, cols}
      });
      LookUps::createFromItems(lookUps)
    | _ -> LookUps[]
    }
  }
}

/*****************************************************************************/
/* LIKE patterns parsing. */
/*****************************************************************************/

fun parsePattern(str: Vector<Char>): Pattern {
  text = mutable Vector[];
  subs = mutable Vector[];
  hasUnderscore = false;
  for (c in str) {
    if (c == '%') {
      if (text.size() != 0) {
        subs.push(text.toArray());
        text.clear();
      };
      continue;
    };
    if (c == '_') {
      !hasUnderscore = true;
    };
    text.push(c);
  };
  if (text.size() != 0) {
    subs.push(text.toArray());
    text.clear();
  };
  firstIsPercent = str.size() > 0 && str[0] == '%';
  lastIsPercent = str.size() > 0 && str[str.size() - 1] == '%';
  Pattern{hasUnderscore, firstIsPercent, lastIsPercent, subs => subs.toArray()}
}
