module SKTest;

class Test{
  name: String,
  func: () ~> void,
  file: String = "unknown",
  lineno: Int = -1,
} {}

fun test_job(
  tests: readonly Map<String, readonly Sequence<Test>>,
  filter: String,
  njobs: Int,
  rank: Int,
): void {
  stdout = mutable IO.File(Posix.dup(IO.stdout().fileno));
  stdout_file = Posix.mkstemp(Path.join(Environ.temp_dir(), "XXXXXX"));
  Posix.dup2(stdout_file.fileno, IO.stdout().fileno);
  i = 0;
  for (testSuite in tests.keys()) {
    for (test in tests[testSuite]) {
      if (!(testSuite + "." + test.name).contains(filter)) {
        continue
      };
      !i = i + 1;
      if (i % njobs != rank) {
        continue
      };
      res = TestResult{
        name => test.name,
        suite => testSuite,
        file => test.file,
        line => test.lineno,
      };
      // TODO: Use more accurate clock.
      start = Time.time();
      !res = try {
        _ = test.func();
        res with {
          result => "success",
          // TODO: test time
          time => Time.time() - start,
        }
      } catch {
      | ExpectationError(msg, _, _) ->
        res with {
          result => "failure",
          time => Time.time() - start,
          failure_type => "ExpectationError",
          failure_message => msg,
          failure_extra => stdout_file.read_to_end(),
        }
      | exn ->
        res with {
          result => "error",
          time => Time.time() - start,
          failure_type => inspect(exn).toString(),
          failure_message => exn.getMessage(),
          failure_extra => stdout_file.read_to_end(),
        }
      };
      stdout.write_all(res.toJSON() + "\n");
    }
  };
}

fun test_harness(tests: readonly Map<String, readonly Sequence<Test>>): void {
  args = Cli.Command("tests")
    .about("Run tests")
    .arg(
      Cli.StringArg("filter")
        .positional()
        .about(
          "If specified, only run tests containing this string in their names",
        ),
    )
    .arg(
      Cli.IntArg("jobs")
        .long("jobs")
        .short("j")
        .about("Number of parallel jobs, defaults to # of CPUs")
        .default(8), // TODO: Properly determine available cores.
    )
    .arg(Cli.StringArg("junitxml").about("Generate a JUnit XML report"))
    .arg(
      Cli.BoolArg("verbose")
        .long("verbose")
        .short("v")
        .about("Use verbose output"),
    )
    .help()
    .parseArgs();

  reporters = mutable Vector<mutable TestReporter>[
    mutable BasicTestReporter{color => true},
  ];
  args.maybeGetString("junitxml").each(path ->
    reporters.push(mutable XmlTestReporter{output => Some(path)})
  );
  filter = args.maybeGetString("filter").default("");

  njobs = args.getInt("jobs");
  procs = Range(0, njobs).map(rank -> {
    Posix.Popen::createFromLambda{
      target => () -> {
        test_job(tests, filter, njobs, rank)
      },
      stdout => true,
      stderr => true,
    };
  });
  readers = Array::createFromItems(
    procs.map(p -> mutable IO.BufferedReader(p.stdout.fromSome())),
  );
  pollfds = Array::mcreateFromItems(
    procs.map(p -> Posix.Pollfd::create(p.stdout.fromSome().fileno)),
  );
  open_fds = procs.size();
  success = true;
  while (open_fds > 0) {
    _ = Posix.poll(pollfds);
    for ((i, pfd) in pollfds.items()) {
      if (pfd.pollin()) {
        loop {
          line = readers[i].read_line();
          res = TestResult::fromJSON(line);
          if (res.result != "success") {
            !success = false
          };
          reporters.each(x -> x.report(res));
          if (readers[i].buffer.length() == 0) {
            break void
          }
        }
      } else if (pfd.fd != -1 && (pfd.pollerr() || pfd.pollhup())) {
        pollfds.set(i, Posix.Pollfd::create(-1));
        !open_fds = open_fds - 1
      }
    }
  };
  procs.each(p -> _ = p.wait());
  reporters.each(r -> r.finish());

  if (!success) {
    skipExit(1)
  }
}

fun main(): void {
  tests = mutable Map[];
  #forEachFunction (@test, #function, #functionName) {
    // TODO: Properly handle tests outside of module/suite?
    (testSuite, testName) = #functionName.splitFirst(".");
    if (!tests.containsKey(testSuite)) {
      tests.set(testSuite, mutable Vector[])
    };
    tests[testSuite].push(Test{name => testName, func => #function})
  };
  test_harness(tests)
}
