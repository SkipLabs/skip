module alias AP = ArgumentParser;

const argsSchema: Array<AP.Param> = Array[
  AP.BoolParam{name => "all", help => "run all the tests", negatable => false},
  AP.BoolParam{name => "replay", help => "replay a diff", negatable => false},
  AP.BoolParam{
    name => "always-allow-joins",
    help => "allows cross joins and joins outside of virtual views",
    negatable => false,
  },
  AP.BoolParam{
    name => "show-used-indexes",
    help => "prints on stdout the indexes used by a query",
    negatable => false,
  },
  AP.BoolParam{name => "backtrace", help => "internal use", negatable => false},
  AP.BoolParam{name => "sync", help => "sync to disk", negatable => false},
  AP.BoolParam{
    name => "compact",
    help => "compacts the db",
    negatable => false,
  },
  AP.BoolParam{
    name => "size",
    help => "returns the size of the db",
    negatable => false,
  },
  AP.BoolParam{name => "debug", help => "", negatable => false},
  AP.BoolParam{name => "sessions", help => "", negatable => false},
  AP.BoolParam{
    name => "csv",
    help => "Changes the output format to CSV",
    negatable => false,
  },
  AP.StringParam{name => "test", help => "The name of the test to run"},
  AP.StringParam{name => "init", help => "Initializes a new data file"},
  AP.StringParam{name => "capacity", help => "Initializes at a given capacity"},
  AP.StringParam{name => "data", help => "Loads an existing data file"},
  AP.StringParam{
    name => "connect",
    help => "Same as --subscribe, but sends the initial state first",
  },
  AP.IntParam{name => "disconnect", help => "Disconnects a session"},
  AP.StringParam{
    name => "subscribe",
    help => "Subscribes to a directory change",
  },
  AP.StringParam{
    name => "write",
    help => "Writes the data coming from stdin into a directory",
  },
  AP.IntParam{name => "reconnect", help => "reconnects to a session id"},
  AP.IntParam{
    name => "diff",
    help => "sends the diff from session (must be used with --since)",
  },
  AP.IntParam{
    name => "since",
    help => "specifies the starting time of the diff",
  },
  AP.StringParam{
    name => "updates",
    help => "Name of the file where the updates will be written",
  },
  AP.StringParam{
    name => "notify",
    help => "Name of the file updated with time of the last change",
  },
  AP.StringParam{name => "load-csv", help => "load csv values into table"},
  AP.BoolParam{
    name => "dump-tables",
    help => "Dumps the table in SQL format",
    negatable => false,
  },
  AP.BoolParam{
    name => "dump-inserts",
    help => "Dumps the inserts in SQL format",
    negatable => false,
  },
  AP.BoolParam{
    name => "dump-views",
    help => "Dumps the views in SQL format",
    negatable => false,
  },
  AP.BoolParam{
    name => "dump",
    help => "Dumps tables/inserts/views in SQL format",
    negatable => false,
  },
];

fun getParsedArgs(): AP.ParseResult {
  AP.parse(argsSchema, arguments()) match {
  | Success(value) -> value
  | Failure(error) ->
    print_error(error.getMessage());
    skipExit(2)
  }
}

fun fixUpDirName(dirNameStr: String): SKFS.DirName {
  chars = dirNameStr.chars();
  SKFS.DirName::create(
    (if (chars[0] != '/') "/" else "") +
      dirNameStr +
      (if (chars[chars.size() - 1] != '/') "/" else ""),
  )
}

untracked fun main(): void {
  parsedArgs = getParsedArgs();
  argMap = parsedArgs.argumentValues;
  if (parsedArgs.unknown.size() != 0) {
    unknownOptions = parsedArgs.unknown.filter(x ->
      x != "" && x.getIter().next() == Some('-')
    );
    for (option in unknownOptions) {
      if (option != "--help") print_error("Unknown option: " + option);
    };
    if (unknownOptions.size() != 0) {
      print_error(AP.help(argsSchema));
      skipExit(2);
    }
  };
  argFiles = parsedArgs.unknown.toArray();
  if (argFiles.size() > 0) {
    for (file in argFiles) {
      print_error("Error: don't know what to do with " + file);
    };
    skipExit(2);
  };

  options = SKSQL.Options{
    backtrace => argMap.maybeGet("backtrace") is Some(AP.BoolValue _),
    alwaysAllowJoins => argMap.maybeGet("always-allow-joins") is Some(
      AP.BoolValue _,
    ),
    sync => argMap.maybeGet("sync") is Some(AP.BoolValue _),
    showUsedIndexes => argMap.maybeGet("show-used-indexes") is Some(
      AP.BoolValue _,
    ),
    csv => argMap.maybeGet("csv") is Some(AP.BoolValue _),
  };

  argMap.maybeGet("sessions") match {
  | Some(AP.BoolValue _) ->
    if (SKFS.gHasContext() == 0) {
      invariant(argMap.maybeGet("data") is Some(AP.MissingValue{}));
      print_error("Error: option --data is missing");
      skipExit(2);
    };
    SKSQL.runSql(options, context ~> {
      for (id => dirName in context.sessions) {
        sub = context.unsafeGetEagerDir(dirName).subs[id];
        print_string(
          id.toString() +
            "\t" +
            dirName.toString() +
            "\t" +
            if (sub.status == 0) "CONNECTED" else "DISCONNECTED",
        );
      };
      SKFS.CStop(None())
    });
    return void
  | _ -> void
  };

  argMap.maybeGet("compact") match {
  | Some(AP.BoolValue{value => true}) ->
    if (SKFS.gHasContext() == 0) {
      invariant(argMap.maybeGet("data") is Some(AP.MissingValue{}));
      print_error("Error: option --data is missing");
      skipExit(2);
    };
    SKSQL.runLockedSql(options, context ~> {
      for (_dirName => dir in context.dirs.state) {
        dir match {
        | edir @ SKFS.EagerDir _ ->
          !edir = edir.purge();
          context.setDir(edir.dirName, edir)
        | _ -> void
        }
      };
    });
    return void
  | _ -> void
  };

  argMap.maybeGet("dump-tables") match {
  | Some(AP.BoolValue{value => true}) ->
    if (SKFS.gHasContext() == 0) {
      invariant(argMap.maybeGet("data") is Some(AP.MissingValue{}));
      print_error("Error: option --data is missing");
      skipExit(2);
    };
    SKSQL.runSql(options, context ~> {
      SKSQL.dumpTables(context);
      skipExit(0);
      SKFS.CStop(None())
    });
    return void
  | _ -> void
  };

  argMap.maybeGet("dump-inserts") match {
  | Some(AP.BoolValue{value => true}) ->
    if (SKFS.gHasContext() == 0) {
      invariant(argMap.maybeGet("data") is Some(AP.MissingValue{}));
      print_error("Error: option --data is missing");
      skipExit(2);
    };
    SKSQL.runSql(options, context ~> {
      SKSQL.dumpInserts(context);
      SKFS.CStop(None())
    });
    return void
  | _ -> void
  };

  argMap.maybeGet("dump-views") match {
  | Some(AP.BoolValue{value => true}) ->
    if (SKFS.gHasContext() == 0) {
      invariant(argMap.maybeGet("data") is Some(AP.MissingValue{}));
      print_error("Error: option --data is missing");
      skipExit(2);
    };
    SKSQL.runSql(options, context ~> {
      SKSQL.dumpViews(context);
      SKFS.CStop(None())
    });
    return void
  | _ -> void
  };

  argMap.maybeGet("dump") match {
  | Some(AP.BoolValue{value => true}) ->
    if (SKFS.gHasContext() == 0) {
      invariant(argMap.maybeGet("data") is Some(AP.MissingValue{}));
      print_error("Error: option --data is missing");
      skipExit(2);
    };
    SKSQL.runSql(options, context ~> {
      SKSQL.dumpTables(context);
      SKSQL.dumpInserts(context);
      SKSQL.dumpViews(context);
      SKFS.CStop(None())
    });
    return void
  | _ -> void
  };

  argMap.maybeGet("load-csv") match {
  | Some(AP.StringValue{value => tableNameUpper}) ->
    tableName = tableNameUpper.lowercase();
    name = SKFS.SID::create(tableName);
    SKSQL.runSql(options, context ~> {
      table = context.getGlobal("CSV_TABLE") match {
      | None() ->
        tableDescr = SKSQL.getTable(options, context, 0, name);
        context.setGlobal("CSV_TABLE", tableDescr);
        tableDescr
      | Some(x) -> SKSQL.DirDescr::fromFile(x)
      };
      line = context.getGlobal("Line") match {
      | None() -> mutable Ref(1)
      | Some(file) -> mutable Ref(SKFS.IntFile::fromFile(file).value)
      };
      vtry<SKFS.ContextOp>(
        () -> {
          contextOp = SKCSV.insert(context, line, options, table);
          context.setGlobal("Line", SKFS.IntFile(line.get()));
          contextOp
        },
        exn -> {
          print_error("Error, line " + line.get() + ": " + exn.getMessage());
          skipExit(23);
        },
      );
    });
    return void
  | _ -> void
  };

  argMap.maybeGet("size") match {
  | Some(AP.BoolValue{value => true}) ->
    if (SKFS.gHasContext() == 0) {
      invariant(argMap.maybeGet("data") is Some(AP.MissingValue{}));
      print_error("Error: option --data is missing");
      skipExit(2);
    };
    SKSQL.runSql(options, _context ~> {
      SKFS.printPersistentSize();
      SKFS.CStop(None())
    });
    return void
  | _ -> void
  };

  argMap.maybeGet("reconnect") match {
  | Some(AP.IntValue{value => sessionID}) ->
    if (SKFS.gHasContext() == 0) {
      invariant(argMap.maybeGet("data") is Some(AP.MissingValue{}));
      print_error("Error: option --data is missing");
      skipExit(2);
    };
    SKSQL.runSql(options, context ~> {
      dirName = context.sessions.maybeGet(sessionID) match {
      | None() ->
        print_error("Error: session not found");
        skipExit(2)
      | Some(x) -> x
      };
      edir = context.unsafeGetEagerDir(dirName);
      edir.reconnect(context, sessionID);
      SKFS.CStop(None())
    });
    return void
  | _ -> void
  };

  argMap.maybeGet("diff") match {
  | Some(AP.IntValue{value => sessionID}) ->
    if (SKFS.gHasContext() == 0) {
      invariant(argMap.maybeGet("data") is Some(AP.MissingValue{}));
      print_error("Error: option --data is missing");
      skipExit(2);
    };
    SKSQL.runSql(options, context ~> {
      if (options.csv) {
        context.setGlobal("CSV", SKFS.BoolFile(true));
      };
      dirName = context.sessions.maybeGet(sessionID) match {
      | None() ->
        print_error("Error: session not found");
        skipExit(2)
      | Some(x) -> x
      };
      time = argMap.maybeGet("since") match {
      | Some(AP.IntValue{value}) -> value
      | _ ->
        print_error("Error: --since option missing");
        skipExit(2)
      };
      context.setGlobal("Stdout", SKSQL.StdoutDiff(dirName, SKFS.Tick(time)));
      SKFS.CStop(None())
    });
    return void
  | _ -> void
  };

  argMap.maybeGet("disconnect") match {
  | Some(AP.IntValue{value => sessionID}) ->
    if (SKFS.gHasContext() == 0) {
      invariant(argMap.maybeGet("data") is Some(AP.MissingValue{}));
      print_error("Error: option --data is missing");
      skipExit(2);
    };
    SKSQL.runLockedSql(options, context ~> {
      dirName = context.sessions.maybeGet(sessionID) match {
      | None() ->
        print_error("Error: session not found");
        skipExit(2)
      | Some(x) -> x
      };
      context.unsafeGetEagerDir(dirName).disconnect(context, sessionID);
    });
    return void
  | Some(AP.MissingValue{}) -> void
  | _ ->
    print_error("Error: --disconnect expects a session ID");
    skipExit(2)
  };

  argMap.maybeGet("write") match {
  | Some(AP.StringValue{value => dirNameStr}) ->
    if (SKFS.gHasContext() == 0) {
      invariant(argMap.maybeGet("data") is Some(AP.MissingValue{}));
      print_error("Error: option --data is missing");
      skipExit(2);
    };
    SKSQL.runSql(options, context ~> {
      SKFS.writeFromStdin(context, dirNameStr);
      SKFS.CStop(None())
    });
    return void
  | _ -> void
  };

  subscribe = argMap.maybeGet("connect") match {
  | Some(AP.StringValue{value => viewName}) ->
    !viewName = viewName.lowercase();
    Some((viewName, fixUpDirName(viewName), true))
  | _ ->
    argMap.maybeGet("subscribe") match {
    | Some(AP.StringValue{value => viewName}) ->
      !viewName = viewName.lowercase();
      Some((viewName, fixUpDirName(viewName), false))
    | _ -> None()
    }
  };

  subscribe match {
  | None() -> void
  | Some((userViewName, viewDirName, init)) ->
    if (SKFS.gHasContext() == 0) {
      invariant(argMap.maybeGet("data") is Some(AP.MissingValue{}));
      print_error("Error: option --data is missing");
      skipExit(2);
    };
    SKSQL.runLockedSql(options, context ~> {
      viewName = userViewName.lowercase();
      SKSQL.forbidNow(context);
      cmd = (argMap.maybeGet("updates"), argMap.maybeGet("notify")) match {
      | (Some(AP.StringValue _), Some(AP.StringValue _)) ->
        print_error("Cannot have both --updates and --notify");
        skipExit(4)
      | (Some(AP.StringValue{value => x}), _) ->
        Some(SKFS.NUpdates(options.csv, x))
      | (_, Some(AP.StringValue{value => x})) -> Some(SKFS.NNotify(x))
      | _ -> None()
      };
      (input, output) = SKSQL.getSubsDirs(options, context);
      viewKey = SKFS.SID(viewName);
      inputDir = context.unsafeGetEagerDir(input.dirName);
      sessionID = SKFS.genSym(0);
      request = SKSQL.SubRequestFile(
        viewName,
        viewDirName,
        init,
        cmd,
        sessionID,
      );
      inputDir.write(context, viewKey, request);
      context.update();
      outputDir = context.unsafeGetEagerDir(output.dirName);
      file = outputDir.getArrayRaw(viewKey)[0];
      invariant(sessionID == SKFS.IntFile::fromFile(file).value);
      print_string(sessionID.toString());
    });
    return void
  };

  if (argMap.maybeGet("replay") is Some(AP.BoolValue _)) {
    map = mutable Map<String, (Int, Int)>[];
    lineNbr = 1;
    txNbr = 0;
    vtry(
      () -> {
        loop {
          line = read_line();
          if (line == "") {
            !txNbr = txNbr + 1;
            continue;
          };
          chars = mutable Vector[];
          iter = line.getIter();
          loop {
            c = iter.next() match {
            | None() ->
              print_error(
                "Error, line " + lineNbr + ": unexpected end of line",
              );
              skipExit(23)
            | Some(x) -> x
            };
            if (c == '\t') break void;
            if (c < '0' || c > '9') {
              print_error(
                "Error, line " + lineNbr + ": expected an integer key",
              );
              skipExit(23)
            };
            chars.push(c);
          };
          repeat = String::fromChars(chars.toArray()).toInt();
          value = line.sub(iter, line.length() - chars.size() - 1);
          if (map.containsKey(value)) {
            (oldTxNbr, oldRepeat) = map[value];
            if (oldTxNbr == txNbr) {
              map![value] = (txNbr, oldRepeat + repeat);
            } else {
              map![value] = (txNbr, repeat);
            }
          } else {
            map![value] = (txNbr, repeat);
          };
          !lineNbr = lineNbr + 1;
        }
      },
      exn -> {
        invariant(exn is EndOfFile _);
        map.each((value, txNbrAndRepeat) -> {
          (_, repeat) = txNbrAndRepeat;
          for (_ in Range(0, repeat)) {
            print_string(value);
          }
        })
      },
    );
    return void
  };

  if (argMap.maybeGet("all") is Some(AP.BoolValue _)) {
    testFuns = SKFSTest.getAllTests();
    for (testName => testFun in testFuns) {
      print_string(
        "/*****************************************************************************/",
      );
      print_string("/* " + testName + " */");
      print_string(
        "/*****************************************************************************/",
      );
      _ = testFun();
      print_string("");
    };
    return void;
  } else if (argMap.maybeGet("test") is Some(AP.StringValue _)) {
    testFuns = SKFSTest.getAllTests();
    testName = argMap["test"] match {
    | AP.StringValue{value => testName} ->
      if (!testFuns.containsKey(testName)) {
        print_error("Error: unknown test " + testName + "\n");
        for (key => _ in testFuns) {
          print_error("  " + key + "\n");
        };
        skipExit(4);
      };
      testName
    | _ ->
      print_error("Invalid test name type");
      skipExit(2)
    };
    context = testFuns[testName]();
    if (argMap.maybeGet("debug") is Some(AP.BoolValue _)) {
      SKFS.toplevel(context.clone())
    } else {
      return void
    }
  } else if (argMap.maybeGet("init") is Some(AP.StringValue _)) {
    _ = SKFS.gContextInit(SKSQL.makeSqlContext().clone());
    return void;
  } else if (argMap.maybeGet("capacity") is Some(AP.StringValue _)) {
    print_error("cannot use capacity without init");
    skipExit(2)
  } else if (argMap.maybeGet("data") is Some(AP.StringValue _)) {
    // this was handled in the C++ side
    void
  };
  if (argMap.maybeGet("debug") is Some(AP.BoolValue _)) {
    SKFS.toplevel(SKFS.Context{});
  } else {
    SKSQL.eval(options)
  }
}
