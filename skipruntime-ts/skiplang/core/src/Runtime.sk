module SkipRuntime;

const kGarbageMillis: Int = 30000;

class ReadInCreatorException() extends Exception {
  fun getMessage(): String {
    "A collection cannot be read in the function that creates it."
  }
}

class ExistingResourceException() extends Exception {
  fun getMessage(): String {
    "A resource instance with specified identifier already exists."
  }
}

class UseExternalResourceException() extends Exception {
  fun getMessage(): String {
    "useExternalResource is not allowed in a lazy computation graph."
  }
}

class Params(json: SKJSON.CJSON) extends SKStore.File uses Orderable {
  fun compare(other: Params): Order {
    this.json.compare(other.json)
  }
  fun toString(): String {
    this.json.prettyPrint()
  }
}

class ResourceCollections(
  value: SKStore.EHandle<SKStore.SID, ResourceInfo>,
) extends SKStore.File

class ServiceDefinition(
  service: Service,
  executor: Executor,
) extends SKStore.File

class ServiceInputs(
  service: Service,
  inputs: Map<String, Collection>,
) extends SKStore.File

class Handle(value: SKStore.EHandle<JSONID, JSONFile>) extends SKStore.File

class StatusHandle(
  value: SKStore.EHandle<SKStore.DirName, SKStore.IntFile>,
) extends SKStore.File

class ConvReducer(
  private reducer: Reducer<SKJSON.CJSON, SKJSON.CJSON>,
) extends Reducer<JSONFile, JSONFile> {
  fun getType(): SKStore.File ~> JSONFile {
    JSONFile::type
  }

  fun init(): JSONFile {
    JSONFile(this.reducer.init());
  }

  fun add(acc: JSONFile, value: JSONFile): JSONFile {
    JSONFile(this.reducer.add(acc.json, value.json));
  }

  fun remove(acc: JSONFile, value: JSONFile): ?JSONFile {
    this.reducer.remove(acc.json, value.json).map(x -> JSONFile(x))
  }
}

class ResourceCollection(value: Collection) extends SKStore.File

class ResourceDef(
  service: String,
  name: String,
  params: SKJSON.CJSON,
  instance: Int = 0,
) extends SKStore.File, SKStore.Key {
  //
  fun toString(): String {
    `${this.service}:${this.name}:${this.params.prettyPrint()}:${this.instance}`
  }

  fun toId(): String {
    `${base64(this.service)}_${toResourceId(this.name, this.params)}_${
      this.instance
    }`
  }

  fun derive(instance: Int = 0): ResourceDef {
    !this.instance = instance;
    this;
  }
}

class ResourceStatus(
  loadable: SKStore.DirName,
  status: Status,
) extends SKStore.File {}

class ServiceFile(
  value: Map<String, Collection>,
  inputs: Map<String, Collection>,
) extends SKStore.File

base class Status(
  created: Int,
  modified: Int,
  initialiazed: ?SKJSON.CJSON,
) uses Show {
  children =
  | Loading()
  | Error(error: SKJSON.CJSON)
  | Ok()

  static fun create(): Status {
    time = Time.time_ms();
    Loading(time, time, None())
  }

  fun ok(): Status {
    Ok(this.created, Time.time_ms(), this.initialiazed)
  }

  fun err(error: SKJSON.CJSON): Status {
    Error(error, this.created, Time.time_ms(), this.initialiazed)
  }

  fun init(error: SKJSON.CJSON): Status {
    !this.initialiazed = Some(error);
    this
  }

  fun toString(): String
  | Loading(created, modified, initialiazed) ->
    `Loading{created: ${created}, modified: ${modified}, initialiazed: ${initialiazed.isSome()}}`
  | Error(error, created, modified, initialiazed) ->
    `Error{error: ${error.toJSON()}, created: ${created}, modified: ${modified}, initialiazed: ${initialiazed.isSome()}}`
  | Ok(created, modified, initialiazed) ->
    `Ok{created: ${created}, modified: ${modified}, initialiazed: ${initialiazed.isSome()}}`
}

class StatusFile(service: String, status: Status) extends SKStore.File

class RequestStatuses(statuses: Array<ResourceStatus>) extends SKStore.File {
  //
  fun getResult<T>(values: T): GetResult<T> {
    errors = mutable Vector[];
    for (resourceStatus in this.statuses) {
      resourceStatus.status match {
      | Error(error, _, _, _) -> errors.push(error)
      | _ -> void
      }
    };
    GetResult(values, errors.toArray())
  }

  fun isLoading(): Bool {
    for (resourceStatus in this.statuses) {
      resourceStatus.status match {
      | Loading _ -> break true
      | Error _
      | Ok _ ->
        void
      }
    } else {
      false
    }
  }

  fun getErrors(): Array<SKJSON.CJSON> {
    errors = mutable Vector[];
    for (resourceStatus in this.statuses) {
      resourceStatus.status match {
      | Error(error, _, _, _) -> errors.push(error)
      | Loading _
      | Ok _ ->
        void
      }
    };
    errors.toArray()
  }
}

class StatusRef(
  resourceId: String,
  statusRef: SKStore.DirName,
) extends SKStore.File

class ResourceInfo(
  name: String,
  collection: Collection,
  statusRef: SKStore.DirName,
) extends SKStore.File {
  fun getResult<T>(context: mutable SKStore.Context, values: T): GetResult<T> {
    SKStore.EHandle(
      SKStore.IID::keyType,
      RequestStatuses::type,
      this.statusRef.sub("all"),
    ).maybeGet(context, SKStore.IID(0)) match {
    | Some(statuses) -> statuses.getResult(values)
    | _ -> GetResult(values, Array[])
    }
  }
}

fun initCtx(): SKStore.Context {
  SKStore.Context::create{}
}

class Input(name: String, values: Array<(SKJSON.CJSON, Array<SKJSON.CJSON>)>)

fun buildResourcesGraph(
  context: mutable SKStore.Context,
  definitionHdl: SKStore.EHandle<SKStore.SID, ServiceDefinition>,
  statusHdl: SKStore.EHandle<SKStore.SID, ResourceStatus>,
  servicesHdl: SKStore.EHandle<SKStore.SID, ServiceFile>,
): void {
  dirname = kResourceSessionDir;
  resourcesHdl = context.mkdir(
    SKStore.SID::keyType,
    ResourceDef::type,
    dirname,
  );
  _ = context.mkdir(
    ResourceDef::keyType,
    SKStore.IntFile::type,
    dirname.sub("active"),
  );
  _ = context.mkdir(
    SKStore.SID::keyType,
    SKStore.IntFile::type,
    kResourceGarbageDir,
  );
  idbyresourceHdl = resourcesHdl.map(
    ResourceDef::keyType,
    SKStore.StringFile::type,
    context,
    dirname.sub("idbyresource"),
    (_c, writer, key, it) ~> {
      writer.set(it.first, SKStore.StringFile(key.value));
    },
  );
  availablesHdl = idbyresourceHdl.map(
    ResourceDef::keyType,
    SKStore.IntFile::type,
    context,
    kResourceAvailablesDir,
    (_c, writer, key, _it) ~> {
      // map to ignore array changes
      // to prevent recompute on each add/remove session
      writer.set(key, SKStore.IntFile(1))
    },
  );
  statusesHdl = availablesHdl.map(
    ResourceDef::keyType,
    StatusRef::type,
    context,
    kResourceStatusDir,
    (context, writer, key, _it) ~> {
      resourceId = `${key.toId()}`;
      statusRef = dirname.sub(resourceId);
      // Status graph
      sStatusHdl = context
        .mkdir(
          SKStore.DirName::keyType,
          StatusFile::type,
          statusRef.sub("status"),
          Array[],
          true,
        )
        .map(
          SKStore.UnitID::keyType,
          ResourceStatus::type,
          context,
          statusRef.sub("statuses"),
          (_ctx, writer, key, it) ~> {
            writer.set(
              SKStore.UnitID::singleton,
              ResourceStatus(key, it.first.status),
            );
          },
        );
      _ = sStatusHdl.map(
        SKStore.UnitID::keyType,
        RequestStatuses::type,
        context,
        statusRef.sub("all"),
        (ctx, writer, lkey, it) ~> {
          statuses = statusHdl
            .getArray(ctx, SKStore.SID(key.service))
            .concat(it.toArray());
          requestStatuses = RequestStatuses(statuses);
          writer.set(lkey, requestStatuses);
        },
      );
      writer.set(key, StatusRef(resourceId, statusRef));
    },
  );
  _ = statusesHdl.map(
    ResourceDef::keyType,
    ResourceInfo::type,
    context,
    kResourceCollectionsDir,
    (context, writer, key, it) ~> {
      serviceId = SKStore.SID(key.service);
      resourceId = it.first.resourceId;
      statusRef = it.first.statusRef;
      service = definitionHdl.maybeGet(context, serviceId) match {
      | Some(definition) -> definition.service
      | _ -> return void
      };
      pushContext(context);
      try {
        resource = service.buildResource(key.name, key.params);
        collections = servicesHdl.get(context, serviceId).value;
        collection = resource.instantiate(collections);
        writer.set(key, ResourceInfo(resourceId, collection, statusRef));
        popContext()
      } catch {
      | ex ->
        popContext();
        throw ex
      }
    },
  )
}

fun initService(
  identifier: String,
  service: Service,
  executor: Executor,
): Result<void, .Exception> {
  if (SKStore.gHasContext() == 0) {
    SKStore.gContextInit(initCtx());
  };
  SKStore.runWithResult(context ~> {
    if (context.unsafeMaybeGetEagerDir(kSessionDir) is None()) {
      sessionHdl = context.mkdir(
        SKStore.SID::keyType,
        ServiceDefinition::type,
        kSessionDir,
        Array[(SKStore.SID(identifier), ServiceDefinition(service, executor))],
      );
      servicesHdl = sessionHdl
        .map(
          SKStore.SID::keyType,
          ServiceInputs::type,
          context,
          kSessionDir.sub("inputs"),
          (ctx, writer, key, it) ~> {
            serviceDef = it.first;
            mInputs = mutable Map<String, Collection>[];
            optFrom = serviceDef.service.from();
            serviceDef.service.inputs().each(input -> {
              iDirName = SKStore.DirName::create(`/${base64(key)}/${input}/`);
              values = optFrom match {
              | Some(from) ->
                fDirName = SKStore.DirName::create(
                  `/${base64(from)}/${input}/`,
                );
                ctx.unsafeMaybeGetEagerDir(fDirName) match {
                | Some(dir) ->
                  dir.keys().collect(Array).map(k ->
                    (JSONID::keyType(k), dir.getArrayRaw(k).map(JSONFile::type))
                  )
                | None() ->
                  serviceDef.service.initialData(input).map(v ->
                    (JSONID(v.i0), v.i1.map(x -> JSONFile(x)))
                  )
                }
              | _ ->
                serviceDef.service.initialData(input).map(v ->
                  (JSONID(v.i0), v.i1.map(x -> JSONFile(x)))
                )
              };
              iHdl = ctx.mkdirMulti(
                JSONID::keyType,
                JSONFile::type,
                iDirName,
                values,
              );
              mInputs.add(input, Collection(iHdl))
            });
            writer.set(key, ServiceInputs(serviceDef.service, mInputs.chill()))
          },
        )
        .map(
          SKStore.SID::keyType,
          ServiceFile::type,
          context,
          kGraphDir,
          (ctx, writer, key, it) ~> {
            definition = it.first;
            pushContext(ctx);
            try {
              writer.set(
                key,
                ServiceFile(
                  definition.service.createGraph(definition.inputs),
                  definition.inputs,
                ),
              );
              popContext()
            } catch {
            | ex ->
              popContext();
              throw ex
            }
          },
        );
      // Service status
      statusDefHdl = context.mkdir(
        SKStore.DirName::keyType,
        StatusFile::type,
        kSessionDir.sub("status"),
      );
      statusHdl = statusDefHdl.map(
        SKStore.SID::keyType,
        ResourceStatus::type,
        context,
        kSessionDir.sub("statuses"),
        (_ctx, writer, key, it) ~> {
          writer.set(
            SKStore.SID(it.first.service),
            ResourceStatus(key, it.first.status),
          );
        },
      );
      buildResourcesGraph(context, sessionHdl, statusHdl, servicesHdl)
    } else {
      sessionHdl = SKStore.EHandle(
        SKStore.SID::keyType,
        ServiceDefinition::type,
        kSessionDir,
      );
      sessionHdl.writeArray(
        context,
        SKStore.SID(identifier),
        Array[ServiceDefinition(service, executor)],
      );
      context.update()
    };
    updateContext(context);
    checkSubcriptions(context, identifier, executor);
  })
}

fun closeService_(
  context: mutable SKStore.Context,
  identifier: String,
  update: Bool = true,
): Float {
  sessionHdl = SKStore.EHandle(
    SKStore.SID::keyType,
    ServiceDefinition::type,
    kSessionDir,
  );
  handles = sessionHdl.maybeGet(context, SKStore.SID(identifier)) match {
  | Some(def) ->
    resourceHdl = SKStore.EHandle(
      SKStore.SID::keyType,
      ResourceDef::type,
      kResourceSessionDir,
    );
    activeHdl = SKStore.EHandle(
      ResourceDef::keyType,
      SKStore.IntFile::type,
      kResourceSessionDir.sub("active"),
    );
    todestroy = mutable Vector[];
    resourceHdl.items(context).each(kf ->
      kf.i1.next().each(f -> if (f.service == identifier) todestroy.push(kf.i0))
    );
    todestroy.each(key -> _ = destroyReactiveResource(context, key));
    activeHdl.items(context).each(kf -> {
      kf.i1.next().each(_ ->
        if (kf.i0.service == identifier) {
          activeHdl.writeArray(context, kf.i0, Array[])
        }
      )
    });
    sessionHdl.writeArray(context, SKStore.SID(identifier), Array[]);
    def.service.shutdown()
  | _ -> 0.0
  };
  if (update) context.update();
  handles;
}

fun closeService(identifier: String): Result<Float, .Exception> {
  SKStore.runWithResult(ctx ~> closeService_(ctx, identifier))
}

fun invalidateCollections(
  jsonCollections: SKJSON.CJArray,
): Result<void, .Exception> {
  SKStore.runWithResult(context ~> {
    collections = SKJSON.expectArray(jsonCollections).map(SKJSON.asString);
    collections.each(collection -> {
      context.maybeGetDir(SKStore.DirName::create(collection)) match {
      | Some(dir) -> dir.invalidate(context)
      | _ -> void
      }
    });
    updateContext(context);
  })
}

class LinkToResource(
  serviceId: String,
  service: Service,
  supplier: String,
  instance: String,
  writer: CollectionWriter,
  name: String,
  params: SKJSON.CJSON,
) extends SKStore.Postponable {
  //
  fun perform(context: mutable SKStore.Context): void {
    this.writer.status(context, Status::create(), this.serviceId);
    pushContext(context);
    this.service.subscribe(
      this.supplier,
      this.instance,
      this.writer,
      this.name,
      this.params,
    );
    popContext();
    addSubscription(context, this.writer.dirName);
  }
}

class CloseExternalService(
  service: Service,
  supplier: String,
  instance: String,
  dirName: SKStore.DirName,
  definition: ExternalServiceDef,
) extends SKStore.Postponable {
  fun perform(context: mutable SKStore.Context): void {
    if (isClosed(context, this.definition)) {
      return void;
    };
    // Clear status
    context.maybeGetEagerDir(this.dirName) match {
    | Some(dir) ->
      dirname = sessionId(context, dir) match {
      | Some(sId) -> kResourceSessionDir.sub(sId).sub("status")
      | _ -> kSessionDir.sub("status")
      };
      shdl = SKStore.EHandle(
        SKStore.DirName::keyType,
        StatusFile::type,
        dirname,
      );
      shdl.writeArray(context, this.dirName, Array[])
    | _ -> void
    };
    pushContext(context);
    this.service.unsubscribe(this.supplier, this.instance);
    popContext();
    addClosed(context, this.definition);
  }
}

/**
 * Creates a lazy reactive collection.
 * @param compute - the function to compute entries of the lazy collection
 * @param params - any additional parameters to the computation
 * @returns The resulting lazy collection
 */
fun createLazyCollection(compute: LazyCompute): LazyCollection {
  getContext() match {
  | Some(context) ->
    collectionId = `collection_${SKStore.genSym(0)}`;
    dirName = subDirName(context, collectionId);
    lhdl = SKStore.LHandle::create(
      JSONID::keyType,
      JSONFile::type,
      context,
      dirName,
      (ctx, self, key) ~> {
        pushContext(ctx);
        try {
          res = compute.compute(LazyCollection(self), key.json).map(json ->
            JSONFile(json)
          );
          popContext();
          res
        } catch {
        | ex ->
          popContext();
          throw ex
        }
      },
    );
    LazyCollection(lhdl)

  | _ -> invariant_violation("Store context must be specified.")
  }
}

fun jsonExtract(from: SKJSON.CJObject, pattern: String): Array<SKJSON.CJSON> {
  fieldsList = SKJSON.PatternParser::mcreate(pattern)
    .toplevelPattern()
    .pmatch(from)
    .collect(Array);
  values = mutable Vector[];
  fieldsList.each(fields -> {
    array = fields.collect(Array).map(field -> {
      cjfields = SKJSON.CJFields::create(Array[field], x -> x);
      SKJSON.CJObject(cjfields)
    });
    values.push(SKJSON.CJArray(array));
  });
  values.toArray()
}

fun useExternalCollection(
  supplier: String,
  resource: String,
  params: SKJSON.CJSON,
): Collection {
  getContext() match {
  | Some(context) ->
    context.currentArrow().each(a -> {
      context.unsafeMaybeGetDir(a.childName) match {
      | Some(SKStore.LazyDir _) -> throw UseExternalResourceException()
      | _ -> void
      }
    });
    serviceId = serviceId(context, context.currentArrow()).fromSome(
      "Unable to get service identifier",
    );
    sessionHdl = SKStore.EHandle(
      SKStore.SID::keyType,
      ServiceDefinition::type,
      kSessionDir,
    );
    service = sessionHdl.get(context, SKStore.SID(serviceId)).service;
    collectionId = toSuppliedResourceId(supplier, resource, params);
    dirName = subDirName(context, collectionId);
    paramsDir = dirName.sub("params");
    dataDir = dirName.sub("data");
    hdl = context.mkdir(
      SKStore.UnitID::keyType,
      Params::type,
      paramsDir,
      Array[(SKStore.UnitID::singleton, Params(params))],
    );
    collectionHdl = hdl.map(
      SKStore.UnitID::keyType,
      Handle::type,
      context,
      dirName,
      (context, writer, key, it) ~> {
        storeDir = dirName.sub("store");
        (optOnCreate, onDelete) = getCloseExternalService(
          context,
          storeDir,
        ) match {
        | Some(onDelete) -> (None(), onDelete)
        | _ ->
          definition = ExternalServiceDef(supplier, resource, params);
          instance = Ksuid::create().toString();
          (
            Some(
              LinkToResource(
                serviceId,
                service,
                supplier,
                instance,
                CollectionWriter(storeDir),
                resource,
                it.first.json,
              ),
            ),
            CloseExternalService(
              service,
              supplier,
              instance,
              storeDir,
              definition,
            ),
          )
        };
        store = context.mkdir(
          JSONID::keyType,
          JSONFile::type,
          storeDir,
          Array[],
          true,
          optOnCreate,
          Some(onDelete),
        );
        writer.set(key, Handle(store));
      },
    );
    Collection(
      hdl.map(
        JSONID::keyType,
        JSONFile::type,
        context,
        dataDir,
        (context, writer, key, _it) ~> {
          remote = collectionHdl.get(context, key).value;
          remote.items(context).each(kv -> {
            writer.setArray(kv.i0, kv.i1.collect(Array))
          });
        },
      ),
    )
  | _ -> invariant_violation("Store context must be specified.")
  }
}

class Collection(hdl: SKStore.EHandle<JSONID, JSONFile>) {
  //
  static fun forName(name: String): Collection {
    hdl = SKStore.EHandle<JSONID, JSONFile>(
      JSONID::keyType,
      JSONFile::type,
      SKStore.DirName::create(name),
    );
    Collection(hdl)
  }

  fun getId(): String {
    this.hdl.dirName.toString();
  }

  /**
   * Get all values mapped to by some key of an eager reactive collection.
   */
  fun getArray(key: SKJSON.CJSON): Array<SKJSON.CJSON> {
    getContext() match {
    | Some(context) ->
      dir = context.unsafeGetEagerDir(this.hdl.dirName);
      if (dir.creator == context.currentArrow()) {
        throw ReadInCreatorException()
      };
      dir.getArray(context, JSONID(key)).map(x ~> JSONFile::type(x).json)
    | _ -> invariant_violation("Store context must be specified.")
    }
  }

  /**
   * Get a value of an eager reactive collection, if one exists.
   * If multiple values are mapped to by the key, any of them can be returned.
   * @returns the value for this `key`, or null if no such value exists
   */
  fun getUnique(key: SKJSON.CJSON): ?SKJSON.CJSON {
    value = this.getArray(key);
    if (value.size() == 1) Some(value[0]) else None();
  }

  /**
   * Create a new eager collection by mapping some computation over this one
   * @param mapper - function to apply to each element of this collection
   * @returns The resulting (eager) output collection
   */
  fun map(mapper: Mapper): Collection {
    this.map_(Some(mapper), None())
  }

  /**
   * Create a new eager reactive collection by mapping some computation `mapper` over this
   * one and then reducing the results with `reducer`
   * @param mapper - function to apply to each element of this collection
   * @param reducer - function to combine results of the `mapper`
   * @returns An eager collection containing the output of the reducer
   */
  fun mapReduce(
    mapperOpt: ?Mapper,
    reducer: Reducer<SKJSON.CJSON, SKJSON.CJSON>,
  ): Collection {
    getContext() match {
    | Some(context) ->
      collectionId = `collection_${SKStore.genSym(0)}`;
      dirName = this.hdl.dirName.sub(collectionId);
      mapper = mapperOpt match {
      | None() -> identityMap
      | Some(mapper) ->
        (ctx, writer, key, values) ~> {
          pushContext(ctx);
          try {
            for (entry in mapper.mapEntry(
              key.json,
              values.nonEmptyMap(x -> x.json),
            )) {
              writer.append(JSONID(entry.i0), JSONFile(entry.i1))
            };
            popContext();
          } catch {
          | ex ->
            popContext();
            throw ex
          }
        }
      };
      hdl = this.hdl.mapReduce(
        JSONID::keyType,
        JSONFile::type,
        context,
        dirName,
        mapper,
        accReducer(ConvReducer(reducer)),
      );
      Collection(hdl)
    | _ -> invariant_violation("Store context must be specified.")
    }
  }

  fun nativeMapReduceImpl<V_elt: SKStore.File, V_acc: SKStore.File>(
    mapperOpt: ?Mapper,
    reducer: SKStore.EReducer<V_elt, V_acc>,
    eltType: SKStore.File ~> V_elt,
    inputConv: SKJSON.CJSON ~> V_elt,
    outputConv: V_acc ~> SKJSON.CJSON,
  ): Collection {
    mapper = (ctx, writer, key, values) ~> {
      mapperOpt match {
      | None() ->
        writer.setArray(
          key,
          Array::createFromIterator(
            values.nonEmptyMap(x ~> inputConv(x.json)).values(),
          ), // TODO: use .toArray()
        )
      | Some(mapper) ->
        pushContext(ctx);
        try {
          for (entry in mapper.mapEntry(
            key.json,
            values.nonEmptyMap(x -> x.json),
          )) {
            writer.append(JSONID(entry.i0), inputConv(entry.i1))
          };
          popContext();
        } catch {
        | ex ->
          popContext();
          throw ex
        }
      }
    };
    getContext() match {
    | Some(context) ->
      hdl = this.hdl.mapReduce(
        JSONID::keyType,
        eltType,
        context,
        this.hdl.dirName.sub(`collection_${SKStore.genSym(0)}`),
        mapper,
        reducer,
      );
      Collection(
        hdl.map(
          JSONID::keyType,
          JSONFile::type,
          context,
          this.hdl.dirName.sub(`collection_${SKStore.genSym(1)}`),
          (_ctx, writer, key, values) ~> {
            writer.setArray(
              key,
              Array::createFromIterator(
                values.nonEmptyMap(x -> JSONFile(outputConv(x))).values(),
              ), // TODO: use .toArray()
            )
          },
        ),
      )
    | _ -> invariant_violation("Store context must be specified.")
    }
  }

  fun nativeMapReduce(mapperOpt: ?Mapper, reducer: String): Collection {
    jsonToIntFile = json ~>
      json match {
      | SKJSON.CJInt(x) -> SKStore.IntFile(x)
      | _ -> throw SKStore.Error("Non-number JSON input to native reducer")
      };
    reducer match {
    | "sum" ->
      this.nativeMapReduceImpl(
        mapperOpt,
        SKStore.sumReducer(),
        SKStore.IntFile::type,
        jsonToIntFile,
        file ~> SKJSON.CJInt(file.value),
      )
    | "min" ->
      this.nativeMapReduceImpl(
        mapperOpt,
        SKStore.minReducer(),
        SKStore.IntFile::type,
        jsonToIntFile,
        file ~> SKJSON.CJInt(file.value),
      )
    | "max" ->
      this.nativeMapReduceImpl(
        mapperOpt,
        SKStore.maxReducer(),
        SKStore.IntFile::type,
        jsonToIntFile,
        file ~> SKJSON.CJInt(file.value),
      )
    | "count" ->
      this.nativeMapReduceImpl(
        mapperOpt,
        SKStore.countReducer(),
        JSONFile::type,
        json ~> JSONFile(json),
        file ~> SKJSON.CJInt(file.value),
      )
    | _ -> throw SKStore.Error("Unrecognized native reducer: " + reducer)
    }
  }

  /**
   * Create a new eager collection by keeping only the elements whose keys are in
   * the given ranges.
   */
  fun sliced(ranges: Array<(SKJSON.CJSON, SKJSON.CJSON)>): Collection {
    this.map_(None(), Some(ranges))
  }

  /**
   * Create a new eager collection by keeping the given number of the first elements.
   */
  fun take(limit: Int): Collection {
    getContext() match {
    | Some(context) ->
      collectionId = `collection_${SKStore.genSym(0)}`;
      dirName = this.hdl.dirName.sub(collectionId);
      resHdl = this.hdl.filter(
        context,
        dirName,
        limit,
        noFilter,
        countElementAsOne,
        removeElementAsOne,
        None(),
      );
      Collection(resHdl)
    | _ -> invariant_violation("Store context must be specified.")
    }
  }

  /**
   * Combine some eager collections into one, associating with each key _all_ values
   * associated with that key in any of the input collections.
   * @param others - some other eager collections of compatible type
   * @returns The resulting combination of all input key/value pairs
   */
  fun merge(others: Array<Collection>): Collection {
    getContext() match {
    | Some(context) ->
      collectionId = `collection_${SKStore.genSym(0)}`;
      dirName = this.hdl.dirName.sub(collectionId);
      hdl = SKStore.EHandle::multiMap(
        JSONID::keyType,
        JSONFile::type,
        context,
        Array[this].concat(others).map(c ->
          c match {
          | ci @ Collection _ -> (ci.hdl, (identityMap, None()))
          }
        ),
        dirName,
      );
      Collection(hdl)
    | _ -> invariant_violation("Store context must be specified.")
    }
  }

  /**
   * Get the current number of elements in the collection
   * @returns The current number of elements in the collection
   */
  fun size(): Int {
    getContext() match {
    | Some(context) ->
      dir = context.unsafeGetEagerDir(this.hdl.dirName);
      if (dir.creator == context.currentArrow()) {
        throw ReadInCreatorException()
      };
      dir.size(context)
    | _ -> invariant_violation("Store context must be specified.")
    }
  }

  fun getAll(
    context: mutable SKStore.Context,
  ): Array<(SKJSON.CJSON, Array<SKJSON.CJSON>)> {
    values = mutable Vector<(SKJSON.CJSON, Array<SKJSON.CJSON>)>[];
    dir = context.unsafeGetEagerDir(this.hdl.dirName);
    for (kv in dir.unsafeGetFileIter()) {
      (key, files) = kv;
      values.push(
        (
          JSONID::keyType(key).json,
          files.collect(Array).map(x -> JSONFile::type(x).json),
        ),
      );
    };
    values.toArray();
  }

  fun items(
    context: mutable SKStore.Context,
  ): mutable Iterator<(JSONID, mutable Iterator<JSONFile>)> {
    this.hdl.items(context)
  }

  private fun map_(
    mapperOpt: ?Mapper,
    rangeOpt: ?Array<(SKJSON.CJSON, SKJSON.CJSON)> = None(),
  ): Collection {
    getContext() match {
    | Some(context) ->
      collectionId = `collection_${SKStore.genSym(0)}`;
      dirName = this.hdl.dirName.sub(collectionId);
      mapper = mapperOpt match {
      | None() -> identityMap
      | Some(mapper) ->
        (ctx, writer, key, values) ~> {
          pushContext(ctx);
          try {
            for (entry in mapper.mapEntry(
              key.json,
              values.nonEmptyMap(x -> x.json),
            )) {
              writer.append(JSONID(entry.i0), JSONFile(entry.i1))
            };
            popContext();
          } catch {
          | ex ->
            popContext();
            throw ex
          }
        }
      };
      hdl = this.hdl.map(
        JSONID::keyType,
        JSONFile::type,
        context,
        dirName,
        mapper,
        rangeOpt.map(v ->
          v.map(r -> SKStore.KeyRange::create(JSONID(r.i0), JSONID(r.i1)))
        ),
      );
      Collection(hdl)
    | _ -> invariant_violation("Store context must be specified.")
    }
  }
}

class LazyCollection(private hdl: SKStore.LHandle<JSONID, JSONFile>) {
  //
  static fun forName(name: String): LazyCollection {
    hdl = SKStore.LHandle(
      JSONID::keyType,
      JSONFile::type,
      SKStore.DirName::create(name),
    );
    LazyCollection(hdl)
  }

  fun getId(): String {
    this.hdl.dirName.toString();
  }

  /**
   * Get (and potentially compute) all values mapped to by some key of a lazy reactive
   * collection.
   */
  fun getArray(key: SKJSON.CJSON): Array<SKJSON.CJSON> {
    getContext() match {
    | Some(context) ->
      this.hdl.getArray(context, JSONID(key)).map(file -> file.json)
    | _ -> invariant_violation("Store context must be specified.")
    }
  }

  /**
   * Get (and potentially compute) a value of a lazy reactive collection.
   * @throws {Error} when either zero or multiple such values exist
   */
  fun getUnique(key: SKJSON.CJSON): SKJSON.CJSON {
    getContext() match {
    | Some(context) -> this.hdl.get(context, JSONID(key)).json
    | _ -> invariant_violation("Store context must be specified.")
    }
  }
}

private fun resourceId(
  context: readonly SKStore.Context,
  dir: SKStore.EagerDir,
): ?ResourceDef {
  dir.creator match {
  | Some(arrow) ->
    if (isResourceDir(arrow.parentName)) {
      Some(ResourceDef::keyType(SKStore.TEagerDir::staticKeyOfArrowKey(arrow)))
    } else {
      context.unsafeMaybeGetEagerDir(arrow.parentName) match {
      | Some(sdir) -> resourceId(context, sdir)
      | _ -> None()
      }
    }
  | _ -> None()
  }
}

private fun serviceId(
  context: readonly SKStore.Context,
  keyArrow: ?SKStore.ArrowKey,
): ?String {
  keyArrow match {
  | Some(arrow) ->
    if (isResourceDir(arrow.parentName)) {
      Some(
        ResourceDef::keyType(SKStore.TEagerDir::staticKeyOfArrowKey(arrow))
          .service,
      )
    } else if (arrow.parentName == kSessionDir.sub("inputs")) {
      Some(
        SKStore.SID::keyType(SKStore.TEagerDir::staticKeyOfArrowKey(arrow))
          .value,
      )
    } else {
      context.unsafeMaybeGetEagerDir(arrow.parentName) match {
      | Some(sdir) -> serviceId(context, sdir.creator)
      | _ -> None()
      }
    }
  | _ -> None()
  }
}

private fun sessionId(
  context: readonly SKStore.Context,
  dir: SKStore.EagerDir,
): ?String {
  resourceId(context, dir).map(def -> def.toId())
}

private fun isResourceDir(dirName: SKStore.DirName): Bool {
  dirName == kResourceStatusDir
}

class CollectionWriter(dirName: SKStore.DirName) {
  //
  fun update(
    values: Array<(SKJSON.CJSON, Array<SKJSON.CJSON>)>,
    isInit: Bool,
    executor: Executor,
  ): Result<void, .Exception> {
    performOnTransaction(this.dirName, (root, context) ~>
      this.update_(root, context, values, isInit, executor)
    )
  }

  fun error(error: SKJSON.CJSON): Result<void, .Exception> {
    performOnTransaction(this.dirName, (_root, context) ~> {
      _ = this.updateStatus(context, status ~> status.err(error));
      updateContext(context);
    })
  }

  fun initialized(error: SKJSON.CJSON): Result<void, .Exception> {
    performOnTransaction(
      this.dirName,
      (_root, context) ~> {
        optResource = this.updateStatus(context, status ~> status.init(error));
        context.update();
        checkInitialization(context, optResource);
        checkGarbage(context);
      },
      true,
    )
  }

  fun status(
    context: mutable SKStore.Context,
    status: Status,
    serviceId: String,
  ): void {
    context.maybeGetEagerDir(this.dirName) match {
    | Some(dir) ->
      dirname = sessionId(context, dir) match {
      | Some(sId) -> kResourceSessionDir.sub(sId).sub("status")
      | _ -> kSessionDir.sub("status")
      };
      shdl = SKStore.EHandle(
        SKStore.DirName::keyType,
        StatusFile::type,
        dirname,
      );
      shdl.writeArray(
        context,
        this.dirName,
        Array[StatusFile(serviceId, status)],
      )
    | _ -> void
    };
  }

  private fun updateStatus(
    context: mutable SKStore.Context,
    update: Status ~> Status,
  ): ?ResourceDef {
    context.maybeGetEagerDir(this.dirName) match {
    | Some(dir) ->
      optResource = resourceId(context, dir);
      dirname = optResource match {
      | Some(def) -> kResourceSessionDir.sub(`${def.toId()}`).sub("status")
      | _ -> kSessionDir.sub("status")
      };
      shdl = SKStore.EHandle(
        SKStore.DirName::keyType,
        StatusFile::type,
        dirname,
      );
      statusFile = shdl.get(context, this.dirName);
      status = update(statusFile.status);
      shdl.writeArray(
        context,
        this.dirName,
        Array[StatusFile(statusFile.service, status)],
      );
      optResource
    | _ -> None()
    };
  }

  private fun update_(
    root: mutable SKStore.Context,
    context: mutable SKStore.Context,
    values: Array<(SKJSON.CJSON, Array<SKJSON.CJSON>)>,
    isInit: Bool,
    executor: Executor,
  ): void {
    context.maybeGetEagerDir(this.dirName) match {
    | None() -> return void
    | _ -> void
    };
    _ = this.updateStatus(context, status ~> status.ok());
    writeInCollection(root, context, this.dirName, values, executor, isInit)
  }
}

value class GetResult<T>(values: T, errors: Array<SKJSON.CJSON>)

fun getAll(
  context: mutable SKStore.Context,
  service: String,
  resourceName: String,
  params: SKJSON.CJSON,
): GetResult<Values> {
  resource = getResourceInfo(context, service, resourceName, params);
  resource.getResult(
    context,
    Values(
      resource.collection.getAll(context),
      `${service}/${context.getTick()}`,
    ),
  );
}

fun getForKey(
  context: mutable SKStore.Context,
  service: String,
  resourceName: String,
  params: SKJSON.CJSON,
  key: SKJSON.CJSON,
): GetResult<Array<SKJSON.CJSON>> {
  resource = getResourceInfo(context, service, resourceName, params);
  pushContext(context);
  values = resource.collection.getArray(key);
  popContext();
  resource.getResult(context, values);
}

fun destroyReactiveResource(
  context: mutable SKStore.Context,
  sid: SKStore.SID,
): ResourceDef {
  context
    .getPersistent(`subscription.${sid}`)
    .map(SKStore.IntFile::type) match {
  | Some(subId) ->
    session = subId.value;
    context.getSession(session).each(sub -> {
      close = sub.cmd match {
      | SKStore.NWatch{close} -> close
      | _ -> invariant_violation("Not manage session kind")
      };
      context.removePersistent(`subscription.${sid}`);
      close();
      context.unsubscribe(session);
    })
  | _ -> void
  };
  resourcesHdl = SKStore.EHandle(
    SKStore.SID::keyType,
    ResourceDef::type,
    kResourceSessionDir,
  );
  defintion = resourcesHdl.get(context, sid);
  resourcesHdl.writeArray(context, sid, Array[]);
  defintion
}

fun closeReactiveResource(
  context: mutable SKStore.Context,
  identifier: String,
  update: Bool = true,
): void {
  context
    .getPersistent(`subscription.${identifier}`)
    .map(SKStore.IntFile::type) match {
  | Some(subId) -> unsubscribe(context, subId.value, update)
  | _ ->
    garbageHdl = SKStore.EHandle(
      SKStore.SID::keyType,
      SKStore.IntFile::type,
      kResourceGarbageDir,
    );
    sid = SKStore.SID(identifier);
    if (garbageHdl.maybeGet(context, sid).isSome()) return void;
    time = Time.time_ms();
    garbageHdl.writeArray(context, sid, Array[SKStore.IntFile(time)]);
    if (update) updateContext(context)
  };
}

fun subscribe(
  context: mutable SKStore.Context,
  identifier: String,
  notifier: Notifier,
  optWatermark: ?String,
): Int {
  garbageHdl = SKStore.EHandle(
    SKStore.SID::keyType,
    SKStore.IntFile::type,
    kResourceGarbageDir,
  );
  sid = SKStore.SID(identifier);
  session = SKStore.genSym(0);
  subId = `subscription.${identifier}`;
  if (context.getPersistent(subId).isSome()) {
    return -2
  };
  unsafeMaybeGetResourceDef(context, identifier) match {
  | Some(def) ->
    start = `${def.service}/`;
    from = SKStore.Tick(
      optWatermark match {
      | Some(watermark) if (watermark.startsWith(start)) ->
        watermark.stripPrefix(start).toInt()
      | _ -> 0
      },
    );
    notifier.subscribed();
    context.subscribe(
      session,
      SKStore.TNWatch<SKStore.Key, SKStore.File>{
        dirNameGetter => ctx ~> {
          unsafeGetReactiveResource(ctx, identifier).collection.hdl.dirName
        },
        identifier,
        from,
        fn => (ctx, values, tick, update) ~> {
          ldef = unsafeMaybeGetResourceDef(ctx, identifier).fromSome(
            `Resource ${identifier} should exists`,
          );
          notifier.notify(
            values.map(v ->
              (
                JSONID::keyType(v.i0).json,
                v.i1.map(x -> JSONFile::type(x).json),
              )
            ),
            `${ldef.service}/${tick}`,
            update,
          )
        },
        close => notifier.close,
      },
      None(),
      Some(from),
    );
    context.setPersistent(subId, SKStore.IntFile(session));
    if (garbageHdl.maybeGet(context, sid).isSome()) {
      garbageHdl.writeArray(context, sid, Array[]);
      context.update();
    };
    checkGarbage(context);
    session
  | _ -> -1
  }
}

fun unsubscribe(
  context: mutable SKStore.Context,
  session: Int,
  update: Bool = true,
): void {
  context.getSession(session).each(sub -> {
    (identifier, close) = sub.cmd match {
    | SKStore.NWatch{identifier, close} -> (identifier, close)
    | _ -> invariant_violation("Not manage session kind")
    };
    context.removePersistent(`subscription.${identifier}`);
    close();
    context.unsubscribe(session);
    closeReactiveResource(context, identifier, update);
  });
}

// WRITES

fun put(
  context: mutable SKStore.Context,
  collection: String,
  key: SKJSON.CJSON,
  value: Array<SKJSON.CJSON>,
): void {
  chdl = SKStore.EHandle(
    JSONID::keyType,
    JSONFile::type,
    SKStore.DirName::create(`/${collection}/`),
  );
  chdl.writeArray(context, JSONID(key), value.map(v -> JSONFile(v)));
  updateContext(context);
}

private fun writeInCollection(
  root: mutable SKStore.Context,
  main: mutable SKStore.Context,
  dirName: SKStore.DirName,
  values: Array<(SKJSON.CJSON, Array<SKJSON.CJSON>)>,
  executor: Executor,
  isInit: Bool = false,
): void {
  chdl = SKStore.EHandle(JSONID::keyType, JSONFile::type, dirName);
  transaction = checkTransaction(main);
  keys = if (isInit) {
    transaction.context.maybeGetEagerDir(dirName) match {
    | Some(dir) -> dir.keys().map(JSONID::keyType)
    | _ -> SortedSet<JSONID>[]
    }
  } else {
    SortedSet<JSONID>[]
  };
  toAdd = mutable Vector[];
  values.each(e -> {
    key = JSONID(e.i0);
    fvalues = e.i1.map(v -> JSONFile(v));
    toAdd.push((key, fvalues));
    !keys = keys.remove(key);
  });
  fadded = toAdd.toArray();
  fremoved = keys;
  commit = (ctx) ~> {
    fadded.each(added -> chdl.writeArray(ctx, added.i0, added.i1));
    fremoved.each(key -> chdl.writeArray(ctx, key, Array[]));
  };
  commit(transaction.context);
  // Do not check garbage collection to prevent closing resources
  transaction.context.update();
  finalizeTransaction(root, main, transaction, commit, executor);
}

fun update(
  context: mutable SKStore.Context,
  service: String,
  collection: String,
  values: Array<(SKJSON.CJSON, Array<SKJSON.CJSON>)>,
  executor: Executor,
): void {
  writeInCollection(
    context,
    context,
    SKStore.DirName::create(`/${base64(service)}/${collection}/`),
    values,
    executor,
  )
}

fun delete(
  context: mutable SKStore.Context,
  collection: String,
  key: SKJSON.CJSON,
): void {
  chdl = SKStore.EHandle(
    JSONID::keyType,
    JSONFile::type,
    SKStore.DirName::create(`/${collection}/`),
  );
  chdl.writeArray(context, JSONID(key), Array[]);
  updateContext(context);
}

class ResourceExecutor(
  executor: IntExecutor,
  definition: ResourceDef,
) extends Executor {
  fun resolve(): void {
    this.executor.resolve(this.definition.instance)
  }

  fun reject(exc: .Exception): void {
    this.executor.reject(exc)
  }
}

fun createReactiveResource(
  context: mutable SKStore.Context,
  service: String,
  identifier: String,
  resource: String,
  params: SKJSON.CJSON,
  executor: IntExecutor,
): ResourceInfo {
  resourceHdl = SKStore.EHandle(
    SKStore.SID::keyType,
    ResourceDef::type,
    kResourceSessionDir,
  );
  activeKey = ResourceDef(service, resource, params);
  activeHdl = SKStore.EHandle(
    ResourceDef::keyType,
    SKStore.IntFile::type,
    kResourceSessionDir.sub("active"),
  );
  key = SKStore.SID(identifier);
  resourceHdl.maybeGet(context, key) match {
  | Some _ -> throw ExistingResourceException()
  | _ -> void
  };
  definition = activeHdl.maybeGet(context, activeKey) match {
  | Some(activeFile) ->
    // Add the instance for corresponding active resource
    definition = ResourceDef(service, resource, params, activeFile.value);
    resourceHdl.writeArray(context, key, Array[definition]);
    context.update();
    definition
  | _ ->
    active = SKStore.genSym(0);
    definition = ResourceDef(service, resource, params, active);
    activeHdl.writeArray(context, activeKey, Array[SKStore.IntFile(active)]);
    resourceHdl.writeArray(context, key, Array[definition]);
    context.update();
    definition
  };
  checkResourceInstanceSubcriptions(
    context,
    definition,
    identifier,
    ResourceExecutor(executor, definition),
  );
  checkGarbage(context);
  SKStore.EHandle(
    ResourceDef::keyType,
    ResourceInfo::type,
    kResourceCollectionsDir,
  ).get(context, definition);
}

fun resourceInstances(
  context: mutable SKStore.Context,
  resources: SortedSet<String>,
): Array<ResourceDef> {
  all = resources.isEmpty();
  activeHdl = SKStore.EHandle(
    ResourceDef::keyType,
    SKStore.IntFile::type,
    kResourceSessionDir.sub("active"),
  );
  instances = mutable Vector[];
  activeHdl.items(context).each(kf ->
    kf.i1.next().each(_ ->
      if (all || resources.contains(kf.i0.name)) instances.push(kf.i0)
    )
  );
  instances.toArray()
}

fun reloadResource(
  context: mutable SKStore.Context,
  service: String,
  resource: String,
  params: SKJSON.CJSON,
  executor: IntExecutor,
): void {
  reloadId = Ksuid::create().toString();
  resourceHdl = SKStore.EHandle(
    SKStore.SID::keyType,
    ResourceDef::type,
    kResourceSessionDir,
  );
  definition = ResourceDef(service, resource, params, SKStore.genSym(0));
  resourceHdl.writeArray(context, SKStore.SID(reloadId), Array[definition]);
  context.update();
  checkResourceInstanceSubcriptions(
    context,
    definition,
    reloadId,
    ResourceExecutor(executor, definition),
  );
}

fun replaceActiveResources(
  context: mutable SKStore.Context,
  service: String,
  definitions: Array<ResourceDef>,
): void {
  resourceHdl = SKStore.EHandle(
    SKStore.SID::keyType,
    ResourceDef::type,
    kResourceSessionDir,
  );
  activeHdl = SKStore.EHandle(
    ResourceDef::keyType,
    SKStore.IntFile::type,
    kResourceSessionDir.sub("active"),
  );
  idbyresourceHdl = SKStore.EHandle(
    ResourceDef::keyType,
    SKStore.StringFile::type,
    kResourceSessionDir.sub("idbyresource"),
  );
  definitions.each(d -> {
    activeKey = ResourceDef(service, d.name, d.params);
    activeInstance = activeHdl.get(context, activeKey).value;
    activeDef = activeKey.derive(activeInstance);
    // remove reload id
    idbyresourceHdl.getArray(context, d).each(sidf -> {
      resourceHdl.writeArray(context, SKStore.SID(sidf.value), Array[])
    });
    // replace active def id
    activeDefinitions = idbyresourceHdl.getArray(context, activeDef);
    activeDefinitions.each(sidf -> {
      resourceHdl.writeArray(context, SKStore.SID(sidf.value), Array[d])
    });
    activeHdl.writeArray(
      context,
      activeKey,
      if (service == d.service) Array[SKStore.IntFile(d.instance)] else Array[],
    )
  });
  // Force the notification of replaced resources
  graphHdl = SKStore.EHandle(
    ResourceDef::keyType,
    ResourceInfo::type,
    kResourceCollectionsDir,
  );
  definitions.each(d -> graphHdl.get(context, d).collection.hdl.renew(context));
  updateContext(context);
}

fun destroyResources(
  context: mutable SKStore.Context,
  definitions: Array<ResourceDef>,
): void {
  resourceHdl = SKStore.EHandle(
    SKStore.SID::keyType,
    ResourceDef::type,
    kResourceSessionDir,
  );
  idbyresourceHdl = SKStore.EHandle(
    ResourceDef::keyType,
    SKStore.StringFile::type,
    kResourceSessionDir.sub("idbyresource"),
  );
  definitions.each(d -> {
    idbyresourceHdl.getArray(context, d).each(sidf -> {
      resourceHdl.writeArray(context, SKStore.SID(sidf.value), Array[])
    })
  });
  updateContext(context);
}

fun getReactiveResource(
  context: mutable SKStore.Context,
  identifier: String,
): ResourceInfo {
  maybeGetReactiveResource(context, identifier) match {
  | Some(ri) -> ri
  | _ ->
    invariant_violation(`Reactive resource ${identifier} should be defined.`)
  }
}

fun maybeGetReactiveResource(
  context: mutable SKStore.Context,
  identifier: String,
): ?ResourceInfo {
  graphHdl = SKStore.EHandle(
    ResourceDef::keyType,
    ResourceInfo::type,
    kResourceCollectionsDir,
  );
  SKStore.EHandle(SKStore.SID::keyType, ResourceDef::type, kResourceSessionDir)
    .maybeGet(context, SKStore.SID(identifier))
    .map(definition -> graphHdl.get(context, definition))
}

fun unsafeMaybeGetResourceDef(
  context: readonly SKStore.Context,
  identifier: String,
): ?ResourceDef {
  SKStore.EHandle(
    SKStore.SID::keyType,
    ResourceDef::type,
    kResourceSessionDir,
  ).unsafeMaybeGet(context, SKStore.SID(identifier))
}

fun unsafeMaybeGetReactiveResource(
  context: readonly SKStore.Context,
  identifier: String,
): ?ResourceInfo {
  graphHdl = SKStore.EHandle(
    ResourceDef::keyType,
    ResourceInfo::type,
    kResourceCollectionsDir,
  );
  unsafeMaybeGetResourceDef(context, identifier).map(definition ->
    graphHdl.unsafeGet(context, definition)
  )
}

fun unsafeGetReactiveResource(
  context: readonly SKStore.Context,
  identifier: String,
): ResourceInfo {
  unsafeMaybeGetReactiveResource(context, identifier) match {
  | Some(ri) -> ri
  | _ ->
    invariant_violation(`Reactive resource ${identifier} should be defined.`)
  }
}

fun getResourceInfo(
  context: mutable SKStore.Context,
  service: String,
  resource: String,
  params: SKJSON.CJSON,
): ResourceInfo {
  activeFile = SKStore.EHandle(
    ResourceDef::keyType,
    SKStore.IntFile::type,
    kResourceSessionDir.sub("active"),
  ).get(context, ResourceDef(service, resource, params));
  SKStore.EHandle(
    ResourceDef::keyType,
    ResourceInfo::type,
    kResourceCollectionsDir,
  ).get(context, ResourceDef(service, resource, params, activeFile.value));
}

fun checkGarbage(context: mutable SKStore.Context): void {
  garbageHdl = SKStore.EHandle(
    SKStore.SID::keyType,
    SKStore.IntFile::type,
    kResourceGarbageDir,
  );
  resourceHdl = SKStore.EHandle(
    SKStore.SID::keyType,
    ResourceDef::type,
    kResourceSessionDir,
  );
  time = Time.time_ms();
  destroyed = mutable Vector[];
  resources = SortedSet[];
  garbageHdl.items(context).each(kf -> {
    kf.i1.next().each(f -> {
      suppressed = f.value;
      if (time - suppressed > kGarbageMillis) {
        key = kf.i0;
        !resources = resources.set(resourceHdl.get(context, key));
        destroyed.push(key);
        resourceHdl.writeArray(context, key, Array[]);
      }
    })
  });
  destroyed.each(key -> garbageHdl.writeArray(context, key, Array[]));
  if (!destroyed.isEmpty()) {
    context.update();
    if (checkResources(context, resources)) context.update();
  }
}

fun checkResources(
  context: mutable SKStore.Context,
  resources: SortedSet<ResourceDef>,
): Bool {
  idbyresourceHdl = SKStore.EHandle(
    ResourceDef::keyType,
    SKStore.StringFile::type,
    kResourceSessionDir.sub("idbyresource"),
  );
  activeHdl = SKStore.EHandle(
    ResourceDef::keyType,
    SKStore.IntFile::type,
    kResourceSessionDir.sub("active"),
  );
  availablesHdl = SKStore.EHandle(
    ResourceDef::keyType,
    SKStore.IntFile::type,
    kResourceAvailablesDir,
  );
  hasDestruction = false;
  for (resource in resources) {
    values = idbyresourceHdl.getArray(context, resource);
    if (values.isEmpty()) {
      !hasDestruction = true;
      activeKey = resource with {instance => 0};
      activeHdl.maybeGet(context, activeKey).each(_ -> {
        activeHdl.writeArray(context, activeKey, Array[]);
      });
      availablesHdl.writeArray(context, resource, Array[]);
    }
  };
  hasDestruction
}

fun updateContext(context: mutable SKStore.Context): void {
  context.update();
  checkGarbage(context);
}

module end;
