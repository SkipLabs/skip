module Cli;

base class ArgumentError extends Exception uses Equality {
  children =
  | InvalidArgumentError(arg: String)
  | MissingArgumentError(arg: String)
  | MissingValueError(arg: String)
  | DuplicateValueError(arg: String)

  fun getMessage(): String
  | InvalidArgumentError(arg) -> `Invalid argument ${arg}.`
  | MissingArgumentError(arg) -> `Missing required argument ${arg}.`
  | MissingValueError(arg) -> `No value provided for argument ${arg}.`
  | DuplicateValueError(arg) -> `Multiple values provided for argument ${arg}.`
}

base class Value uses Show, Equality {
  children =
  | BoolValue(Bool)
  | StringValue(String)
  | IntValue(Int)
  | ArrayValue(Array<String>)
  | MissingValue()

  fun toString(): String
  | MissingValue() -> "(no value)"
  | BoolValue(v) -> v.toString()
  | StringValue(v) -> `"${v}"`
  | IntValue(v) -> v.toString()
  | ArrayValue(v) -> "[" + v.map(x -> `"${x}"`).join(", ") + "]"
}

class ParseResults{
  cmd: Command,
  values: Map<String, Value> = Map[],
  extra: Array<String> = Array[],
  subcommand: ?String = None(),
  error: ?ArgumentError = None(),
} {
  fun maybeGetBool(name: String, fail_on_undefined_arg: Bool = true): ?Bool {
    this.getValue(name, fail_on_undefined_arg) match {
    | BoolValue(v) -> Some(v)
    | MissingValue() -> None()
    | _ -> invariant_violation(`Argument ${name} is not boolean`)
    }
  }
  fun getBool(name: String, default: ?Bool = None()): Bool {
    this.maybeGetBool(name, default.isNone()) match {
    | Some(v) -> v
    | None() ->
      default match {
      | Some(v) -> v
      | None() -> invariant_violation(`Argument ${name} is missing`)
      }
    }
  }

  fun maybeGetString(
    name: String,
    fail_on_undefined_arg: Bool = true,
  ): ?String {
    this.getValue(name, fail_on_undefined_arg) match {
    | StringValue(v) -> Some(v)
    | MissingValue() -> None()
    | _ -> invariant_violation(`Argument ${name} is not a string`)
    }
  }

  fun getString(name: String, default: ?String = None()): String {
    this.maybeGetString(name, default.isNone()) match {
    | Some(s) -> s
    | None() ->
      default match {
      | Some(s) -> s
      | None() -> invariant_violation(`Argument ${name} is missing`)
      }
    }
  }

  fun maybeGetInt(name: String, fail_on_undefined_arg: Bool = true): ?Int {
    this.getValue(name, fail_on_undefined_arg) match {
    | IntValue(v) -> Some(v)
    | MissingValue() -> None()
    | _ -> invariant_violation(`Argument ${name} is not an int`)
    }
  }

  fun getInt(name: String, default: ?Int = None()): Int {
    this.maybeGetInt(name, default.isNone()) match {
    | Some(v) -> v
    | None() ->
      default match {
      | Some(v) -> v
      | None() -> invariant_violation(`Argument ${name} is missing`)
      }
    }
  }

  fun maybeGetArray(
    name: String,
    fail_on_undefined_arg: Bool = true,
  ): ?Array<String> {
    this.getValue(name, fail_on_undefined_arg) match {
    | ArrayValue(v) -> Some(v)
    | MissingValue() -> None()
    | _ -> invariant_violation(`Argument ${name} is not an array`)
    }
  }

  fun getArray(name: String, default: ?Array<String> = None()): Array<String> {
    this.maybeGetArray(name, default.isNone()) match {
    | Some(a) -> a
    | None() ->
      default match {
      | Some(a) -> a
      | None() -> invariant_violation(`Argument ${name} is missing`)
      }
    }
  }

  private fun getValue(
    name: String,
    fail_on_undefined_arg: Bool = true,
  ): Value {
    this.values.maybeGet(name) match {
    | Some(v) -> v
    | None() if (fail_on_undefined_arg) ->
      invariant_violation(`Argument ${name} is undefined`)
    | None() -> MissingValue()
    }
  }

  fun maybeGetSubcommand(): ?String {
    this.subcommand
  }

  fun getCommand(): Command {
    this.cmd
  }
}

fun parseArgs(cmd: Command): ParseResults {
  parseArgsFrom(cmd, Environ.args().drop(1).collect(Array))
}

fun parseArgsFrom(cmd: Command, argv: Sequence<String>): ParseResults {
  parse(cmd, argv.values())
}

private fun updateValue(
  values: mutable Map<String, Value>,
  arg: Arg,
  value: Value,
): ?ArgumentError {
  arg match {
  | ArrayArg _ ->
    strValue = value match {
    | StringValue(v) -> v
    | _ -> invariant_violation(`Unexpected value type for ArrayArg`)
    };

    values.maybeGet(arg.name) match {
    | Some(ArrayValue(arr)) ->
      values.set(arg.name, ArrayValue(arr.concat(Array[strValue])))
    | None() -> values.set(arg.name, ArrayValue(Array[strValue]))
    | Some(v) -> invariant_violation(`Unexpected value type ${v} for ArrayArg`)
    }
  | _ ->
    if (!values.containsKey(arg.name)) {
      values.set(arg.name, value)
    } else {
      return Some(DuplicateValueError(arg.name))
    }
  };

  None()
}

private fun defaultValue(arg: Arg): Value {
  arg match {
  | ValuedArg _ -> arg._default.default(MissingValue())
  | BoolArg _ -> arg._default.default(BoolValue(false))
  }
}

private fun subcommand_map(subcommands: Array<Command>): Map<String, Command> {
  res = mutable Map[];
  for (subcmd in subcommands) {
    if (res.containsKey(subcmd.name)) {
      invariant_violation(`Duplicate subcommand ${subcmd.name}`)
    };
    res.set(subcmd.name, subcmd);
    subcmd._short.each(n -> {
      if (res.containsKey(n)) {
        invariant_violation(`Duplicate subcommand short alias ${n}`)
      };
      res.set(n, subcmd)
    })
  };

  res.chill()
}

private fun arg_maps(args: Array<Arg>): (Array<Arg>, Map<String, Arg>) {
  argsNames = mutable Set[];
  posArgs = mutable Vector<Arg>[];
  // TODO: options is a bad name. Maybe flag_args?
  options = mutable Map[];
  for (arg in args) {
    if (argsNames.contains(arg.name)) {
      invariant_violation(`Duplicate argument ${arg.name}`)
    };
    argsNames.add(arg.name);

    if (arg._positional) {
      if (posArgs.size() > 0) {
        prevArg = posArgs[posArgs.size() - 1];
        if (prevArg is ArrayArg _) {
          invariant_violation(
            `Positional argument ${
              arg.name
            } cannot appear after array positional argument ${prevArg.name}`,
          )
        }
      };
      posArgs.push(arg);
    } else {
      if (arg._short.isSome()) {
        options.add(`-${arg._short.fromSome()}`, arg);
        if (arg._long.isNone()) {
          if (arg._negatable) {
            invariant_violation(
              `Argument ${arg.name} cannot be negatable without a long name`,
            )
          };
          continue
        }
      };

      // Use arg name as default long flag for convenience.
      longFlag = arg._long.default(arg.name);
      if (arg is BoolArg _ && longFlag.startsWith("no-")) {
        positiveFlag = longFlag.stripPrefix("no-");
        invariant_violation(
          `Invalid boolean argument name ${longFlag}. Declare a negatable ${positiveFlag} instead.`,
        )
      };
      options.add(`--${longFlag}`, arg);
      if (arg._negatable) {
        options.add(`--no-${longFlag}`, arg);
      };
    }
  };

  (posArgs.collect(Array), options.chill())
}

private fun parse(
  cmd: Command,
  iterator: mutable Iterator<String>,
): ParseResults {
  Parser::create(cmd).parse(iterator)
}

mutable class Parser(
  cmd: Command,
  subcommands: Map<String, Command>,
  posArgs: Array<Arg>,
  options: Map<String, Arg>,
  values: mutable Map<String, Value> = mutable Map[],
  mutable extra: mutable Vector<String> = mutable Vector[],
  mutable posArgId: Int = 0,
  mutable hasExtra: Bool = false,
) {
  static fun create(
    cmd: Command,
    globals: Array<Arg> = Array[],
    values: mutable Map<String, Value> = mutable Map[],
  ): mutable Parser {
    subcommands = subcommand_map(cmd._subcommands);
    (posArgs, options) = arg_maps(cmd._args.concat(globals));

    mutable Parser(cmd, subcommands, posArgs, options, values)
  }

  mutable fun parse(iterator: mutable Iterator<String>): ParseResults {
    error: ?ArgumentError = None();
    subcommand: ?String = None();
    loop {
      iterator.next() match {
      | None() -> break void
      | Some(str) if (this.hasExtra) -> this.extra.push(str)
      | Some(str) if (this.subcommands.containsKey(str)) ->
        subcmd = this.subcommands.get(str);
        !subcommand = Some(subcmd.name);

        // TODO: This does not support nested subcommands (which probably
        // shouldn't exist).
        globalArgs = this.cmd._args.filter(a -> a._global);
        subcmdParser = Parser::create(subcmd, globalArgs, this.values);
        res = subcmdParser.parse(iterator);
        if (res.error.isSome()) {
          !error = res.error;
          break void
        };

        // TODO: This is dirty.
        this.!extra = Vector::mcreateFromItems(res.extra);

        break void
      | Some("--") ->
        if (!this.cmd._extra) {
          !error = Some(InvalidArgumentError("--"));
          break void
        };
        this.!hasExtra = true
      | Some(str) ->
        this.parse_next_args(str, iterator) match {
        | Failure(err) ->
          !error = Some(err);
          break void
        | Success((arg, value)) ->
          arg match {
          | BoolArg _ ->
            if (!this.values.containsKey(arg.name)) {
              this.values.set(arg.name, BoolValue(!str.startsWith("--no-")))
            } else {
              !error = Some(DuplicateValueError(arg.name));
              break void
            }
          | _ ->
            updateValue(this.values, arg, value) match {
            | err @ Some _ ->
              !error = err;
              break void
            | None() -> void
            }
          }
        }
      }
    };

    if (error.isNone()) {
      for (arg in this.cmd._args) {
        if (!this.values.containsKey(arg.name)) {
          if (arg._required) {
            !error = Some(MissingArgumentError(arg.name));
            break void
          } else {
            env_var = arg._env.map(v -> Environ.var(v));
            value = arg match {
            | StringArg _ -> env_var.map(v -> StringValue(v))
            | IntArg _ -> env_var.map(v -> IntValue(v.toInt()))
            | BoolArg _ ->
              env_var.map(b -> BoolValue(b != "no" && b != "false" && b != "0"))
            | _ ->
              env_var.map(_ -> invariant_violation("Unexpected argument type."))
            };
            this.values.set(arg.name, value.default(defaultValue(arg)))
          }
        }
      }
    };

    ParseResults{
      cmd => this.cmd,
      subcommand,
      values => this.values.chill(),
      extra => Array::createFromItems(this.extra.chill()),
      error => error,
    }
  }

  private mutable fun parse_next_args(
    str: String,
    iterator: mutable Iterator<String>,
  ): Result<(Arg, Value), ArgumentError> {
    (argName, argValue) = if (str.contains("=")) {
      (k, v) = str.splitFirst("=");
      (k, Some(v))
    } else {
      (str, None())
    };
    this.options.maybeGet(argName) match {
    | Some(arg @ ValuedArg _) ->
      strValue = argValue match {
      | Some(v) -> v
      | None() ->
        iterator.next() match {
        | Some(v) -> v
        | None() -> return Failure(MissingValueError(arg.name))
        }
      };
      parse_value(arg, strValue).map(v -> (arg, v))
    | Some(arg) -> Success((arg, BoolValue(!str.startsWith("--no-"))))
    | None() if (!str.startsWith("-") && this.posArgId < this.posArgs.size()) ->
      arg = this.posArgs[this.posArgId];
      res = parse_value(arg, str).map(v -> (arg, v));
      arg match {
      | ArrayArg _ -> void
      | _ -> this.!posArgId = this.posArgId + 1
      };
      res
    | None() -> // Check for short forms that take values such as `-O2`.
      !argName = str.take(2);
      strValue = str.substring(str.getIter().forward(2));
      this.options.maybeGet(argName) match {
      | Some(arg @ StringArg _)
      | Some(arg @ IntArg _) ->
        parse_value(arg, strValue).map(v -> (arg, v))
      | _ -> Failure(InvalidArgumentError(str))
      }
    }
  }
}

private fun parse_value(
  arg: Arg,
  strValue: String,
): Result<Value, ArgumentError> {
  arg match {
  | StringArg _
  | ArrayArg _ ->
    Success(StringValue(strValue))
  | IntArg _ ->
    strValue.toIntOption() match {
    | Some(v) -> Success(IntValue(v))
    | _ -> Failure(InvalidArgumentError(arg.name))
    }
  | BoolArg _ -> invariant_violation("Unexpected parse_value() for boolean arg")
  }
}

module end;
