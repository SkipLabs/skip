/**
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

module Main;

class Config private {
  exportedFunctions: UnorderedSet<String>,
  exportedAsFunctions: UnorderedMap<String, String>,
  disasmAll: Bool,
  disasmAnnotated: Bool,
  disasmFiles: UnorderedSet<String>,
  disasmFunctions: UnorderedSet<String>,
  outputFiles: Array<String>,
  preambleFiles: Array<String>,
  // profilePath: String,
  wasm: Bool,
  asan: Bool,
  autogc: Bool,
  sampleRate: Int,
  // NOTE: Using fully specialized class names yields more detailed stats
  // info, but inhibits sharing, which increases compilation time and
  // binary sizes.
  useSpecializedNames: Bool,
  version: Bool,
  check: Bool,
} {
  static fun make(result: Cli.ParseResults): this {
    disasmAll = result.getBool("disasm-all");
    disasmAnnotated = result.getBool("disasm-annotated");
    disasmFiles = UnorderedSet::createFromItems(result.getArray("disasm-file"));
    disasmFunctions = UnorderedSet::createFromItems(
      result.getArray("disasm-function"),
    );
    exportedFunctions = UnorderedSet::createFromItems(
      result.getArray("export-function"),
    );
    exportedAsFunctions = UnorderedSet::createFromItems(
      result.getArray("export-function-as"),
    );
    preambleFiles = result.getArray("preamble");
    outputFiles = result.getArray("output");
    // profilePath = result.getString("profile-path");
    wasm = result.getBool("wasm");
    asan = result.getBool("asan");
    autogc = result.getBool("autogc");
    sampleRate = result.getString("sample-rate").toInt();
    useSpecializedNames = result.getBool("use-specialized-names");
    version = result.getBool("version");
    check = result.getBool("check");

    if (version) {
      print_string(getBuildVersion());
      skipExit(0);
    };

    exportAs = mutable UnorderedMap[];
    for (f in exportedAsFunctions) {
      vals = f.split("=");
      if (vals.size() != 2 || vals[0].isEmpty() || vals[1].isEmpty()) {
        print_error("Invalid --export-function-as: " + f + "\n");
        skipExit(1)
      };

      skipName = vals[0];
      cppName = vals[1];

      if (!exportAs.maybeSet(skipName, cppName)) {
        oldCppName = exportAs[skipName];
        if (oldCppName != cppName) {
          print_error(
            "Conflicting --export-function-as for " +
              skipName +
              ": " +
              oldCppName +
              " and " +
              cppName +
              "\n",
          );
          skipExit(1)
        }
      }
    };

    static{
      exportedFunctions,
      exportedAsFunctions => exportAs.chill(),
      disasmAll,
      disasmAnnotated,
      disasmFiles,
      disasmFunctions,
      outputFiles,
      preambleFiles,
      // profilePath,
      wasm,
      asan,
      autogc,
      sampleRate,
      useSpecializedNames,
      version,
      check,
    }
  }
}

module end;

fun targetIsWasm(): Bool {
  kConfig.mainConfig.wasm
}

fun createOptimizedFunctions(
  context: mutable SKFS.Context,
  env: GlobalEnv,
  config: Config.Config,
): GlobalEnv {
  runCompilerPhase("native/compile", () -> {
    !env = Optimize.compileAll(context, env, config);

    // Find all the functions that are still reachable from the root set,
    // post-inlining, dead code elimination, etc.
    !env.sfuns = findAllReachableFuns(
      keep -> {
        // Seed the "reachable" recursion with functions we definitely
        // need to emit.
        keep(env.initializeAllConstsID);
        for (f in env.sfuns) {
          if (f.isDisasm || f.isRuntimeExport) {
            keep(f.id)
          }
        };
        env.runtimeFunctions.values().each(keep)
      },
      env,
    );

    // Now that we have computed the fields for all of the various
    // coroutine classes, we can finally analyze pointer escape info.
    !env = Escape.computeWhetherPointersCanEscape(env);

    // optimize.sk steps (5) Lower + (6) Lay out vtables.
    !env = Lower.lowerFunctions(env, config)
  });

  env
}

fun compile(
  isInit: Bool,
  config: Config.Config,
  context: mutable SKFS.Context,
  fileNames: Array<String>,
): void {
  // Convert project:program-unit targets to a list of source files.

  if (fileNames.isEmpty()) {
    print_error("fatal error: no input files\n");
    skipExit(4); // Exit code used by g++ for no input files
  };

  cfg = config.mainConfig;

  // Are we in "disassemble" mode?
  disasm = (
    cfg.disasmAll ||
    cfg.disasmAnnotated ||
    !cfg.disasmFiles.isEmpty() ||
    !cfg.disasmFunctions.isEmpty()
  );

  // Create a filter for what functions to disassemble.
  //
  // Note that for "disasmAll" we do not return true, since we only want
  // to disassemble code which is actually used, and returning true would
  // force everything to be compiled just so it could be disassembled.
  shouldDisasm = (
    funDef ~>
      disasm &&
        (cfg.disasmFunctions.contains(funDef.origName) ||
          (cfg.disasmAnnotated &&
            annotationsContain(funDef.annotations, "@disasm", funDef.getPos())))
  );

  // Create a filter for what functions to compile.
  shouldRuntimeExport = (
    funDef ~>
      AsmOutput.cppIsExported(
        funDef.origName,
        funDef.annotations,
        funDef.getPos(),
        config.mainConfig.exportedAsFunctions,
      )
  );

  if (context.unsafeMaybeGetDir(FileCache.fileDirName) is None()) {
    _ = context.mkdir(x ~> x, FileCache.fileDirName, false, Array[]);
    _ = context.mkdir(x ~> x, FileCache.fileTimeDirName, false, Array[]);
    _ = context.mkdir(x ~> x, FileCache.allFilesDirName, false, Array[]);
  };

  FileCache.writeFiles(context, fileNames);

  backendDirName = SKFS.DirName::create("/backend/");
  backendSinkDirName = SKFS.DirName::create("/backendSink/");

  if (context.unsafeMaybeGetEagerDir(backendDirName) is None()) {
    outerIst = OuterIstToIR.makeOuterIst(context);

    defsProj = outerIst.getFunsProj(context);
    constsProj = outerIst.getConstsProj(context);

    converter = OuterIstToIR.Converter::create(
      context,
      SKFS.DirName::create("/converter/"),
      outerIst,
    );

    backendDir = context.mkdir(
      SKFS.IntFile::fromFile,
      backendDirName,
      false,
      if (isInit) Array[] else Array[(SKFS.IID(0), SKFS.IntFile(-128))],
    );

    _ = backendDir.contextWriterKeyValues(
      SKFS.IntFile::fromFile,
      context,
      backendSinkDirName,
      (context, _writer, _key, _values) ~> {
        if (config.mainConfig.check) {
          return void;
        };

        context.getGlobal("ERRORS") match {
        | None() -> void
        | Some(errors) ->
          SkipError.printErrorsAndExit(
            SkipError.ErrorsFile::fromFile(errors).value.reversed().toArray(),
          )
        };

        env = OuterIstToIR.createIR(
          context,
          config,
          shouldDisasm,
          shouldRuntimeExport,
          outerIst,
          converter,
          constsProj,
          defsProj,
        );

        !env = createOptimizedFunctions(context, env, config);
        defs = runCompilerPhase("native/create_asm_graph", () -> {
          AsmOutput.createAsmDefGraph(env, config)
        });

        runCompilerPhase("native/merge_asm_graph", () -> {
          AsmOutput.mergeIdenticalAsmDefs(defs, config.verbose)
        });

        runCompilerPhase("native/create_asm_symbols", () -> {
          AsmOutput.assignFinalSymbols(defs)
        });

        runCompilerPhase("native/write_asm_files", () -> {
          AsmOutput.writeOutputFiles(defs, fileNames, config)
        });
      },
    );
  } else {
    context
      .unsafeGetEagerDir(backendDirName)
      .writeArray(
        context,
        SKFS.IID(0),
        Array[SKFS.IntFile(context.tick.value)],
      );
  };
  context.update()
}
