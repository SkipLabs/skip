module Skargo;

class LexVersion(
  major: Int,
  minor: ?Int = None(),
  patch: ?Int = None(),
) uses Equality {
  //
  fun toCaretRangeConstraint(): RangeConstraint {
    (this.minor, this.patch) match {
    | (Some(minor), Some(patch)) ->
      if (this.major > 0) {
        //1.2.3  :=  >=1.2.3, <2.0.0
        RangeConstraint(
          Version(this.major, minor, patch),
          Some(Version(this.major + 1, 0, 0)),
        )
      } else if (minor > 0) {
        // 0.2.3  :=  >=0.2.3, <0.3.0
        RangeConstraint(
          Version(this.major, minor, patch),
          Some(Version(this.major, minor + 1, 0)),
        )
      } else {
        // 0.0.3  :=  >=0.0.3, <0.0.4
        RangeConstraint(
          Version(this.major, minor, patch),
          Some(Version(this.major, 0, patch + 1)),
        )
      }
    | (Some(minor), None()) ->
      if (this.major > 0) {
        // 1.2    :=  >=1.2.0, <2.0.0
        RangeConstraint(
          Version(this.major, minor, 0),
          Some(Version(this.major + 1, 0, 0)),
        )
      } else {
        // 0.2    :=  >=0.2.0, <0.3.0
        // 0.0    :=  >=0.0.0, <0.1.0
        RangeConstraint(
          Version(this.major, minor, 0),
          Some(Version(this.major, minor + 1, 0)),
        )
      }
    | (None(), None()) ->
      // 1      :=  >=1.0.0, <2.0.0
      // 0      :=  >=0.0.0, <1.0.0
      RangeConstraint(
        Version(this.major, 0, 0),
        Some(Version(this.major + 1, 0, 0)),
      )
    | _ -> invariant_violation("Unsupported version")
    }
  }

  fun toTildeRangeConstraint(): RangeConstraint {
    (this.minor, this.patch) match {
    | (Some(minor), Some(patch)) ->
      //~1.2.3  := >=1.2.3, <1.3.0
      RangeConstraint(
        Version(this.major, minor, patch),
        Some(Version(this.major, minor + 1, 0)),
      )
    | (Some(minor), None()) ->
      //~1.2    := >=1.2.0, <1.3.0
      RangeConstraint(
        Version(this.major, minor, 0),
        Some(Version(this.major, minor + 1, 0)),
      )
    | (None(), None()) ->
      //~1      := >=1.0.0, <2.0.0
      RangeConstraint(
        Version(this.major, 0, 0),
        Some(Version(this.major + 1, 0, 0)),
      )
    | _ -> invariant_violation("Unsupported version")
    }
  }

  fun toEquals(): RangeConstraint {
    low = Version(this.major, this.minor.default(0), this.patch.default(0));
    high = Version(
      this.major,
      this.minor.default(0),
      this.patch.default(0) + 1,
    );
    RangeConstraint(low, Some(high))
  }

  fun toVersion(next: Bool = false): Version {
    Version(
      this.major,
      this.minor.default(0),
      this.patch.default(0) + if (next) 1 else 0,
    )
  }
}

mutable class VersionLexer private {position: mutable Lexer.LexingPosition} {
  //
  mutable fun lex(): RangeConstraint {
    this.skipWhitespace();
    this.peek() match {
    | '~' ->
      this.advance();
      this.lexVersion().toTildeRangeConstraint()
    | '*' -> RangeConstraint(Version(0, 0, 0), None())
    | '=' ->
      this.advance();
      this.skipWhitespace();
      this.lexVersion().toEquals()
    | '>' ->
      this.advance();
      lstrict = true;
      this.peek() match {
      | '=' ->
        this.advance();
        !lstrict = false
      | _ -> void
      };
      this.skipWhitespace();
      low = this.lexVersion().toVersion(lstrict);
      this.skipWhitespace();
      this.peek() match {
      | ',' ->
        hstrict = true;
        this.advance();
        this.skipWhitespace();
        this.peek() match {
        | '<' ->
          this.advance();
          this.peek() match {
          | '=' ->
            this.advance();
            !hstrict = false
          | _ -> void
          }
        | _ -> void
        };
        this.skipWhitespace();
        high = this.lexVersion().toVersion(!hstrict);
        RangeConstraint(low, Some(high))
      | c if (c == Chars.null) -> RangeConstraint(low, None())
      | _ -> this.version_violation()
      }
    | '<' ->
      this.advance();
      this.skipWhitespace();
      hstrict = true;
      this.peek() match {
      | '=' ->
        this.advance();
        this.skipWhitespace();
        !hstrict = false
      | _ -> void
      };
      high = this.lexVersion().toVersion(!hstrict);
      RangeConstraint(Version(0, 0, 0), Some(high))
    | '^' ->
      this.advance();
      this.lexVersion().toCaretRangeConstraint()
    | c if (Chars.isDigit(c)) ->
      major = this.lexInt();
      this.peek() match {
      | '.' ->
        this.advance();
        this.peek() match {
        | '*' ->
          // 1.*   := >=1.0.0, <2.0.0
          RangeConstraint(Version(major, 0, 0), Some(Version(major + 1, 0, 0)))
        | _ ->
          minor = this.lexInt();
          this.peek() match {
          | '.' ->
            this.advance();
            this.peek() match {
            | '*' ->
              // 1.2.* := >=1.2.0, <1.3.0
              RangeConstraint(
                Version(major, minor, 0),
                Some(Version(major, minor + 1, 0)),
              )
            | _ ->
              patch = this.lexInt();
              LexVersion(
                major,
                Some(minor),
                Some(patch),
              ).toCaretRangeConstraint()
            }
          | c1 if (c1 == Chars.null || Chars.isWhitespace(c1)) ->
            LexVersion(major, Some(minor)).toCaretRangeConstraint()
          | _ -> this.version_violation()
          }
        }
      | c1 if (c1 == Chars.null || Chars.isWhitespace(c1)) ->
        LexVersion(major).toCaretRangeConstraint()
      | _ -> this.version_violation()
      }
    | _ -> this.version_violation()
    };
  }

  mutable fun lexVersion(): LexVersion {
    major = this.lexInt();
    this.peek() match {
    | '.' ->
      this.advance();
      minor = this.lexInt();
      this.peek() match {
      | '.' ->
        this.advance();
        patch = this.lexInt();
        LexVersion(major, Some(minor), Some(patch))
      | c if (c == Chars.null || Chars.isWhitespace(c) || c == ',') ->
        LexVersion(major, Some(minor))
      | _ -> this.version_violation()
      }
    | c if (c == Chars.null || Chars.isWhitespace(c) || c == ',') ->
      LexVersion(major)
    | _ -> this.version_violation()
    }
  }

  mutable fun lexInt(): Int {
    c = this.peek();
    invariant(Chars.isDigit(c), "Expected digit");
    current = 0;
    while (Chars.isDigit(c)) {
      v = c.code() - 48;
      !current = current * 10 + v;
      this.advance();
      !c = this.peek();
    };
    current
  }

  // Creates a Lexer positioned at the start of a String.
  static fun create(source: String): mutable this {
    static::createFromPosition(Lexer.LexingPosition::create(source));
  }

  static fun createFromPosition(
    position: mutable Lexer.LexingPosition,
  ): mutable this {
    mutable static{position}
  }

  mutable fun skipWhitespace(): void {
    this.skipChars(Chars.isWhitespace);
  }

  mutable fun skipDigitSequence(): void {
    this.skipChars(Chars.isDigit);
  }

  // Used to mark the start of the next token.
  mutable fun mark(): mutable Lexer.LexingPosition {
    this.position.clone();
  }

  // Skip characters while predicate is true.
  protected mutable fun skipChars(predicate: Char ~> Bool): void {
    loop {
      if (!predicate(this.peek())) break void;
      this.advance();
    }
  }

  // Returns the next character.
  protected readonly fun peek(): Char {
    this.position.peek();
  }

  // Returns the char at offset beyond the current character.
  protected readonly fun peekOffset(offset: Int): Char {
    this.position.peekOffset(offset);
  }

  // Is the next char ch?
  protected readonly fun peekChar(ch: Char): Bool {
    this.position.peekChar(ch);
  }

  // Is the char at offset ch?
  protected readonly fun peekCharOffset(ch: Char, offset: Int): Bool {
    this.position.peekCharOffset(ch, offset);
  }

  // Consume a character.
  protected mutable fun advance(): void {
    this.position.advance();
  }

  // Consume a char and return the consumed char.
  protected mutable fun next(): Char {
    this.position.next();
  }

  protected readonly fun atEnd(): Bool {
    this.position.atEnd()
  }

  protected readonly fun getTokenText(
    start: readonly Lexer.LexingPosition,
  ): String {
    start.getText(this.position);
  }

  protected readonly fun version_violation<T>(): T {
    invariant_violation(
      "Unsupported version constraint " + this.position.source,
    )
  }
}
